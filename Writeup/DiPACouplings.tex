\documentclass[12pt]{article}


\usepackage[shortlabels]{enumitem} 
\usepackage{amsmath,amsfonts,amssymb,amsthm,bm,mathrsfs}
\usepackage{fancyhdr}
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{stmaryrd}
% \usepackage{mdframed}
\usepackage{hyperref}
\usepackage{xcolor, soul}
\sethlcolor{cyan}


\newcommand{\NN}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\notimplies}{\;\not\!\!\!\implies}
\newcommand{\gguard}[1][x]{\texttt{insample}\geq#1}
\newcommand{\lguard}[1][x]{\texttt{insample} < #1}
\newcommand{\mvgguard}[1][\texttt{x}_1]{\texttt{insample}^{(#1)}\geq#1}
\newcommand{\mvlguard}[1][\texttt{x}_1]{\texttt{insample}^{(#1)}<#1}
\newcommand{\gaguard}{n<N \text{ AND } \texttt{insample} \geq\ \texttt{x}}
\newcommand{\laguard}{n<N\text{ AND }\texttt{insample} < \texttt{x}}
\newcommand{\itgguard}{\texttt{input}\neq\tau\text{ AND } \texttt{insample}\geq\texttt{x}}
\newcommand{\itlguard}{\texttt{input}\neq\tau\text{ AND }\texttt{insample} < \texttt{x}}
\newcommand{\range}{\texttt{range}}
\newcommand{\brangle}[1]{\langle#1 \rangle}
\newcommand{\guard}{\texttt{guard}}
\newcommand{\trans}{\texttt{trans}}
\newcommand{\Lap}{\texttt{Lap}}
\newcommand{\gcycle}{\texttt{G}-cycle}
\newcommand{\lcycle}{\texttt{L}-cycle}
\newcommand{\sgn}{\texttt{sgn}}
\newcommand{\andtext}{\text{ AND }}
\newcommand{\ortext}{\text{ OR }}
\newcommand{\supp}{\texttt{supp}}

\newcommand{\im}{\texttt{im}}

\newcommand{\todo}[2]{\textcolor{#1}{\textbf{#2}}}
\newcommand{\sasho}[1]{\todo{blue}{Sasho: <<#1>>}}
\newcommand{\sky}[1]{\todo{green}{Sky: <<#1>>}}
\newcommand{\azadeh}[1]{\todo{red}{Azadeh: <<#1>>}}
\newcommand{\vishnu}[1]{\todo{magenta}{Vishnu: <<#1>>}}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\providecommand{\floor}[1]{\lfloor #1 \rfloor}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{obs}[thm]{Observation}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{const}[thm]{Construction}
\newtheorem{examp}[thm]{Example}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{rmk}[thm]{Remark}
\newtheorem{clm}[thm]{Claim}

\newcommand{\isto}{\stackrel{\sim}{\smash{\longrightarrow}\rule{0pt}{0.4ex}}} 
\graphicspath{ {./} }
\bibliographystyle{plain} 


\begin{document}

\input{intro}
\input{preliminaries.tex}

\section{Deciding Privacy Using Couplings}

We now begin the process of building up a program model through the lens of regular languages. 
We will model programs as simply regular languages comprised of possible program paths (or executions) where each path corresponds to a word in the language. This approach simultaneously allows us to build approximate liftings for each path that prove the overall privacy of a program.

We begin with single transitions between two program locations, which correspond directly to characters in our alphabet. 

\sky{todo: add a note about treating $\varepsilon$ as a parameter to the program}

\input{sv-transitions.tex}

\input{sv-paths.tex}

\input{sv-loops.tex}

\input{sv-programs.tex}

\input{sv-decision-alg.tex}

\section{Optimizing Privacy Cost with Couplings}

\input{sv-opt.tex}

\input{mv-extensions.tex}

\input{relatedwork.tex}

{\color{red} need to reformat some citations at some point}
\bibliography{./dipalibrary}

\input{appendix.tex}

\end{document} 