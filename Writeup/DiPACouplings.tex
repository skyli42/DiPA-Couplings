\documentclass[12pt]{article}

\usepackage[shortlabels]{enumitem} 
\usepackage{amsmath,amsfonts,amssymb,amsthm,bm,mathrsfs}
\usepackage{fancyhdr}
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{stmaryrd}
% \usepackage{mdframed}
\usepackage{hyperref}
\usepackage{xcolor, soul}
\sethlcolor{cyan}


\newcommand{\NN}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\notimplies}{\;\not\!\!\!\implies}
\newcommand{\gguard}[1][x]{\texttt{insample}\geq #1}
\newcommand{\lguard}[1][x]{\texttt{insample} < #1}
\newcommand{\gaguard}{n<N \text{ AND } \texttt{insample} \geq \texttt{x}}
\newcommand{\laguard}{n<N\text{ AND }\texttt{insample} < \texttt{x}}
\newcommand{\itgguard}{\texttt{input}\neq\tau \text{ AND } \texttt{insample} \geq \texttt{x}}
\newcommand{\itlguard}{\texttt{input}\neq\tau \text{ AND }\texttt{insample} < \texttt{x}}
\newcommand{\range}{\texttt{range}}
\newcommand{\brangle}[1]{\langle #1 \rangle}
\newcommand{\guard}{\texttt{guard}}
\newcommand{\trans}{\texttt{trans}}
\newcommand{\Lap}{\texttt{Lap}}
\newcommand{\gcycle}{\texttt{G}-cycle}
\newcommand{\lcycle}{\texttt{L}-cycle}
\newcommand{\sgn}{\texttt{sgn}}
\newcommand{\andtext}{\text{ AND }}
\newcommand{\ortext}{\text{ OR }}
\newcommand{\supp}{\texttt{supp}}

\newcommand{\im}{\texttt{im}}


\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\providecommand{\floor}[1]{ \lfloor #1 \rfloor }
\newtheorem{thm}{Theorem}[section]
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{obs}[thm]{Observation}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{const}[thm]{Construction}
\newtheorem{examp}[thm]{Example}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{rmk}[thm]{Remark}
\newtheorem{clm}[thm]{Claim}

\newcommand{\isto}{\stackrel{\sim}{\smash{\longrightarrow}\rule{0pt}{0.4ex}}} 
\graphicspath{ {./} }
\bibliographystyle{plain} 


\begin{document}

\section{Introduction}

Differential privacy is a framework for privacy that gives rigorous guarantees on the amount of data leakage any one person's data can be subjected to when releasing statistical data. Since being introduced in 2006 \cite{DP2006}, differential privacy has become the gold standard for private statistical analysis. 
Differentially private algorithms, whose efficacy are characterized by a ``privacy cost'' $\varepsilon$, primarily rely on the addition of statistical noise, ensuring that statistical results remain approximately correct while preventing any one person's information from being revealed. 

Differentially private algorithms are notoriously tricky to analyze for correctness; most famously, the Sparse Vector Technique (SVT) algorithm has gone through multiple iterations, some of which were later shown to completely fail at protecting privacy\cite{10.14778/3055330.3055331}. Previous implementations of differential privacy by Apple have similarly been shown to have an increase from the claimed privacy cost by a factor of up to 16 \cite{appleleakprivacy}. 

Thus, much work has been done on developing methods for automatic verification of differentially private algorithms, both in their overall privacy and in the specific privacy costs they claim to achieve. 
Because even for limited programs the problem of determining if a program is differentially private is undecidable\cite{barthe.etal2020decidingdp}, previous work tends to focus on semi-decidability or further restricting program models. 

Recently, a line of work has emerged around \textbf{approximate liftings} \cite{BartheEtAl2016,bartheKopfOlmedo2012ProbabilisticRelationalReasoningforDifferentialPriv,BartheOlmedo2013,HsuThesis2017}. Approximate liftings are a generalization of probabilistic couplings, themselves a well-known technique in probability theory for analyzing relationships between random variables. 
Approximate liftings allow for a more structured proof approach to many algorithms that themselves are not conducive to a standard compositional analysis, such as SVT. Because of their structure, liftings also lend themselves to automated proof construction~\cite{AlbarghouthiHsu2018}. 

We first rewrite the major results of approximate liftings in \{not program logic\}\footnote{not sure how to describe this, also not sure if worth mentioning}. 
We then use approximate liftings to demonstrate that a certain limited class of programs, first described in \cite{chadhaLinearTimeDecidability2021}, are differentially private; interestingly, we show that our class of liftings completely characterizes this class of programs. Additionally, we demonstrate that the privacy of a natural generalization of this class of programs can be proven using liftings and almost immediately follows from the privacy of the smaller class. 

\section{Differential Privacy}

Differential privacy is a mathematically robust approach to privacy; most generally, differential privacy ensures that it is unlikely for an adversary to distinguish between whether or not one person's data was used in a private algorithm. To do this, differentially private algorithms rely on randomization, especially through the addition of statistical noise.

More precisely then, for a fixed output $\sigma$ of a private algorithm $A$, the probability of obtaining $\sigma$ for a dataset with some individual Alex is close (measured by a multiplicative factor) to the probability of obtaining $\sigma$ for the same dataset with Alex removed or Alex's data changed.

We will consider \textbf{datasets} $\mathcal{X}\in X^n$ of size $n$, where $X$ is the set of all possible rows in the dataset; each person is represented by a single row. 

We next define what it means for datasets to be ``similar'' to each other. 

\begin{defn}
    Two datasets $\mathcal{X}=(x_1, \ldots, x_n), \mathcal{X}'=(x'_1, \ldots, x'_n)\in X^n$ are \textbf{adjacent} (notated $\mathcal{X}\sim\mathcal{X}'$) if $|\{i: x_i\neq x'_i\}|\leq 1$\footnote{A common variant is to define adjacency by the removal or addition of an entry, rather than changing one}.
\end{defn}

We thus formalize privacy under this framework as follows.
\begin{defn}[Pure Differential Privacy]
    A randomized algorithm $A$ is $\varepsilon$-differentially private if, for all pairs of \textbf{adjacent} datasets $X$ and $X'$ and all events $E \subseteq \im(A)$, \[\PP[A(X) \in E]\leq e^\varepsilon \PP[A(X')\in E]\]
\end{defn}


An extremely useful property of differential privacy is that differentially private programs can be \textbf{sequentially composed} with a linear degradation in privacy:

\begin{thm}[Standard Composition]
    If $A$ is $\varepsilon_1$-differentially private and, for all $\sigma$, $B(\sigma, \cdot)$ is $\varepsilon_2$-differentially private, then $B(A(X), X)$ is $\varepsilon_1+\varepsilon_2$-differentially private. 
\end{thm}

Composition therefore allows us to view privacy parameters $\varepsilon$ as a ``budget'' for privacy-leaking operations in a program. Many\footnote{generic platitude - reword} common differentially private algorithms are thus built out of well-known private components combined together, which also lend themselves to straightforward analyses. 

\subsection{Sensitivity and the Laplace Mechanism}

Because we are typically interested in analyzing \textit{functions} of our raw dataset (for example, the average age of a town), it is often useful to examine differential privacy through a similar model - instead of comparing two adjacent datasets $X\sim X'$, we compare \textbf{queries} $f(X)$ and $f(X')$. In this world, we care about the \textit{sensitivity} of functions: how much a function \textit{changes} when considering adjacent inputs.  

\begin{defn}
    The ($\ell_1$-)sensitivity of a function $f: X\to \RR$, often denoted $\Delta f$, is defined as $\Delta f = \max_{X\sim X'}||f(X)-f(X')||_1$.
\end{defn}

Given a function's sensitivity, we can easily make it differentially private through the use of the \textbf{Laplace Mechanism}.

\begin{defn}
    The Laplace distribution $\Lap(\mu, b)$ with mean $\mu$ and spread parameter $b$ is the probability distribution with probability density function $f(x) = \frac{1}{2b}\exp(-\frac{|x-\mu|}{b})$. If $\mu =0$, we will often abbreviate $\Lap(0, b)$ as $\Lap(b)$. 
\end{defn}

The Laplace Mechanism, as expected, simply adds noise sampled from the Laplace distribution to a query result. 

\begin{thm}[Theorem 3.6~\cite{dworkrothmonograph}]
    For a function $f$ with sensitivity $\Delta$, $A(X) = f(X) + \Lap(\frac{\Delta}{\varepsilon})$ is $\varepsilon$-differentially private. 
\end{thm}

We will consider the scenario where we are given a potentially infinite \textit{sequence} of real-valued query functions $q_0, q_1, \ldots$, each with sensitivity at most $\Delta$.

\subsection{Deciding Privacy}

Because designing differentially private algorithms can be quite tricky, we would like to be able to automatically (i.e. algorithmically) verify whether or not a given program is private, especially for algorithms whose privacy proofs do not rely primarily on composition. 
Ideally, beyond just determining whether a program is private or not, if a program is private, we'd like to find a good bound on the privacy cost for the program as well. 

Unfortunately, even for relatively simple programs, just the basic problem is undecidable. 

\begin{thm}[\cite{barthe.etal2020decidingdp}]
    The problem of determining whether a program from a certain class of algorithms with assignments, conditionals, and while loops is $\varepsilon$-differentially private is undecidable\footnote{rephrase?}.
\end{thm}

Thus, we will derive a decision procedure for a very specific class of potentially private programs; in particular, this class of programs lends itself to a straightforward analysis by \textbf{approximate liftings}, which we now introduce. 

\section{Couplings and Liftings}

Probabilistic couplings are a common tool in probability theory; intuitively, couplings allow for the joint analysis of nominally unrelated probabilistic processes. 

\begin{defn}
    A coupling between two distributions $A$ and $B$ is a joint distribution $C$ such that $\pi_1(C)=A$ and $\pi_2(C)=B$, where $\pi_1(C)$ and $\pi_2(C)$ are the first and second marginals of $C$, respectively. 
\end{defn}

In particular, couplings can be useful when analyzing the relation between two probablistic processes; couplings were first formulated by [check name] to analyze the behaviour of markov chains and have close connections to concepts such as total variation distance and stochastic domination. 

As useful as standard couplings are, however, we must use more powerful machinery to properly reason about privacy.

\textbf{Approximate liftings} \cite{BartheOlmedo2013,bartheKopfOlmedo2012ProbabilisticRelationalReasoningforDifferentialPriv,HsuThesis2017,BartheEtAl2016} allow us to apply couplings to the realm of differential privacy. 

\begin{defn}
    Let $A_1, A_2$ be two probability spaces\footnote{may need to formally rewrite this at some point}. We say a distribution $\mu_1$ on $A_1$ and $\mu_2$ on $A_2$ are related by the $\mathbf{\varepsilon}$\textbf{-lifting} of the relation $\Psi\subseteq A_1\times A_2$ (written $\mu_1\Psi^{\#\varepsilon}\mu_2$) if there exist two \textbf{witness distributions} $\mu_L, \mu_R$ on $A_1\times A_2$ such that\begin{enumerate}
        \item $\pi_1(\mu_L) = \mu_1$ and $\pi_2(\mu_R) = \mu_2$
        \item $\supp(\mu_L), \supp(\mu_R)\subseteq \Psi$
        \item $\sup_{E\subseteq A_1\times A_2}(\PP_{x\gets \mu_L}[x\in E]- e^\varepsilon \PP_{x\gets \mu_R}[x\in E])\leq 0$
    \end{enumerate}
\end{defn}

The similarities between the third condition and the definition of differential privacy should be clear. Indeed, there is a close connection between approximate liftings and differential privacy:

\begin{thm}
    An algorithm $A(X)$ is $\varepsilon$-differentially private if and only if, for all adjacent input sequences $X\sim X'$, $A(X)(=)^{\#\varepsilon}A(X')$.
\end{thm}

If we are solely aiming to show that a program is private, we can instead work with the following relaxation: 

\begin{thm}\label{implicationcouplingthm}
    If for all adjacent input sequences $X\sim X'$ and outputs $\sigma$ of $A$, $A(X)\{(a, b): a=\sigma\implies b=\sigma\}^{\#\varepsilon}A(X')$, then $A(X)$ is $\varepsilon-$differentially private.
\end{thm}

As expected, the foundational results of differential privacy can be restated in terms of liftings:

\begin{prop}[Laplace Mechanism for Liftings]
    If $X_1\sim\Lap(\mu_1, \frac{1}{\varepsilon})$ and $X_2\sim\Lap(\mu_2, \frac{1}{\varepsilon})$, then $X_1(=)^{\#\varepsilon|\mu_1-\mu_2|}X_2$.
\end{prop}

\begin{thm}[Composition of Liftings]\label{liftingcomposition}
    Let $A_1, B_2, A_2, B_2$ be distributions over $S_1, T_1, S_2, T_2$, respectively and let $R_1\subseteq S_1\times T_1$, $R_2\subseteq S_2\times T_2$ be relations. If $A_1 R_1^{\#\varepsilon_1}B_1$ and $A_1 R_1 B_1\implies A_2R_2^{\#\varepsilon_2}B_2$, then $A_2 R_2^{\#\varepsilon_1+\varepsilon_2}B_2$.
\end{thm}

The structure of theorems \ref{implicationcouplingthm} and \ref{liftingcomposition} suggests the format that coupling proofs of privacy take: given two ``runs'' of an algorithm on adjacent inputs, construct many smaller liftings between program variables in each run and compose these liftings together to show that a final implicatory lifting between the outputs of the two runs exists. 

\subsection{Proving SVT with couplings}

A classic algorithm that requires analysis beyond standard composition is Sparse Vector Technique (SVT). Given a possibly infinite stream of inputs and a threshold value, SVT will output if the queries are above or below the threshold (with noise on both the query and the threshold). 

Unusually for differentially private algorithms, SVT can output a potentially unbounded number of ``below threshold'' queries before the first $c$ ``above threshold''s (or vice-versa), where $c$ is some constant set by the user; when $c=1$, SVT is frequently also referred to as ``Above (or Below) Threshold''. Potential applications include, for example, checking that a series of inputs is within an expected range or, appropriately, privately determining the non-zero elements of a sparse vector. 

Because SVT allows for a potentially unbounded number of ``below threshold'' query outputs, its analysis requires a non-standard approach; a naive composition approach that assigns a fixed cost to outputting the result of each query will immediately result in unbounded privacy cost as well. 
Indeed, the analysis of SVT is notoriously difficult, with multiple published attempts at privacy proofs that were later shown to be incorrect\footnote{A textbook analysis of SVT, along with a discussion of bugged versions and incorrect privacy proofs, can be found at \cite{10.14778/3055330.3055331}}. 

However, re-analyzing SVT using approximate liftings can be relatively simple. 

\begin{algorithm}
    \hspace*{\algorithmicindent}\textbf{Input}: $\mathcal{X}\in X^n$, $T\in \RR$, $Q=q_1, \ldots \in {(X^n\to \RR)}^*$ with sensitivity $\Delta$, $c\in \NN$.
    \begin{algorithmic}[1]
        \caption{Sparse Vector Technique}\label{couplingAlg}
        \State $\varepsilon_1, \varepsilon_2 \gets \frac{\varepsilon}{2},
        \rho \gets \Lap(\frac{\Delta}{\varepsilon_1})$, $count \gets 0$
		\For{$q_i \in Q$} 
			\State $z\gets \Lap(\frac{2c\Delta}{\varepsilon_2})$
            \If{$q_i(\mathcal{X}) + z \geq T + \rho$}
                \State\textbf{output} $\top$
                \State$count\gets count+1$
                \If{$count \geq c$}
                    \State$\textbf{break}$
                \EndIf
            \Else
                \State\textbf{output} $\bot$
            \EndIf
		\EndFor
    \end{algorithmic}
\end{algorithm}


\begin{thm}
    Sparse Vector Technique is $\varepsilon$-differentially private. 
\end{thm}

\begin{proof}
    Consider two runs of SVT with adjacent inputs $\mathcal{X}\sim\mathcal{X}'$, respectively. We are aiming to show that $SVT(\mathcal{X}, T, Q, c)\{(a, b): a=\sigma \implies b=\sigma\}^{\#\varepsilon}SVT(\mathcal{X}', T, Q, c)$ is a valid lifting. 

    Fix some output $\sigma \in \{\bot, \top\}^n$. Let $A = \{i:\sigma_i = \top\}$ be the indices of queries that are measured to be above the threshold. Note that $|A| = c$. 
    
    For every program variable $x$, let $x\brangle{1}$ and $x\brangle{2}$ represent the value of $x$ in $SVT(\mathcal{X}, T, Q, c)$ and $SVT(\mathcal{X}', T, Q, c)$, respectively, so, for example, $q_i(\mathcal{X})\brangle{1} = q_i(\mathcal{X})$ and $q_i(\mathcal{X})\brangle{2} = q_i(\mathcal{X}')$. 

    Let $\tilde{T}=T + \rho$. Then $\tilde{T} \sim \Lap(T, \frac{\Delta}{\varepsilon_1})$, so $\tilde{T}\brangle{1} +\Delta (=)^{\#\varepsilon_1}\tilde{T}\brangle{2}$. 

    Let $S_i = q_i(\mathcal{X}) + z_i$, so $S_i \sim\Lap(q_i(\mathcal{X}), \frac{2c\Delta}{\varepsilon_2})$.

    For all $i$ such that $0\leq i < n$, $i\notin A$, we construct the lifting $z_i\langle 1\rangle (=)^{\#0}z_i\langle 2\rangle$. 

    Then note that $\tilde{T}\brangle{1}+\Delta = \tilde{T}\brangle{2}\land z_i\brangle{1} = z_i \brangle{2} \implies (S_i\brangle{1} < \tilde{T}\brangle{1} \implies S_i\brangle{2} < \tilde{T}\brangle{2} )$.

    For all $i\in A$, create the lifting $z_i\brangle{1}(=)^{\#\frac{\varepsilon_2}{c}}z_i\brangle{2} - q_i(\mathcal{X})+q_i(\mathcal{X}')-\Delta$, or equivalently, \\$S_i\brangle{1} +\Delta (=)^{\#\frac{\varepsilon_2}{c}} S_i\brangle{2}$. Note that this costs $\frac{\varepsilon_2}{c}$ since $|q_i(\mathcal{X})-q_i(\mathcal{X}')|\leq \Delta$.

    Then \[\tilde{T}\brangle{1} +\Delta = \tilde{T}\brangle{2} \land S_i\brangle{1} + \Delta = S_i\brangle{2} \implies (S_i\brangle{1} \geq \tilde{T}\brangle{1} \implies S_i\langle 2\rangle \geq \tilde{T}\brangle{2})\]

    Thus, for all $i$, $SVT(\mathcal{X}, T, Q, c)_i = \sigma_i \implies SVT(\mathcal{X}', T, Q, c)_i = \sigma_i$, so $SVT(\mathcal{X}, T, Q, c)\{(a, b): a=\sigma \implies b=\sigma\}^{\#\varepsilon_1+\varepsilon_2}SVT(\mathcal{X}', T, Q, c)$.

    By Theorem \ref{implicationcouplingthm}, SVT is $\varepsilon$-differentially private. 
\end{proof}

\section{Automatically Proving Privacy using Couplings}

We begin by building up a program model for SVT-style algorithms. There are three major components of SVT: taking in a threshold value and adding Laplace noise to it, taking in input and adding Laplace noise to it, and comparing the noisy threshold to the noisy input. 


\subsection{Individual Transitions}


\begin{defn}
    Let $Q$ be a finite set of program states partitioned into input states $Q_{in}$ and non-input states $Q_{non}$. Then $P_Q(q): Q\to \RR^{\geq 0}\times \RR^{\geq 0}$ is a function that associates each state state with two \textbf{noise parameters} $P(q) = (d_q, d_q')$.
\end{defn}

In our program model, we have a singular persistent real-valued variable $\texttt{x}$, which can be thought of as analogous to the threshold in algorithms like SVT. 

To capture the value of $\texttt{x}$ at different states, we pair each state with possible values of $\texttt{x}$:

\begin{defn}
    Given a finite set of program states $Q$, the set $Q\times \RR$ is the set of \textbf{instantiated states} of $Q$. 
\end{defn}

Let $\mathcal{C}=\{\texttt{true}, \lguard[\texttt{x}], \gguard[\texttt{x}]\}$ be a set of \textbf{transition guards}.

We now can define the simplest programs, individual transitions:

\begin{defn}[Transitions]
    Given a finite set of program states $Q$ and a set of real-valued variables $\{\texttt{x}, \texttt{insample}, \texttt{insample}'\}$. A transition is a tuple $t = (q, q', c, \sigma, \tau)$, where \begin{itemize}
        \item $q\in Q$ is the initial state.
        \item $q'\in Q$ is the following state.
        \item $c\in \mathcal{C}$ is a transition guard that determines if $t$ is taken.
        \item $\sigma \in \Gamma\cup\{\texttt{insample}, \texttt{insample}'\}$ is the output of $t$.
        \item $\tau\in\{\texttt{true}, \texttt{false}\}$ is a boolean value indicating whether or not the stored value of $\texttt{x}$ will be updated.
    \end{itemize}
    Depending on context, we may also notate $t$ as $q\to q'$. 
\end{defn}


\subsubsection{Transition Semantics}

We can think of each transition as defining an extremely small program; beginning in some state $q$, a transition takes in some real valued input $\texttt{in}$, compares it to some threshold $\texttt{x}$, and, depending on the result of the comparison, moves to a state $q'$ while outputting a value $\sigma$ and possibly updating the value of $\texttt{x}$.

More specifically, given some threshold value $\texttt{x}$, each transition $t = (q, q', c, \sigma, \tau)$ will first read in a real number input $\texttt{in}$, sample two random variables $z\sim\Lap(0, \frac{1}{d\varepsilon})$, $z'\sim\Lap(0, \frac{1}{d'\varepsilon})$, where $P(q) = (d, d')$, and then assign two variables $\texttt{insample} = \texttt{in} + z$ and $\texttt{insample}' = \texttt{in} + z'$. 
If the guard $c$ is satisfied, then we transition to state $q'$, outputting $\sigma$ and, if $\tau = \texttt{true}$, reassigning $\texttt{x} = \texttt{insample}$. 

We can describe the semantics of a transition as a function that maps an initial program \textbf{state} and a real-valued input to a distribution of subsequent program states and an output value. 

To be precise, a program state is a tuple consisting of a program location and a value for the program variable $\texttt{x}$. Let $S = Q\times\RR$ be the set of all possible program states. As expected, every possible input is simply an element of $\RR$. 
An output can either be a symbol from some finite alphabet $\Gamma$ or a real number; thus, the set of all possible output events is $\Gamma \cup \Sigma$, where $\Sigma$ is some $\sigma$-algebra over $\RR$.
In particular, we will take $\Sigma$ to be the standard $\sigma$-algebra of all Lebesgue measurable sets. 

It follows that the semantics of a transition $t$ can be defined as a function $\Phi((q, \texttt{x}), \texttt{in}): S\times \RR\to dist(S\times (\Gamma\cup\Sigma\cup \lambda))$ that maps an initial program state and an input to a distribution of subsequent program states and an output event following the expected semantics; $\lambda$ here denotes the empty string (i.e. no output). 

{\color{red}[If we need space, just say that we use the natural semantics and move the following section to appendix]}


Let $q\in Q$ be an initial state, $\texttt{x}\in \RR$ be an initial threshold value, and $P(q) = (d_q, d_q')$ be the distributional parameters associated with $q$. Let $t = (q, q', c, \sigma, \tau)$ be a transition whose semantics we are defining. 

Let $\texttt{in}\in \RR$ be a real-valued input and $o\in (\Gamma\cup\Sigma\cup\lambda)$ be a possible output event of $t$.

Let $I\sim \Lap(\texttt{in}, \frac{1}{d_q\varepsilon})$ and $I'\sim \Lap(\texttt{in}, \frac{1}{d_q'\varepsilon})$ be independent random variables corresponding to $\texttt{insample}$ and $\texttt{insample}'$. 

For both $I$ and $I'$, given $o$, we say that $I$ (or $I'$, respectively) matches $o$ if $o\subseteq \RR$ and $I\in o$. 

Then if $\tau = \texttt{false}$, $\Phi_t((q, \texttt{x}), \texttt{in}) = ((q', \texttt{x}), o)$ with probability equal to the probability $c$ is satisfied for $\texttt{x} = X$ and $\texttt{insample} = I$ and, if $\sigma = \texttt{insample}$ or $\sigma = \texttt{insample}'$, then $I$ matches $o$ or $I'$ matches $o$, respectively. $\Phi_t((q, \texttt{x}), \texttt{in}) = ((q_{term}, \texttt{x}), \lambda)$ with probability equal to the probability that $c$ is not satisfied. 

Similarly, if $\tau = \texttt{true}$, then $\Phi_t((q, \texttt{x}), \texttt{in}) \in ((q', I), o)$ with probability equal to the probability $c$ is satisfied for $\texttt{x} = X$ and $\texttt{insample} =I$ and,
if $\sigma = \texttt{insample}$ or $\sigma = \texttt{insample}'$, then $I$ matches $o$ or $I'$ matches $o$, respectively. $\Phi_t((q, \texttt{x}), \texttt{in}) = ((q_{term}, I), \lambda)$ with probability equal to the probability that $c$ is not satisfied. 

Here, $q_{term}$ is a sink or terminal state with no transitions allowed out of it.

We primarily are concerned with the probability that a transition ``succeeds'', that is, the probability that from state $q$, the program defined by $t$ transitions to state $q'$ and outputs a certain value. We denote this probability as $\PP[\texttt{x}, t, \texttt{in}, o]$, where $\texttt{x} \in \RR$ is the initial value of $\texttt{x}$, $t$ is a transition, $\texttt{in}\in \RR$ is a real-valued input, and $o\in \Gamma\cup\Sigma$ is a possible output of $t$.
Note that this is an aggregated probability over all possible final values of $\texttt{x}$ - we do not particularly care what the final value of the threshold is. 


\subsubsection{Privacy}

Recall that $\texttt{in}$, in reality, represents a \textbf{function} of some underlying dataset. This means that `closeness' in this context is defined as follows:

\begin{defn}[Adjacency]
    Two inputs $\texttt{in}\sim_{\Delta} \texttt{in}'$ are $\Delta$-adjacent if $|\texttt{in}-\texttt{in}'|\leq \Delta$. If $\Delta$ is not specified, we assume that $\Delta = 1$. 
\end{defn}

\begin{defn}[Valid inputs]
    Let $t = (q, q', c, \sigma, \tau)$ be a transition over $Q$. A valid adjacent input pair to $t$ is a pair of real numbers $(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})\in \RR^2$ such that:
    \begin{itemize}
        \item If $q\in Q_{in}$, then $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$. 
        \item If $q\notin Q_{in}$, then $\texttt{in}\brangle{1} = \texttt{in}\brangle{2} = 0$.
    \end{itemize}
    We will abuse notation and denote that $(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})$ is a valid adjacent input pair by also writing $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$. In general, we will assume that all inputs are valid unless explicitly otherwise stated.
\end{defn}

In lieu of defining exactly what it means for an individual transition to be ``private'', we will define a closely related {\color{red}measure? is that the right word?}.

{\color{red} Move this to the DP section?}

\begin{defn}[Max Divergence]
    For any two probability distributions $P, Q$ over a shared event space $E$, the max-divergence of $P$ and $Q$ is 
    $D_{\infty}(P||Q) = \max_{e\in E}\ln\left(\frac{P(e)}{Q(e)}\right)$.
\end{defn}

Max divergence is closely related to differential privacy; it should be clear that an algorithm $A$ is $\varepsilon$-DP if and only if for all adjacent inputs $X\sim X'$, $D_{\infty}(A(X)||A(X'))\leq \varepsilon$. 

\begin{defn}[$d\varepsilon$-closeness{\color{red} need a better name/ is this definition even necessary?}]
    Let $X\brangle{1}\sim \Lap(\mu\brangle{1}, \frac{1}{d_x\varepsilon}), X\brangle{2}\sim\Lap(\mu\brangle{2}, \frac{1}{d_x\varepsilon})$ be random variables representing possible initial values of $\texttt{x}$. 
    Then, given $X\brangle{1}, X\brangle{2}$, a transition $t=(q, q', c, \sigma, \tau)$ is \textbf{$d\varepsilon$-close} for some $d>0$ if $\forall \varepsilon> 0$, for all adjacent input pairs $\texttt{in}\brangle{1}, \texttt{in}\brangle{2}$, and $D_{\infty}(\PP[X\brangle{1}, t, \texttt{in}\brangle{1}, \cdot]||\PP[X\brangle{2}, t, \texttt{in}\brangle{2}, \cdot])\leq d\varepsilon$. Note that $d$ can be dependent on $X\brangle{1}$ and $X\brangle{2}$.
\end{defn}

Note that we slightly redefine $\varepsilon$-differential privacy as $d\varepsilon$-differential privacy, treating $\varepsilon$ as a universal scaling parameter that can be fine-tuned by users for their own purposes. 
In particular, we argue that this definition is functionally equivalent\footnote{\cite{chadhaLinearTimeDecidability2021} notes that it is not entirely clear how this differs from standard differential privacy, but that the known decidability result does not apply here - {\color{red} maybe something to investigate}}, since if we are targeting $\varepsilon^*$-differential privacy overall, we can always take $\varepsilon = \frac{\varepsilon^*}{d}$.

\subsubsection{Couplings}

For every transition $t$ between two states $q$ and $q^*$, we can show that $t$ is differentially private using a series of liftings. 

\begin{lemma}\label{indTransitionCoupling}
    Let $X\brangle{1}\sim \Lap(\mu\brangle{1}, \frac{1}{d_x\varepsilon}), X\brangle{2}\sim\Lap(\mu\brangle{2}, \frac{1}{d_x\varepsilon})$ be random variables be random variables representing possible initial values of $\texttt{x}$. 

    Consider some transition $t = (q, q^*, c, \sigma, \tau)$ from $q$ to $q^*\in Q$. Let $P(q) = (d_q, d_q')$.

    Let $\texttt{in}\brangle{1}, \texttt{in}\brangle{2}$ be an arbitrary valid adjacent input pair and let $o\brangle{1}$, $o\brangle{2}$ be random variables representing possible outputs of $t$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. 

    Then $\forall \varepsilon>0$ and for all $\gamma_x, \gamma_q, \gamma_q'\in [-1, 1]$ that satisfy the constraints \[
        \begin{cases}
          \gamma_q\leq\gamma_x & c = \lguard[\texttt{x}]\\
          \gamma_q\geq\gamma_x & c = \gguard[\texttt{x}]\\
          \gamma_q=0 & \sigma = \texttt{insample}\\
          \gamma_q'=0 & \sigma = \texttt{insample}'
        \end{cases},
      \]
      the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = (|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_x+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$, and therefore $t$ is $d\varepsilon$-close. 
\end{lemma}

\begin{proof}
Fix $\varepsilon>0$.

We will analyze the behaviour of two different \textbf{runs} of $t$, one with input $\texttt{in}\brangle{1}$ and one with input $\texttt{in}\brangle{2}$. 

Our approach to couplings will be that for every Laplace-distributed variable, we will couple the value of the variable in one run with its value in the other \textbf{shifted} by some amount. 

We differentiate between the values of variables in the first and second run by using angle brackets $\brangle{k}$, so, for example, we will take $X\brangle{1}$ to be the value of $\texttt{x}$ at state $q$ in the run of $t$ with input $\texttt{in}\brangle{1}$ and $X\brangle{2}$ to be the value of $\texttt{x}$ in the run of $t$ with input $\texttt{in}\brangle{2}$. 

We thus want to create the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}o\brangle{2}$. We must guarantee two things: that if the first transition is taken, then the second is also taken and that both runs output the same value $\sigma$ when taking the transition. Note that if $c = \texttt{true}$, the first condition is trivially satisfied and when $\sigma\in \Gamma$, the second condition is trivially satisfied. 

We can first create the lifting $X\brangle{1}+\gamma_x (=)^{\#(|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_x\varepsilon}X\brangle{2}$. This is analogous to shifting the threshold values that we want to compare inputs to in an algorithm like SVT. 

Additionally, create the lifting $z\brangle{1} (=)^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q\varepsilon}z\brangle{2} - \texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q$. 

This is equivalent to creating the lifting $\texttt{insample}\brangle{1} +\gamma_q{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q\varepsilon}\texttt{insample}\brangle{2}$.

Finally, create the lifting $z'\brangle{1} (=)^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'\varepsilon}z'\brangle{2} - \texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'$. As before, this is equivalent to creating the lifting $\texttt{insample}'\brangle{1} +\gamma_q'{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'\varepsilon}\texttt{insample}'\brangle{2}$.

Thus, we emerge with three key statements to leverage:\begin{itemize}
    \item $X\brangle{1} + \gamma_x = X\brangle{2}$
    \item $z\brangle{1} = z\brangle{2} - \texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q$
    \item $z'\brangle{1} = z'\brangle{2} - \texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'$
\end{itemize}

So if $c=\lguard[\texttt{x}]$ and $\gamma_q\leq \gamma_x$, then \begin{align*}
    \texttt{insample}\brangle{1}<X\brangle{1}&\implies \texttt{in}\brangle{1}+z\brangle{1}<X\brangle{1}\\
    &\implies \texttt{in}\brangle{1}+z\brangle{2}-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q<X\brangle{2}-\gamma_x\\
    &\implies \texttt{insample}\brangle{2}<X\brangle{2}
\end{align*}

Similarly, if $c=\gguard[\texttt{x}]$ and $\gamma_q\geq \gamma_x$, then \begin{align*}
    \texttt{insample}\brangle{1}\geq X\brangle{1}&\implies \texttt{in}\brangle{1}+z\brangle{1}\geq X\brangle{1}\\
    &\implies \texttt{in}\brangle{1}+z\brangle{2}-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q\geq X\brangle{2}-\gamma_x\\
    &\implies \texttt{insample}\brangle{2}\geq X\brangle{2}
\end{align*}

With these liftings, we have ensured that if the first run takes transition $t$, then the second run does as well. 

As noted, if $\sigma \in \Gamma$ and the first run taking transition $t$ implies that the second run does as well, then $o\brangle{1} = \sigma \implies o\brangle{2}=\sigma$ trivially.

Now, if $\sigma=\texttt{insample}$ and $\gamma_q=0$, then clearly we have that $\texttt{insample}\brangle{1}=\texttt{insample}\brangle{2}$, so for all $a\in \RR$, $o\brangle{1} = a\implies o\brangle{2} = a$.

Similarly, if $\sigma=\texttt{insample}'$ and $\gamma_q'=0$, we have that for all $a\in \RR$, $o\brangle{1} = a\implies o\brangle{2} = a$.

Thus, given the constraints \[
  \begin{cases}
    \gamma_q\leq\gamma_x & c = \lguard[\texttt{x}]\\
    \gamma_q\geq\gamma_x & c = \gguard[\texttt{x}]\\
    \gamma_q=0 & \sigma = \texttt{insample}\\
    \gamma_q'=0 & \sigma = \texttt{insample}'
  \end{cases},
\]
we have shown that the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid, where the cost $d = (|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_x+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$. 

By an application of theorem \ref{implicationcouplingthm}, $\PP[X\brangle{1}, t, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[X\brangle{2}, t, \texttt{in}\brangle{2}, \sigma]$. Because $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$ are arbitrary adjacent inputs and $\sigma$ is an arbitrary possible output of $t$, this implies that $t$ is $d\varepsilon$-differentially private. 
\end{proof}

We can thus think of couplings for a transition as being parameterized by $\gamma_x$, $\gamma_q$, and $\gamma_q'$. In particular, we will view choices of $\gamma_x, \gamma_q$, and $\gamma_q'$ as a \textbf{strategy} for proving that a transition is differentially private. 

\begin{defn}[Coupling strategies]
    A \textbf{coupling strategy} for a transition $t_i = (q_i, q_{i+1}, c_i, \sigma_i, \tau_i)$ is a tuple $C_i = (\gamma_x^{(i)}, \gamma_i, \gamma_i')\in [-1, 1]^3$. 
\end{defn}

\begin{defn}[Validity of a coupling strategy]
    A coupling strategy $C_i =(\gamma_x^{(i)}, \gamma_i, \gamma_i')$ for a transition $t_i$ is \textbf{valid} if the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_x^{(i)} & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_x^{(i)} & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}'
        \end{cases},
      \]
      are all satisfied. 
\end{defn}

In particular, a valid coupling proof gives an upper bound on the privacy cost of any individual transition. 
\begin{prop}\label{indivTransitionCouplingProp}
    For a transition $t_i$, if there exists a valid coupling strategy $C_i=(\gamma_x^{(i)}, \gamma_i, \gamma_i')$ given initial $\texttt{x}$ values centred at $\hat{\mu_q}\brangle{1}$ and $\hat{\mu_q}\brangle{2}$, then $t_i$ is $d\varepsilon$-differentially private for some 
    \[d\leq \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}} (|\hat{\mu_q}\brangle{1}-\hat{\mu_q}\brangle{2}+\gamma_x^{(i)}|)\hat{d_q}+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_i|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_i'|)d_q'.\]
\end{prop}
\begin{proof}
    Follows immediately from lemma \ref{indTransitionCoupling}.
\end{proof}

\subsubsection{Constructing an alphabet}

We will consider individual transitions as part of an \textit{alphabet}; we will show that there is an interesting subset of regular languages over an alphabet of transitions that we can apply the coupling framework to. 

We will only consider certain alphabets of transitions; the ones that generate coherent programs. 

\begin{defn}[Valid Transition Alphabets]
    Let $\Sigma_T$ be a finite alphabet of transitions. We will call $\Sigma_T$ \textbf{valid} if it satisfies the following conditions:
    \begin{itemize}
        \item \textbf{Initialization:} There exists some $t_{init}\in \Sigma_T$ such that $t_{init} = (q_0, q_1, \texttt{true}, \sigma, \texttt{true})$ for some $q_0, q_1\in Q$, $\sigma \in \Gamma\cup\{\texttt{insample}, \texttt{insample}'\}$. 
        \item \textbf{Determinism}: If any transition $t\in \Sigma_T$ is of the form $t=(q, q', c, \sigma, \tau)$, then no other transitions of the form $(q, q^*, c, \sigma', \tau')$ for $q, q', q^*\in Q$ exist in $\Sigma_T$. 
        Additionally, if there exists a transition $t=(q, q', \texttt{true}, \sigma, \tau)$ such that $t\in \Sigma_T$, then transitions of the form $(q, q^*, \lguard[\texttt{x}], \sigma', \tau')$ or $(q, q^*, \lguard[\texttt{x}], \sigma', \tau')$ are not in $\Sigma_T$. 
        \item \textbf{Output distinction}: If there exist some $\sigma, \sigma', \tau, \tau'$ such that $(q, q', \lguard[\texttt{x}], \sigma, \tau)\in \Sigma_T$  and $(q, q^*, \gguard[\texttt{x}], \sigma', \tau') \in \Sigma_T$, then $\sigma \neq \sigma'$. Additionally, at least one of $\sigma\in \Gamma$, $\sigma'\in \Gamma$ is true.
        \item \textbf{Non-input state condition}: For all states $q\in Q_{non}$, if there exists a transition $t=(q, q', c, \sigma, \tau)$ such that $t\in \Sigma_T$, then $c = \texttt{true}$.
    \end{itemize}
\end{defn}

\subsection{Multiple Transitions}

Of course, in practice we would like to analyze the behaviour of programs with more than two program states.

We start with \textit{paths}, comprised of a sequence of transitions. Equivalently, paths are words comprised of letters from a (valid) transition alphabet $\Sigma_T$. 

\begin{defn}[Program paths]
    Let $\Sigma_T$ be a valid transition alphabet with underlying state space $Q$. A program \textbf{path} is a sequence of transitions $t_0\cdot t_1\cdot \ldots\cdot t_{n-1}$ such that for all $i\in 0\ldots n-1$, $t_i = (q_i, q_{i+1}, c_i, \sigma_i, \tau_i)$ for some $c_i, \sigma_i, \tau_i$. We will often notate an path $\rho$ as $\rho = q_0\to q_1\to \ldots \to q_n$. 

    If a path $\rho$ is of the form $\rho = t_{init}\cdot \rho'$ for $\rho'\in \Sigma_T^*$, then we call $\rho$ a \textbf{complete} path. 
\end{defn}

We define some useful notation for dealing with paths and sequences more generally. 

\begin{defn}
    Given a path (or sequence) $\rho = t_0\cdot t_1\cdot \ldots\cdot t_{n-1}$, the \textbf{tail} of $\rho$ is defined as $tail(\rho) = t_1\cdot \ldots\cdot t_{n-1}$. 

    We may additionally use the notation $\rho_{i:j}$ to represent the subpath (or subsequence) $q_i\to q_{i+1}\to \ldots \to q_j$ of $\rho$. Using this notation, $tail(\rho) = \rho_{1:} = \rho_{1:n}$.
\end{defn}


As before, we need to restrict the space of possible inputs to a path based on which states in the path actually read in user input.
\begin{defn}
    For a path $\rho$ of length $n$, an input sequence $\texttt{in}\in \RR^n$ is valid if, for all $q_i$ in $\rho$ such that $q_i \notin Q_{in}$, $\texttt{in}_i = 0$.  
\end{defn} 

We will assume that all input sequences are valid from now on. 

Interestingly, the constraints on valid transition alphabets mean that outputs uniquely correspond to paths. 

In other words, given a valid transition alphabet, knowing an output sequence uniquely determines which path must have produced the output. 


\begin{prop}
    Let $\Sigma_T$ be a valid transition alphabet and let $\Gamma$ be the finite output alphabet associated with $\Sigma_T$. Let $O\subset (\Gamma\cup\{\texttt{insample}, \texttt{insample}'\})^*$ be the set of all possible outputs of complete paths over $\Sigma_T$. There exists an injection $f: \Sigma_T\to t_{init}\Sigma_T^*$ from the set of all possible outputs to complete paths over $\Sigma_T$. 
\end{prop}
\begin{proof}
    Follows immediately because $\Sigma_T$ satisfies determinism and output distinction.
\end{proof}

\textbf{Path Semantics}

As with transitions, we can think of paths as very limited programs consisting of a series of transitions concatenated together with a persistent threshold variable $\texttt{x}$. Naturally, paths will now consider as input a \textbf{sequence} of real numbers, and similarly output a \textbf{sequence} of real numbers or symbols - each transition reads in an input and outputs some value.

In particular, the semantics of a path $\rho = q_0\to \ldots \to q_n = t_0t_1\cdots t_{n-1}$ can be defined as the function $\tilde{\Phi}(\rho, \texttt{x}, \texttt{in}): S\times \RR^n\to S\times (\Sigma\cup\Gamma\cup\lambda)^n$ mapping a path, an initial threshold value, and a input sequence to a distribution of final states and output sequences. 

$\tilde{\Phi}$ can be computed by composing the program semantics of individual transitions in the natural manner.

As before, let $\texttt{in}\in \RR^n$ be a sequence of inputs and let $\sigma \in (\Sigma\cup\Gamma\cup\lambda)^n$ be a sequence of possible output events.
Let $I\sim \Lap(\texttt{in}_0, \frac{1}{d_q\varepsilon})$ and $I'\sim \Lap(\texttt{in}_0, \frac{1}{d_q'\varepsilon})$ be independent random variables corresponding to $\texttt{insample}$ and $\texttt{insample}'$. 

Then \[
    \tilde{\Phi}(\rho, \texttt{x}, \texttt{in})((q', \texttt{x}', \sigma)) = \begin{cases}
        1 & (q', \texttt{x}', \sigma)=(q_0, \texttt{x}, \lambda)\land n = 0\\
        \PP[c_0\text{ is not satisfied}] & (q', \texttt{x}', \sigma) = (q_{term}, \texttt{x}, \lambda)\land \tau = \texttt{false} \\
        \PP[c_0\text{ is not satisfied}] & (q', I, \sigma) = (q_{term}, \texttt{x}, \lambda)\land \tau = \texttt{true}\\
        \begin{gathered}
            \PP[c_0\text{ is satisfied}\land I \text{ matches }\sigma_0]*\\
            \tilde{\Phi}(tail(\rho),\texttt{x}, tail(\texttt{in}))(q', \texttt{x}', tail(\sigma))
        \end{gathered} & \tau = \texttt{false}\\
        \begin{gathered}
            \PP[c_0\text{ is satisfied}\land I \text{ matches }\sigma_0]*\\
            \tilde{\Phi}(tail(\rho),I, tail(\texttt{in}))(q', \texttt{x}', tail(\sigma))
        \end{gathered} & \tau = \texttt{true}\\
        0 & otherwise
    \end{cases}
\]

As before, we primarily care about the probability of a ``successful'' execution of a path with a particular output, which we will denote as $\PP[\texttt{x}_0, \rho, \texttt{in}, \sigma]$, where $\texttt{x} \in \RR$ is the initial value of $\texttt{x}$, $\rho$ is the path we are concerned about, $\texttt{in}\in \RR^n$ is a real-valued input sequence, and $o\in (\Gamma\cup\Sigma\cup\lambda)^n$ is a possible output sequence of $\rho$. 

For a complete path $\rho$, note that the initial value of $\texttt{x}$ is irrelevant, so we will shorthand $\PP[\texttt{x}_0, \rho, \texttt{in}, \sigma]$ to $\PP[\rho, \texttt{in}, \sigma]$.


\subsubsection{Privacy}

Because we now read in a \textit{sequence} of real-valued inputs, we need to slightly modify our definition of adjacency.

\begin{defn}[Adjacency for a sequence of inputs]
    Two input sequences $\{\alpha_i\}_{i=1}^n, \{\beta_i\}_{i=1}^n$ of length $n$ are $\Delta$-adjacent (notated $\alpha \sim_{\Delta}\beta$) if, for all $i\in [1\ldots n]$, $|\alpha_i-\beta_i|\leq \Delta$. 

    As before, if $\Delta$ is not specified, we assume that $\Delta = 1$. 
\end{defn}

Thus, we get the following definition of privacy:

\begin{defn}[$d\varepsilon$-differential privacy for a path]
    A complete path $\rho$ of length $n$ is $d\varepsilon$-differentially private for some $d>0$ if $\forall \varepsilon>0$, for all valid adjacent input sequences $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ of length $n$ and all possible output sequences $\sigma$ of length $n$, $\PP[\rho, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\rho, \texttt{in}\brangle{2}, \sigma]$.
\end{defn}

It will also be convenient to define a notion of privacy for sets of paths:
\begin{defn}
    Let $S$ be a set of complete paths and let $O$ be a set of all possible outputs of paths in $S$. 
    Then $S$ is $d\varepsilon$-differentially private for some $d>0$ if, for all paths $\rho\in S$ and outputs $\sigma\in O$, $\forall \varepsilon>0$, for all valid adjacent input sequences $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$, $\PP[\rho, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\rho, \texttt{in}\brangle{2}, \sigma]$.
\end{defn}

However, because of the path-output correspondence, the following definition is equivalent:
\begin{defn}
    Let $S$ be a set of complete paths; $S$ is $d\varepsilon$-differentially private for some $d>0$ if, for all paths $\rho\in S$, $\rho$ is $d\varepsilon$-differentially private.
\end{defn}

\subsubsection{Concatenating couplings}

Let $\rho[\texttt{in}]$ be a random variable representing the output of $\rho$ given input sequence $\texttt{in}$. 

In order to show that a program path $\rho$ is differentially private, for all adjacent inputs $\alpha\sim\beta$ and all possible outputs $\sigma$, we want to create the coupling $\rho[\alpha]\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}\rho[\beta]$ for some $d>0$. 

Ideally, we would like to simply create couplings for each individual transition in $\rho$ as before and compose them together to create this overall coupling. Indeed, this approach is almost sufficient; the constraints imposed upon shifts for a coupling for transition $t_i$ depend solely on the shift at the most recent \textbf{assignment transition} in $\rho$ (i.e. the most recent transition $t_j$ such that $\tau_j = \texttt{true}$). 
The coupling shifts for \textit{non-assignment transitions} can thus never impact each other. 

\begin{defn}[Assignment transitions]
    Let $A_\rho = \{t_i=(q_i, q_{i+1}, c_i, \sigma_i, \tau_i): \tau_i = \texttt{true}\}$ be the set of \textbf{assignment transitions} in a path $\rho$. Additionally, for every transition $t_i$ in $\rho$, let $t_{at(i)}$ be the most recent assignment transition in $\rho$; i.e., $at(i) = \max\{j<i: t_j\in A_\rho\}$. If such a $j$ does not exist, we set $at(i)=-1$. 
\end{defn}

In particular, note that for transition $t_i$, $\gamma_x = \gamma_{at(i)}$, where $\gamma_{-1}$ is the shift applied to the initial $\texttt{x}$-values $\texttt{x}_0\brangle{1}$ and $\texttt{x}_0\brangle{2}$ (for complete paths, note that $\gamma_{-1}$ is irrelevant).

Thus, for an individual transition $t_i$ of $\rho$, from proposition \ref{indivTransitionCouplingProp}, we have a family of valid coupling strategies $C_i(\gamma_{at(i)}, \gamma_i, \gamma_i')$. 

We can merge these coupling strategies together to create a proof of privacy for the entire path: 

\begin{lemma}\label{multTransitionsCouplingProof}
    Let $\rho = q_0\to \ldots \to q_n$ be a complete path of length $n$. 
    Let $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ be arbitrary adjacent input sequences of length $n$. Additionally, fix some potential output $\sigma$ of $\rho$ of length $n$ and let $\sigma\brangle{1}$, $\sigma\brangle{2}$ be random variables representing possible outputs of $\rho$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. Additionally, for all $q_i$, let $P(q_i) = (d_i, d_i')$.

    Then $\forall \varepsilon>0$ and for all $\{\gamma_i, \gamma_i'\}_{i=0}^{n-1}$ that, for all $i$, satisfy the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_{at(i)} & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_{at(i)} & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}'
        \end{cases},
      \]
      the lifting $\sigma\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}\sigma\brangle{2}$ is valid for $d = \sum_{i=0}^{n-1}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'$, and therefore $t$ is $d\varepsilon$-differentially private. 
\end{lemma}
\begin{proof}
    From the proof of lemma \ref{indTransitionCoupling}, we know that we can create the couplings $\texttt{insample}_i\brangle{1} +\gamma_i{(=)}^{\#(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i\varepsilon}\texttt{insample}_i\brangle{2}$ and $\texttt{insample}_i'\brangle{1} +\gamma_i'{(=)}^{\#(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'\varepsilon}\texttt{insample}_i'\brangle{2}$ for all $q_i$ in $\rho$. 

    Additionally, for some fixed $q_i$ in $\rho$, if we have the coupling $\texttt{x}_i\brangle{1}+\gamma_x (=)^{\#(|\hat{\mu_i}\brangle{1}-\hat{\mu_i}\brangle{2}+\gamma_x|)\hat{d_i}\varepsilon}x_i\brangle{2}$, where $\texttt{x}_i\brangle{1}\sim \Lap(\hat{\mu_i}\brangle{1}, \frac{1}{\hat{d_i}\varepsilon})$ and $\texttt{x}_i\brangle{2}\sim \Lap(\hat{\mu_i}\brangle{2}, \frac{1}{\hat{d_i}\varepsilon})$, then subject to the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_x & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_x & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}_i\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}_i'
        \end{cases},
      \]
    the coupling $\sigma_i\brangle{1}\{(a, b): a=\sigma_i\implies b=\sigma_i\}^{\#d\varepsilon}\sigma_i\brangle{2}$ is valid for some $d$. 

    Indeed, note that for all $i$, $\texttt{x}_i = \texttt{insample}_{at(i)}$ by definition. Thus, we have that $\texttt{x}_i\brangle{1}+\gamma_x (=)^{\#(|-\texttt{in}_{at(i)}\brangle{1}+\texttt{in}_{at(i)}\brangle{2}+\gamma_{at(i)}|)d_{at(i)}\varepsilon}x_i\brangle{2}$, and we must satisfy the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_{at(i)} & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_{at(i)} & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}_i\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}_i'
        \end{cases}
      \]
      for all $i$.

    Thus, we can put all of these couplings together to show that the coupling $\sigma_i\brangle{1}\{(a, b): a=\sigma_i\implies b=\sigma_i\}^{\#d\varepsilon}\sigma_i\brangle{2}$ is valid for some $d>0$.

    In particular, note that we have created at most one pair of couplings (for $\texttt{insample}$ and $\texttt{insample}$) for each $q_i$. Thus, the total coupling cost associated with each $q_i$ is at most $(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'$, 
    which gives us an overall coupling cost of $d = \sum_{i=0}^{n-1}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'$.
\end{proof}
\begin{defn}
    For a complete path $\rho$ of length $n$ and adjacent input sequences $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$, a \textbf{coupling strategy} is two functions $\bm{\gamma}(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}):\RR^n\times \RR^n\to [-1, 1]^n$ and $\bm{\gamma}'(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}):\RR^n\times \RR^n\to [-1, 1]^n$ that produce shifts for each transition of $\rho$ dependent on the input sequences. 

    If $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$ are clear from context, we will often shorthand notating a coupling strategy as $\bm{\gamma}$ and $\bm{\gamma}'$. 
\end{defn}

\begin{defn}
    For a complete path $\rho$ of length $n$, a coupling strategy $C_\rho = (\bm{\gamma}, \bm{\gamma}')$ is \textbf{valid} if $\forall \texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$, $\bm{\gamma}(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})$ and $\bm{\gamma}'(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})$ satisfy the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_{at(i)} & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_{at(i)} & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}'
        \end{cases}.
      \]
\end{defn}

\subsubsection{Optimizing Privacy}

\begin{defn}
    For a complete path $\rho$ of length $n$, the \textbf{cost} of a coupling strategy $C_\rho=(\bm{\gamma}, \bm{\gamma}')$ is \[cost(C_\rho) = \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n-1}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'.\]

    Additionally, let $G$ be the set of all valid coupling strategies $C_\rho=(\bm{\gamma}, \bm{\gamma}')$ for $\rho$. Then the \textbf{coupling cost} of $\rho$ is 
    \[cost(\rho) = \min_{(\bm{\gamma}, \bm{\gamma}')\in G}cost((\bm{\gamma}, \bm{\gamma}')).\]
\end{defn}

As before, the existence of a valid coupling strategy upper bounds the privacy cost of any path. 

\begin{prop}
    If $C_\rho=(\bm{\gamma}, \bm{\gamma}')$ is valid, then $\rho$ is $cost(C_\rho)\varepsilon$-differentially private.
\end{prop}

\begin{proof}
    Follows immediately from lemma \ref{multTransitionsCouplingProof}.
\end{proof}

\begin{cor}{\color{red} Cut?}
    Any complete path $\rho$ is $cost(\rho)\varepsilon$-differentially private. Further, for all complete paths $\rho$, $cost(\rho)<\infty$. 
\end{cor}

\begin{proof}
    The first claim follows immediately from definitions. 
    
    The second claim follows by considering a coupling strategy $(\bm{\gamma}, \bm{\gamma}')$ where $\forall \texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}, \bm{\gamma} = \bm{\gamma}' = \bm{0}$. Note that $(\bm{\gamma}, \bm{\gamma}')$ is trivially valid. Since $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$, $cost(\rho)\leq cost(C_\rho(\bm{0}))\leq \sum_{i=0}^{n-1}(d_i+d_i')$, which is finite for all fixed $\rho$. 
\end{proof}


 

\subsection{Branching} 
{\color{red} considering cutting this section - the major function it serves is to emphasize that, excepting loops, paths should all have their own coupling strategies, which could just be explained in the program section}


\begin{defn}[Branching program]
    Let $\Sigma_T$ be a valid transition alphabet, a branching program $B$ is a finite set of complete paths over $Q$.
\end{defn}

Equivalently, a branching program is a language over $\Sigma_T$ that can be represented by a regular expression only using concatenation and finite union; every word in the language must also be of the form $t_{init}\Sigma_T^*$ and satisfy the path condition. 

\subsubsection{Privacy}

We can do no better than assigning coupling strategies for each path independently. 
\begin{defn}[Coupling strategies]
    A (branched program) coupling strategy $C$ for a branching program $B$ is a collection of (path) coupling strategies where each complete path $\rho\in B$ is assigned a coupling strategy $C_\rho$. 
\end{defn}

\begin{defn}
    A coupling strategy $C$ for a branching program $B$ is valid if, for every constituent path coupling strategy $C_\rho$, $C_\rho$ is valid. 
\end{defn}

\begin{defn}
    The cost of a coupling strategy $C$ for a branched program $B$ is $\max_{\rho\in B}cost(\rho)$.
\end{defn}

\begin{prop}\label{costDependspathProp}
    Optimal cost is dependent on path. There exists a valid transition alphabet $\Sigma_T$, a state space $Q$, and a branching program $B$ for which the optimal cost of a coupling strategy $C$ for $B$ is dependent on the path $\rho$. 
    
    In other words, the optimal strategy $C$ must assign different coupling strategies to occurances of the same transition in different paths. 
\end{prop}

\begin{proof}
    Let $Q = \{q_0, q_1, q_2, q_3\}$ consist only of input states, each of which have both noise parameters equal to $1$. Let $\Sigma_T = \{t_{init}, t_{geq1}, t_{leq1}, t_{leq2}, t_{geq2}\}$ where 
    \begin{align*}
        t_{init} &= (q_0, q_1, \texttt{true}, \bot, 1)\\
        t_{geq1} &= (q_1, q_2, \gguard[\texttt{x}], \top, 0)\\
        t_{leq1} &= (q_1, q_3, \lguard[\texttt{x}], \bot, 0)\\
        t_{geq2} &= (q_2, q_2, \gguard[\texttt{x}], \top, 0)\\
        t_{leq2} &= (q_3, q_3, \lguard[\texttt{x}], \bot, 0)
    \end{align*}
    and let $B = \{t_{init}t_{geq1}t_{geq2}^n, t_{init}t_{leq1}t_{leq2}^n\}$ be the branching program consisting of two paths, each of which have $n$ repetitions of the cycle transitions $t_{geq2}$ and $t_{leq2}$, respectively.

    Let $\rho_1 = t_{init}t_{geq1}t_{geq2}^n$ and $\rho_2 = t_{init}t_{leq1}t_{leq2}^n$ be the two paths in $B$. Notice the following: 
    
    \begin{itemize}
        \item The cost of any coupling strategy for $B$ must be at least $2$.
        
        Let $C_{\rho_1}$ be a coupling strategy for $\rho_1$. We can bound its cost as follows: 
        \begin{align*}
            cost(C_{\rho_1}) &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2}))\\&\qquad+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
            &\geq \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}} \sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
            &= \max_{\Delta \in [-1, 1]^{n+2}} \sum_{i=0}^{n+2}(|\Delta_i-\gamma_i(0, \Delta_i)|)\\
            &\geq |1 - \gamma_0(0, 1)| + \sum_{i=1}^{n+2}|-1-\gamma_i(0, -1)|\\
            &= 1 - \gamma_0(0, 1) + \sum_{i=1}^{n+2} (1+\gamma_i(0, -1))\\
            &= 1 - \gamma_0(0, 1) + (n + 2) + \sum_{i=1}^{n+2}\gamma_i(0, -1)\\
            &\geq 1 - \gamma_0(0, 1) + (n + 2) + \sum_{i=1}^{n+2}\gamma_0(0, 1) \qquad \text{(privacy constraint)}\\
            &= (n + 3) + (n + 1) \gamma_0(0, 1)\\
            &\geq 2
        \end{align*}

    and by a similar argument, $cost(C_{\rho_2})\geq 2$ for any coupling strategy $C_{\rho_2}$.

    \item There exists a coupling strategy $C^*$ for $B$ such that $cost(C^*) = 2$.
    
    We will first describe $C_{\rho_1}^* = (\gamma, \gamma')$. Since no transition outputs \texttt{insample}, we can set $\gamma_i'(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) = \texttt{in}\brangle{2} - \texttt{in}\brangle{1}$ for all $i$ with no privacy cost. Define 
    \begin{align*}
        \gamma_0(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= -1 \\
        \gamma_i(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= \texttt{in}_i\brangle{2} - \texttt{in}_i\brangle{1} \qquad \text{for all $i>0$}
    \end{align*}
    We see that $C^*_{\rho_1}$ is valid, since $\gamma_i\geq \gamma_{0}$ for all $i>0$. Further, we see that 
    \begin{align*}
        cost(C^*_{\rho_1}) &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2}))\\&\qquad+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
        &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}} |-\texttt{in}_0\brangle{1}+\texttt{in}_0\brangle{2}-\gamma_0(\texttt{in}_0\brangle{1}, \texttt{in}_0\brangle{2})| \\
        &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}} |-\texttt{in}_0\brangle{1}+\texttt{in}_0\brangle{2}+1|\\
        &\leq 2 
    \end{align*}
    showing that $cost(C^*_{\rho_1}) = 2$. Similarly, there is a coupling strategy $C^*_{\rho_2}$ for which $cost(C^*_{\rho_2}) = 2$. This shows that there is a coupling strategy $C^*$, consisting of $C^*_{\rho_1}$ and $C^*_{\rho_2}$, for which $cost(C^*) = 2$.
    
    \item Any coupling strategy $C$ that assigns the same coupling strategy to $t_{init}$ in both $\rho_1$ and $\rho_2$ must have cost $>2$.
    
    Let $C$ be as described, and assume that $C$ has optimal cost, ie. $cost(C) = 2$. If $\gamma_0(0, 1) \neq -1$ in $C_{\rho_1}$, then $cost(C_{\rho_1}) > 2$ in the same method as the above, a contradiction.  

    Thus, $\gamma_0(0, 1) = -1$ in $C_{\rho_1}$, which by hypothesis, means that $\gamma_0(0, 1) = -1$ in $C_{\rho_2}$. We have the privacy constraint $\gamma_i \leq \gamma_0$ on $\rho_2$, which also means that $\gamma_i = -1$ identically for all $i > 0$. However, this means that 
    \begin{align*}
        cost(C_{\rho_2}) &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2}))\\&\qquad+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
        &\geq \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}} \sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
        &\geq \max_{\Delta \in [-1, 1]^{n+2}} |\Delta_0 - \gamma_i(0, \Delta_0)| + \sum_{i=1}^{n+2}(|\Delta_i-\gamma_i(0, \Delta_i)|)\\
        &\geq |1 - \gamma_i(0, 1)| + \sum_{i=1}^{n+2}(|1+1|)\\
        &= 2 \cdot (n + 2)
    \end{align*}
    showing that $C$ is not optimal, a contradiction. Therefore $cost(C) > 2$.

    \end{itemize}
    
    The above observations show that the optimal coupling strategy for $B$ must necessarily assign different coupling strategies to $t_{init}$ in $\rho_1$ and $\rho_2$.
\end{proof}

\begin{prop}
    There exist a family of branching programs $\{B_n\}_{n\in \NN}$ for which the cost of any path-independent coupling strategy $C$ for $B_n$ is greater than $n^2$, but for which there exists a path-dependent coupling strategy $C'$ for $B_n$ with cost $\leq n$.
\end{prop}

\begin{proof}
    TODO (Vishnu)
\end{proof}


\subsection{Loops}

\begin{defn}
    A looping branch $L$ is a (possibly infinite) set of complete paths such that $L$ is the language described by a single union-free regular expression over a valid transition alphabet $\Sigma_T$.
\end{defn}

For a looping branch $L$, we will use $R_L$ to denote the minimal union-free regular expression that defines $L$. 

\begin{defn}[Coupling strategy for a looping branch]
    Let $r$ be the union-free regular expression describing paths in a looping branch $L$. Let $T_r$ be the set of all transitions that appear in $r$. Then a coupling strategy $C = (\gamma, \gamma')$ for a looping branch is a function $C:T_r\times[-1, 1] \to [-1, 1]\times[-1, 1]$ that computes shifts for each transition in $L$ as a function of the difference between two adjacent inputs. 
\end{defn}


\begin{defn}[Induced Coupling Strategy]
    {\color{red}not sure how necessary this is}
    Given a coupling strategy $C = (\gamma, \gamma')$ for a looping branch $L$ and a specific path $\rho\in L$, the coupling strategy for $\rho=q_0\to \ldots \to q_n$ induced by $C$ is the pair of functions $\gamma_\rho, \gamma'_\rho$ such that 
    \begin{align*}
        \gamma_\rho(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= (\gamma(q_0\to q_1)(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}), \gamma(q_1\to q_2)(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}), \ldots,\gamma(q_{n-1}\to q_n)(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) )\\
        \gamma'_\rho(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= (\gamma'(q_0\to q_1)(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}), \gamma'(q_1\to q_2)(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}), \ldots,\gamma'(q_{n-1}\to q_n)(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) )
    \end{align*}
\end{defn}

One natural question that arises is whether it could be more efficient with regards to cost to 

\begin{prop}\label{ClassCouplingStrategiesAreEnoughProp}
    If there exists a valid coupling strategy $C_\rho$ with cost $cost(C_\rho)$ for every path $\rho$ of an path class $[\rho]$ in a program $A$ and $\sup_{\rho\in [\rho]}cost(C_\rho)< \infty$, then there exists a class coupling strategy $C'$ for $[\rho]$ of $A$ that is valid such that $cost(C') \leq \sup_{\rho\in [\rho]}cost(C_\rho)$. 
\end{prop}


Note that, because of the introduction of stars (or, equivalently, cycles) to our model, it is possible for a looping branch to fail to be private for \textit{any} $d>0$; i.e. every coupling strategy for a looping branch has infinite cost. We can characterize whether or not a coupling strategy has infinite cost through another constraint:

\begin{lemma}\label{finiteCostConstraintLemma}
    For a looping branch $L$, a valid coupling strategy $C = (\mathbf{\gamma}, \mathbf{\gamma}')$ has finite cost $cost(C)<\infty$ if and only if the following constraint applies for all $i$:
    \begin{itemize}
        \item If $t_i$ is contained within a star in $R_L$ (i.e. $t_i$ is in a cycle), then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$ and $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$.
    \end{itemize}
\end{lemma}


In other words, a finite-cost coupling strategy must assign shifts such that every cycle transition has 0 privacy cost. 

\begin{proof}

    ($\impliedby$)

    Let $T$ be the set of transitions $t_i$ in $L$ such that $t_i$ is \textbf{not} found under a star in $R_L$. 

    Fix a complete path $\rho\in L$ and let $C_\rho$ be the coupling strategy for $\rho$ induced by $C$. 

    Let $D_\rho$ be the set of transitions $t_i\in \rho$ such that $t_i$ is under a star in $R_L$, i.e., $t_i\notin T$.  

    If the given constraint holds, then we know that $\max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i: t_i\in D_\rho}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i' = 0$

    So \begin{align*}
        cost(C_\rho) = \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}&\sum_{i: t_i\in D_\rho}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'\\
        &+\sum_{i: t_i\notin D_\rho}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'\\
        = \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}&\sum_{i: t_i\in T}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'\\
        \leq \sum_{i:t_i\in T}(2d_i& + 2d_i')\\
        \leq |T|\max_{i:t_i\in T}&(2d_i + 2d_i')
    \end{align*}

    Thus, $cost(C)\leq |T|\max_{i:t_i\in T}(2d_i + 2d_i') <\infty$.

    ($\implies$)

    Let $t_i$ be a transition in $L$ under a star in $R_L$ such that $\gamma_i\neq -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$ or $\gamma_i'\neq  -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$.     Thus, $\exists \texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ such that $(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'>0$.
    Fix such a $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$. 

    Then there exists some complete path $\rho$ in $L$ of the form $a(bt_ic)^*d$ for some $a, b, c, d\in \Sigma_T^*$.
    
    Let $\rho_k=a(bt_ic)^kd$ be the corresponding complete path in $L$ with $(bt_ic)$ iterated $k$ times. This is equivalent to iterating the cycle containing $t_i$ $k$ times. Then for all $k\in \NN$, \begin{align*}
        cost(\rho_k) \geq k((|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'),
    \end{align*}
    so for all $M\in \RR$, $\exists \rho_k$ such that $cost(\rho_k) > M$.
\end{proof}

In particular, we can combine this constraint that gives us \textit{finite cost} class coupling strategies with the four constraints that ensure that coupling strategies are valid. 

\begin{defn}[Privacy Constraint System]
    Let $L$ be a looping branch over a valid transition alphabet $\Sigma_T$. If, for a candidate coupling strategy $C_L = (\gamma, \gamma')$ for $L$, the following constraints are satisfied for all $i$: \begin{enumerate}
        \item If $c_i = \lguard[\texttt{x}]$, then $\gamma_i\leq\gamma_{at(i)}$
        \item If $c_i = \gguard[\texttt{x}]$, then $\gamma_i\geq\gamma_{at(i)}$
        \item If $\sigma_i = \texttt{insample}$, then $\gamma_i=0$
        \item If $\sigma_i = \texttt{insample}'$, then $\gamma_i'=0$
        \item If $t_i$ is in a cycle, then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $t_i$ is in a cycle, then $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
    \end{enumerate}
    then we say that $C$ satisfies the privacy constraint system for $L$. 
\end{defn}

This provides a useful tool for the decision problem of privacy, which we will discuss in more depth later. 

\begin{prop}\label{privacyFiniteCostProp}
    If there exists a coupling strategy $C$ for a looping branch $L$ that satisfies the privacy constraint system, then there exists a finite $d>0$ such that $L$ is $d\varepsilon$-differentially private. 
\end{prop}

\subsection{Programs}

\begin{defn}
    A program $P$ is a finite union of looping branches over a valid finite alphabet of transitions. 
\end{defn}

Naturally, this means that $P$ is a language described by a regular expression in union normal form such that each individual term describes a looping branch. 

\begin{lemma}
    If, for every looping branch $L$ in $P$, there exists a valid coupling strategy $C_L$, then $P$ is $(\max_{L\in P} cost(C_L))\varepsilon$-differentially private. 
\end{lemma}
\begin{proof}
    Follows immediately from definitions. 
\end{proof}

\subsection{Deciding Privacy}

We are primarily(?) concerned with the boolean question of privacy; that is, deciding whether or not there exists \textit{any} finite $d>0$ such that a program is $d\varepsilon$-differentially private. 

Clearly, we can algorithmically show that at least some subset of differentially private programs are private through the use of couplings and coupling strategies. 

\begin{lemma}
    If, for every looping branch $L\subseteq P$ in a program $P$, there exists a coupling strategy $C_L$ that satisfies the privacy constraint system, then there exists some finite $d>0$ such that $P$ is $d\varepsilon$-differentially private.    
\end{lemma}
\begin{proof}
    Follows immediately from proposition \ref{privacyFiniteCostProp}.
\end{proof}

Perhaps surprisingly though, we show that coupling proofs are \textbf{complete} for programs of this form; every differentially private program can be proved to be private using couplings. 

\begin{lemma}\label{ProgramCounterexampleLemma}
    If, for some looping branch $L\subseteq P$ in a program $P$, there does not exist a coupling strategy $C_L$ that satisfies the privacy constraint system, then there does not exist any finite $d>0$ such that $P$ is $d\varepsilon$-differentially private.
\end{lemma}

\subsection{DiPA}

We now discuss a previously defined program model, DiPA, which turns out to be exactly equivalent to our own program model. 

\begin{defn}[\cite{chadhaLinearTimeDecidability2021}]
    A Differentially Private Automaton (DiPA) $A$ is an 8-tuple $(Q, \Sigma, C, \Gamma, q_{init}, X, P, \delta)$ where
    \begin{itemize}
        \item $Q$ is a finite set of states partitioned into input states $Q_{in}$ and non-input states $Q_{non}$. 
        \item $\Sigma = \RR$ is the input alphabet
        \item $C = \{\texttt{true}, \lguard, \gguard\}$ is a set of guard conditions
        \item $\Gamma$ is a finite output alphabet
        \item $q_{init}\in Q$ is the initial state
        \item $X = \{\texttt{x}, \texttt{insample}, \texttt{insample}'\}$ is a set of variables
        \item $P: Q\to \QQ\times \QQ^{\geq 0}\times \QQ\times  \QQ^{\geq 0}$ is a parameter function that assigns sampling parameters for the Laplace distribution for each state
        \item $\delta:(Q\times C)\to (Q\times (\Gamma \cup \{\texttt{insample}, \texttt{insample}'\})\times \{\texttt{true}, \texttt{false}\})$ is a partial transition function. 
    \end{itemize}
    In addition, $\delta$ must satisfy some additional conditions:
    \begin{itemize}
        \item \textbf{Determinism:} For any state $q\in Q$, if $\delta(q,\texttt{true})$ is defined, then $\delta(q,\lguard)$ and $\delta(q,\gguard)$ are not defined. 

        \item \textbf{Output Distinction:} For any state $q\in Q$, if $\delta(q, \gguard) = (q_1, o_1, b_1)$ and $\delta(q, \lguard) = (q_2, o_2, b_2)$, then $o_1\neq o_2$ and at least one of $o_1\in \Gamma$ and $o_2\in \Gamma$ is true.

        \item \textbf{Initialization:} The initial state $q_0$ has only one outgoing transition of the form $\delta(q_0, \texttt{true}) = (q, o, \texttt{true})$.

        \item \textbf{Non-input transition:} From any $q\in Q_{non}$, if $\delta(q, c)$ is defined, then $c=\texttt{true}$.
    \end{itemize}
\end{defn}

A DiPA operates as follows: 
\begin{itemize}
    \item At each state, a real-valued input $\texttt{in}$ is read in and two variables $\texttt{insample}\sim \Lap(\texttt{in}, d\varepsilon)$ and $\texttt{insample}'\sim\Lap(\texttt{in}, d\varepsilon)$ are sampled.
    \item $\texttt{insample}$ is compared to the stored variable $\texttt{x}$, and depending on the guards of the transitions out of the current state, changes the current state and outputs a value. This value can either be $\texttt{insample}, \texttt{insample}'$, or a symbol from $\Gamma$.
    \item Finally, the  value of $\texttt{x}$ is optionally updated with the value of $\texttt{insample}$.
\end{itemize}

\begin{defn}
    Let $\rho$ be a path in a DiPA $A$, let $\texttt{in}$ be a valid input sequence and let $o$ be a possible output of $\rho$. In particular, if $o_i\in \{\texttt{insample}, \texttt{insample}'\}$, then we require that $o_i$ is an \textit{interval} $(a, b)\subseteq \RR$, rather than simply a measurable set as before. 
    Then $\texttt{Pr}[x, \rho, \texttt{in}, o]$ is the probability of $\rho$ being taken with input sequence $\texttt{in}$ and outputting $o$. If the first state in $\rho$ is $q_{init}$, then $\texttt{Pr}[x, \rho, \texttt{in}, o]$ may be shortened to $\texttt{Pr}[\rho, \texttt{in}, o]$, since the initial value of $\texttt{x}$ is irrelevant.
\end{defn}

For a full numerical definition, we refer back to the original work. 

\begin{defn}
    A DiPA $A$ is $d\varepsilon$-differentially private for some $d>0$ if for all paths $\rho$ in $A$, for all possible outputs $o$ of $\rho$ and valid adjacent input sequences $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$, \[
        \PP[\rho, \texttt{in}\brangle{1}, o]\leq e^{d\varepsilon} \PP[\rho, \texttt{in}\brangle{2}, o]
    \]
\end{defn}

We can draw a direct equivalence between programs and DiPAs.

\begin{prop}
    Every path $\rho$ through a DiPA $A$ is represented by a complete path $\hat{\rho}$ comprised of transitions from a valid transition alphabet $\Sigma_T$; further, the set of all possible paths through $A$ is a regular language over $\Sigma_T$.
\end{prop}
\begin{proof}
    Let $\rho = q_0\to q_1\to\ldots \to q_n$ be a path in a DiPA $A=(Q, \RR, C, \Gamma, q_0, X, P, \delta)$. 

    For all $i\in 0\ldots n-1$, there must be some $c_i$ such that $\delta(q_i, c_i) = (q_{i+1}, \sigma_i, \tau_i)$. Let $t_i = (q_i, q_{i+1}, c_i, \sigma_i, \tau_i)$ and let $\Sigma_\rho = \{t_i: i\in 0\ldots n-1\}$ be the set of all such transitions. Note that because $\delta$ satisfies the conditions of determinism, output distinction, initialization, and non-input transition, $\Sigma_\rho$ must as well. 
    Then let $\hat{\rho} = t_0\cdot t_1\cdot \ldots\cdot t_{i-1}$ be the representation of $\rho$ as a word over $\Sigma_\rho$. 

    Let $\Sigma_T = \bigcup_{\rho\in A}\Sigma_\rho$. Note that $\Sigma_T$ must have finite size because $A$ is a finite automaton and must still be a valid transition alphabet.

    Let $D = (Q, \Sigma_T, \delta_D, q_0, F=Q)$ be an NFA defined over the set of program locations $Q$ such that $\delta_D$ is defined as follows:
    Let $q\in Q$ be an arbitrary state. If $\delta(q, c) = (q', \sigma, \tau)$ is defined for some $c\in C$, let $\delta_D(q, (q, q', c, \sigma, \tau)) = q'$.

    Then clearly every path in $A$ is also a path in $D$ and vice versa; since every state in $D$ is an accepting state, $\mathcal{L}(D) = \{\hat{\rho}: \rho\in A\}$. Thus, the set of (representations of) all paths in $A$ must be a regular language. 
\end{proof}

As expected, the probability of a path ``succeeding'' in a program is the same as the probability of a path being traversed in a DiPA. 

\begin{prop}
    For all paths $\rho$ in a DiPA $A$ and for all input sequences $\texttt{in}$ and possible outputs $\sigma$ of $\rho$, $\PP[\rho, \texttt{in}, \sigma] = \PP[\hat{\rho}, \texttt{in}, \sigma]$.
\end{prop}
\begin{proof}
    Follows immediately from definitions. 
\end{proof}

\begin{prop}
    For every program $P$ over a valid transition alphabet $\Sigma_T$, there exists a corresponding DiPA $A$ such that there exists a path $\rho$ in $A$ if and only if its representation is in $P$. 
\end{prop}
\begin{proof}
    The DiPA can be directly constructed from $P$.
\end{proof}

Interestingly, the privacy of any DiPA $A$ is completely characterized by four graph-theoretic structures (we omit the precise definitions here). 

\begin{thm}[\cite{chadhaLinearTimeDecidability2021}]\label{DiPACounterexamplesThm}
    A DiPA $A$ does not have a leaking cycle, leaking pair, disclosing cycle, or privacy violating path if and only if there exists some $d>0$ such that for all $\varepsilon>0$, $A$ is $d\varepsilon$-differentially private. 
\end{thm}

\begin{cor}
    If the corresponding DiPA $A$ to a program $P$ contains a leaking cycle, leaking pair, disclosing cycle, or privacy violating path, then does not exist a finite $d>0$ such that $P$ is $d\varepsilon$-differentially private. 
\end{cor}


\subsection{An algorithm for deciding privacy}

Observe that the constraints imposed on valid coupling strategies for a complete path $\rho$ only depend on the shifts associated with \textit{assignment transitions} in $\rho$. 

In particular, this lends itself to conceptualizing complete paths by splitting them up based on assignment transitions. 

\begin{defn}
    For a complete path $\rho$ in a program $P$, let $A_\rho$ be the set of all assignment transitions in $\rho$. 
\end{defn}

\begin{defn}
    A \textbf{segment} of a (complete) path $\rho = q_0\to\ldots\to q_n$ is a subpath $q_i \to q_{i+1}\to \ldots \to q_j$ of $\rho$ such that $t_i \in A_\rho$; for all $i<k<j$, $t_k \notin A_\rho$; and either $j=n$ or $t_j \in A_\rho$.
\end{defn}

In other words, a segment is a subpath of $\rho$ between two consecutive assignment transitions (or between the last assignment transition and the end of the path). Splitting up a path into segments thus allows us to think about a single value of $\texttt{x}$ at a time.


% The segment graph overview

\begin{defn}
    Given segments $s_i$ and $s_j$ of a path $\rho$, we say that $s_j$ follows $s_i$ (written $s_i \hookrightarrow s_j$) if $s_j$ is a subpath of $\rho$ occurring immediately after $s_i$ in $\rho$.
\end{defn}


\begin{defn}[Segment graph of a program]
    Given a DiPA $\mathcal{A}$, the segment graph $G_P = (V, E)$ of $\mathcal{A}$ is a directed graph where: 
    \begin{itemize}
        \item For every segment $s_i \in seg(\mathcal{A})$, there is a vertex $v_i \in V$ representing the coupling shift on the assignment transition of $s_i$.
        \item For every pair of segments $(s_i, s_j)$ which have the privacy constraint $\gamma_i \leq \gamma_j$, there is an edge $(v_i, v_j) \in E$.
        \item There are nodes ${\bf 1, -1}\ \in V$ such that: 
        \begin{itemize}
            \item The edges $({\bf -1}, v)$ exist for all $v \in V$.
            \item The edges $(v, {\bf 1})$ exist for all $v \in V$.
            \item For every segment $s_i$ with the privacy constraint $\gamma_i = 1$, there is an edge $({\bf 1}, v_i) \in E$.
            \item For every segment $s_i$ with the privacy constraint $\gamma_i = -1$, there is an edge $(v_i, {\bf -1}) \in E$. 
        \end{itemize}
    \end{itemize}
\end{defn}

\begin{lemma}
    \label{lemma:segpath}
    Let there exist a path $v_1 \to \dots \to v_k$ in the segment graph of $\mathcal{A}$, and let the corresponding segments be $s_{i_1}, \dots, s_{i_k}$. Then we either have that 
    
    \[s_{i_1} \hookrightarrow s_{i_2} \hookrightarrow \dots \hookrightarrow s_{i_k} \qquad \text{ and } \qquad guard(s_{i_k}) = <\]
    
    or 
    
    \[s_{i_k} \hookrightarrow s_{i_{k - 1}} \hookrightarrow \dots \hookrightarrow s_{i_1} \qquad \text{ and } \qquad guard(s_{i_k}) = \geq\]
\end{lemma}

\begin{proof}
    We will use induction on $k$ with base case $k = 2$. If we have $v_1 \to v_2$ in the segment  graph, then we either have that $s_{i_1} \hookrightarrow s_{i_2}$ with $guard(s_{i_2}) = <$, or that $s_{i_2} \hookrightarrow s_{i_1}$ with $guard(s_{i_2}) = \geq$. For a path with length $k + 1$ in the segment  graph, let us assume the desired result. Then apply the base case on $s_{i_{k}} \to s_{i_{k + 1}}$ to conclude. 
\end{proof}

\begin{thm}
    \label{theorem:decide_privacy}
    A DiPA $\mathcal{A}$ is differentially private if and only if there does not exist a path from $\bf 1$ to $\bf -1$ in the segment graph of $\mathcal{A}$.
\end{thm}

\begin{proof}
    $(\implies)$ Suppose that $\mathcal{A}$ is differentially private. Then there exists a shift-coupling proof of privacy $\Gamma$ with finite cost. Assume that there exists a path ${\bf 1} \to v_1 \to \dots \to v_k \to {\bf -1}$ in the segment graph of $\mathcal{A}$. 
    Without loss of generality, we have the sequence of segments $s_{i_1} \hookrightarrow \dots \hookrightarrow s_{i_k}$ corresponding to the path by Lemma \ref{lemma:segpath}. We can then extend this to a sequence of segments $s_1 \to \dots \to s_{i_1} \to \dots \to s_{i_k} \to \dots \to s_n$ that begins with the initialization segment and ends with a terminal segment. 

    If we restrict the segment-shift graph to only these segments, we find that any assignment of shifts $\gamma$ would not be valid, as we would be able to construct a sequence of inequalities to conclude that $1 \leq -1$, which is false. Thus, there is no valid assignment of shifts $\gamma$ for this sequence of segments with finite cost, and so $\Gamma$ is not a shift-coupling proof of privacy with finite cost. This is a contradiction.

    $(\impliedby)$ This direction follows from the fact that there is \textit{some} valid assignment of shifts $\gamma$ with finite cost on each segment, and so we can construct a shift-coupling proof of privacy $\Gamma$ with finite cost.
\end{proof}

We can construct the segment graph of a DiPA in linear time, and check for a path from $\bf 1$ to $\bf -1$ in linear time using a breadth-first search. Thus, we can decide privacy in linear time.

\subsection{Minimizing a privacy budget}

If we have a differentially private program, we'd also like to optimize its privacy cost. We can do so via couplings. We can partition a program into a finite set of looping branches, and then optimize the privacy cost of each looping branch individually.

\begin{prop}
    \label{prop:compute_opt_cost}
    Let $L$ be a looping branch in a program $P$ consisting of $n$ transitions. The cost $opt(L)$ of the optimal coupling strategy for $L$ can be computed by the following optimization problem: 
    \begin{align*}
        opt(L) = \max_{\Delta \in [-1, 1]^n} &\min_{\gamma, \gamma' \in [-1, 1]^n} \sum_{i = 1}^n \left(|\Delta_i - \gamma_i| d_i + |\Delta_i - \gamma_i'|d_i' \right)\\ 
            \text{subject to }
            &\ \gamma_{at(i)} \leq \gamma_i \text{ if } c_i = \gguard, \\
            &\ \gamma_{at(i)} \geq \gamma_i \text{ if } c_i = \lguard, \\
            &\ \gamma_i = 0 \text{ if } \sigma_i = \texttt{insample}, \\
            &\ \gamma_i' = 0 \text{ if } \sigma_i = \texttt{insample}'\\
            &\ \gamma_i = \gamma_i'= \Delta_i \text{ if } t_i \text{ is in a cycle}
    \end{align*}
    If a looping branch $L$ is not differentially private, a solution to this optimization problem does not exist, and we write $opt(L) = \infty$.
\end{prop}

\begin{proof}
    Assume that $L$ is differentially private. Then there exists a valid coupling strategy for $L$ with finite cost, showing that the constraints above are feasible, and a finite solution to the optimization problem exists.  

    We will specify a valid coupling strategy $C^* = (\gamma^*, {\gamma'}^*)$ for $L$ with the cost stated above, and then show it is optimal. Define $\Gamma: [-1, 1]^n \to [-1, 1]^n \times [-1, 1]^n$ as follows, where $\Gamma(\Delta)$ is a pair $(\gamma, \gamma')$: 
    \begin{align*}
        \Gamma(\Delta) = &\argmin_{\gamma, \gamma' \in [-1, 1]^n} \sum_{i = 1}^n \left(|\Delta_i - \gamma_i| d_i + |\Delta_i - \gamma_i'|d_i' \right)\\ 
        \text{subject to }
        &\ \gamma_{at(i)} \leq \gamma_i \text{ if } c_i = \gguard, \\
        &\ \gamma_{at(i)} \geq \gamma_i \text{ if } c_i = \lguard, \\
        &\ \gamma_i = 0 \text{ if } \sigma_i = \texttt{insample}, \\
        &\ \gamma_i' = 0 \text{ if } \sigma_i = \texttt{insample}'\\
        &\ \gamma_i = \gamma_i'= \Delta_i \text{ if } t_i \text{ is in a cycle}
    \end{align*}
    Then define \[(\gamma^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}), {\gamma'}^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})) = \Gamma(\texttt{in}\brangle{1} - \texttt{in}\brangle{2})\]

    Notice the following: 

    \begin{enumerate}
        \item $C^*$ is a valid coupling strategy for $L$, since the privacy constraints on $\gamma^*$ and ${\gamma'}^*$ are satisfied by construction.
        \item $C^*$ has the cost given by the solution to the optimization problem, since 
        \begin{align*}
            cost(C^*) &= \max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}} \sum_{i = 1}^n  |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - \gamma_i^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})| d_i \\ 
            \phantom{cost(C^*)} &\phantom{=\max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}}\qquad } + |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - {\gamma'}_i^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})|d_i' \\
            &= \max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}} \sum_{i = 1}^n  |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - \Gamma_1(\texttt{in}\brangle{1} - \texttt{in}\brangle{2})_i| d_i \\ 
            \phantom{cost(C^*)} &\phantom{=\max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}}\qquad } + |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - \Gamma_2(\texttt{in}\brangle{1} - \texttt{in}\brangle{2})_i|d_i' \\
            &= \max_{\Delta \in [-1, 1]^n} \sum_{i = 1}^n  |\Delta_i - \Gamma_1(\Delta)_i| d_i + |\Delta_i - \Gamma_2(\Delta)_i|d_i' \\
            &= \max_{\Delta \in [-1, 1]^n} \min_{\gamma, \gamma' \in [-1, 1]^n} \sum_{i = 1}^n  |\Delta_i - \gamma_i| d_i + |\Delta_i - \gamma_i'|d_i'
        \end{align*}
        \item $C^*$ is optimal, since for any valid coupling strategy $C = (\delta, \delta')$ for $L$, we have
        \begin{align*}
            cost(C) &= \max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}} \sum_{i = 1}^n  |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - \delta_i(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})| d_i \\
            \phantom{cost(C)} &\phantom{=\max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}}\qquad } + |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - \delta_i'(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})|d_i' \\
            &\geq \max_{\Delta \in [-1, 1]^n} \sum_{i = 1}^n  |\Delta_i - \delta_i(0, \Delta_i)| d_i + |\Delta_i - \delta_i'(0, \Delta_i)|d_i' \\
            &\geq \max_{\Delta \in [-1, 1]^n} \min_{\gamma, \gamma' \in [-1, 1]^n} \sum_{i = 1}^n \left(|\Delta_i - \gamma_i| d_i + |\Delta_i - \gamma_i'|d_i' \right)\\
            &= cost(C^*)
        \end{align*}
    \end{enumerate}
    which shows that the optimization problem computes the optimal cost of a coupling strategy for $L$ that satisfies the privacy constraints.
\end{proof}

Note: the inner problem is convex, and so the outer problem is that of convex maximization. 

\begin{defn}
    Define the approximate privacy cost of a differentially private looping branch $L$ to be as follows. Let $I$ be the set of transitions in $L$ that do $\textit{not}$ appear in a cycle.  
    \begin{align*} 
        approx(L) = &\sum_{t_i \text{outputs \texttt{insample}}} d_i' + \min_{\gamma \in [-1, 1]^n} \sum_{i \in I} \left(1 + |\gamma_i| \right) d_i  \\
            \text{subject to } 
            &\ \gamma_{at(i)} \leq \gamma_i \text{ if } c_i = \gguard, \\
            &\ \gamma_{at(i)} \geq \gamma_i \text{ if } c_i = \lguard, \\
            &\ \gamma_i = 0 \text{ if } \sigma_i = \texttt{insample}, \\
            &\ \gamma_i = 1 \text{ if } t_i \text{ is in a cycle and has } c_i = \lguard,\\ 
            &\ \gamma_i = -1 \text{ if } t_i \text{ is in a cycle and has } c_i = \gguard
    \end{align*}
    which is the cost of a coupling strategy in which $\gamma$ and $\gamma'$ are constant with respect to $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$ on each transition. 
\end{defn}

\begin{prop}
    Given a differentially private looping branch $L$, there exists a valid coupling strategy $C_L$ for $L$ such that $cost(C_L) = approx(L)$.
\end{prop}

\begin{proof}
    Let 
    \[\gamma = \argmin_{\gamma \in [-1, 1]^n} \sum_{i \in I} \left(1 + |\gamma_i| \right) d_i\]
    subject to the constraints above. Define $C_L = (\gamma^*, {\gamma'}^*)$ where
    \begin{align*}
        \gamma_i^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= \begin{cases}
            \texttt{in}\brangle{1}_i - \texttt{in}\brangle{2}_i &\text{ if } t_i \text{ is in a cycle} \\
            \gamma_i &\text{ otherwise}
        \end{cases} \\[1em]
        {\gamma'}_i^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= \begin{cases}
            0 &\text{ if } t_i \text{ outputs \texttt{insample}} \\
            \texttt{in}\brangle{1}_i - \texttt{in}\brangle{2}_i &\text{ otherwise}
        \end{cases}
    \end{align*}
    Notice the following: 

    \begin{itemize}
        \item $C_L$ satisfies the privacy constraints, and so is valid.
        
        If $t_i$ is in a cycle with $c_i = \lguard$, then the constraints on $\gamma$ require that $\gamma_i = 1$, and so $1 = \gamma_i \leq \gamma_{at(i)} = 1$. As a result, we will satisfy the privacy constraint $\gamma_{at(i)}^* \geq \gamma_i^*$: 
        \[\gamma_i^* = \texttt{in}\brangle{1}_i - \texttt{in}\brangle{2}_i \leq 1 = \gamma_{at(i)}^*\]
        A similar argument holds for if $t_i$ is in a cycle with $c_i = \gguard$.

        All other privacy constraints are satisfied by construction.

        \item $C_L$ has the cost given by the solution to the optimization problem, since
        
        \begin{align*}
            cost(C_L) &= \max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}} \sum_{i = 1}^n  |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - \gamma_i^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})| d_i \\ 
            \phantom{cost(C_L)} &\phantom{=\max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}}\qquad } + |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - {\gamma'}_i^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})|d_i' \\
            &= \max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}} \left(\sum_{i \in I} |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - \gamma_i^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})| d_i\right) \\
            \phantom{cost(C_L)} &\phantom{=\max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}}\qquad } + \left(\sum_{t_i \text{outputs \texttt{insample}}}|\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - {\gamma'}_i^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})|d_i'\right)\\
            &= \max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}} \left(\sum_{i \in I} |\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2} - \gamma_i| d_i\right) \\
            \phantom{cost(C_L)} &\phantom{=\max_{\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}}\qquad } + \left(\sum_{t_i \text{outputs \texttt{insample}}}|\texttt{in}_i\brangle{1} - \texttt{in}_i\brangle{2}|d_i'\right)\\
            &= \sum_{i \in I} (1 + |\gamma_i|) d_i + \sum_{t_i \text{outputs \texttt{insample}}} d_i' \\
            &= approx(L)
        \end{align*}
    \end{itemize}
\end{proof}

\begin{prop}
    The approximate privacy cost of $L$ can be computed in time polynomial in $n$, the number of transitions in $L$.
\end{prop}

\begin{proof}
    To compute the solution to the minimization problem, we can set up the following linear program: 
    \begin{align*}
        \min_{\gamma, v_i \in [-1, 1]^n} &\sum_{i = 1}^n \left(1 + v_i \right) d_i \\ 
            \text{subject to } 
            &\ \gamma_{at(i)} \leq \gamma_i \text{ if } c_i = \lguard, \\
            &\ \gamma_{at(i)} \geq \gamma_i \text{ if } c_i = \gguard, \\
            &\ \gamma_i = 0 \text{ if } \sigma_i = \texttt{insample}, \\
            &\ \gamma_i = 1 \text{ if } t_i \text{ is in a cycle and has } c_i = \lguard,\\ 
            &\ \gamma_i = -1 \text{ if } t_i \text{ is in a cycle and has } c_i = \gguard,\\
            &\ \gamma_i \leq v_i, -\gamma_i \leq v_i \text{ for all } i \in \{1, \dots, n\} 
    \end{align*}
    This program can be solved using the ellipsoid method in polynomial time.
\end{proof}

\begin{prop}
    For a looping branch $L$ with $n$ distinct transitions, we have 
    \[opt(L) \leq approx(L) \leq opt(L) + \sum_{i \in I }^n d_i + \sum_{t_i \text{outputs \texttt{insample}}} d_i'\]
    where $I$ is the set of transitions in $L$ that do $\textit{not}$ appear in a cycle.
\end{prop}

\begin{proof}
    We have $opt(L) \leq approx(L)$ by Proposition \ref{prop:compute_opt_cost}. Let $I$ be the set of transitions in $L$ that do $\textit{not}$ appear in a cycle. Then we have
    \begin{align*}
        opt(L) &= \max_{\Delta \in [-1, 1]^n} \min_{\gamma, \gamma' \in [-1, 1]^n} \sum_{i = 1}^n \left(|\Delta_i - \gamma_i| d_i + |\Delta_i - \gamma_i'|d_i' \right)\\
        &= \max_{\Delta \in [-1, 1]^n} \min_{\gamma, \gamma' \in [-1, 1]^n} \sum_{i \in I} \left(|\Delta_i - \gamma_i| d_i + |\Delta_i - \gamma_i'|d_i' \right)\\
        &= \max_{\Delta \in [-1, 1]^n} \min_{\gamma, \gamma' \in [-1, 1]^n} \left(\sum_{i \in I} \left(|\Delta_i - \gamma_i| d_i \right) + \sum_{t_i \text{outputs \texttt{insample}}} |\Delta_i| d_i' \right)\\
        &\geq \max_{\Delta \in [-1, 1]^n} \min_{\gamma, \gamma' \in [-1, 1]^n} \left(\sum_{i \in I} \left(|\gamma_i| - |\Delta_i| \right) d_i  + \sum_{t_i \text{outputs \texttt{insample}}} |\Delta_i| d_i' \right)\\
        &= \max_{\Delta \in [-1, 1]^n} \left(- \sum_{i \in I} |\Delta_i| d_i + \sum_{t_i \text{outputs \texttt{insample}}} |\Delta_i| d_i' + \min_{\gamma, \gamma' \in [-1, 1]^n} \sum_{i \in I}|\gamma_i| d_i \right)\\
        &\geq \min_{\gamma, \gamma' \in [-1, 1]^n} \sum_{i \in I}|\gamma_i| d_i \\
        &= approx(L) - \sum_{t_i \text{outputs \texttt{insample}}} d_i' - \sum_{i \in I} d_i'
    \end{align*}
    showing the second inequality.
\end{proof}


\begin{conj}
    The optimal coupling cost is the ``true'' privacy cost of a looping branch. That is, 
    \begin{align*}
        opt(L) = \sup_{\rho \in L} \sup_{\texttt{in}\brangle{1} \sim \texttt{in}\brangle{2}} D_\infty(\PP[\rho, \texttt{in}\brangle{1}, o]\; ||\; \PP[\rho, \texttt{in}\brangle{2}, o])
    \end{align*}
    representing the worst-case privacy loss over all possible paths in $L$ and all possible adjacent inputs.
\end{conj}

\subsection{Deciding Privacy II}

We can check whether a looping branch is differentially private by checking whether the approximate privacy cost of the looping branch is finite. This is true if and only if the \textit{approximate privacy constraints} {(\color{red} Is this the right name?)} are feasible.


\begin{prop}
    We can check whether the approximate privacy constraints are feasible in linear time in $n$, the number of transitions in the looping branch.
\end{prop}

\begin{proof} (Sketch)

    (If there is a transition in a cycle that outputs \texttt{insample}, then the approximate privacy constraints are not feasible, and we can return false. There is a way to encode this also into 2-SAT, but is it really worth it? So we'll only consider $\gamma$ in this sketch). 
    
    We will construct a reduction to 2-SAT.

    \begin{itemize}
        \item For every transition $t_i$ in the looping branch, construct the variable $x_i$, which represents whether $\gamma_i = 1$ ($x_i$ = 1) or $\gamma_i = -1$ ($x_i$ = 0).
        \item For every constraint $\gamma_j \leq \gamma_i$, construct 
        \begin{equation}
            \lnot x_j \lor x_i
        \end{equation}
        essentially encoding $\gamma_j = 1 \implies \gamma_i = 1$.
        \item For every constrint $\gamma_i = 1$, construct the clause
        \begin{equation}
            x_i
        \end{equation}
        and for every constraint $\gamma_i = -1$, construct the clause
        \begin{equation}
            \lnot x_i
        \end{equation}
    \end{itemize}

    We can check whether the constraints are feasible by checking whether the resulting 2-SAT instance is satisfiable. This can be done in linear time in $n$ using the algorithm described in (TODO: Cite 2-SAT algorithm).
\end{proof}

\section{Program Model Extensions}

The class of programs we have defined is rather limited, leading to the natural question of whether our results can be extended to more powerful program models. 

Some `natural' extensions of DiPA end up reducing directly to DiPA. For example, we considered an extension of DiPA that included a single integral ``counter'' variable $n$; this program model also allowed for branching conditional on $n$ being greater than a threshold value. 
We discovered that every DiPA equipped with a counter can be rewritten as a standard DiPA by using a power set-style automata construction. 

However, there are other, non-trivial, extensions that warrant further study. In particular, we describe one extension of DiPA that allows for two real-valued program variables $\texttt{x}, \texttt{y}$.

\subsection{Two-Variable Programs: GDiPA}

\subsubsection{Multivariable Transitions}

\begin{defn}[Two-variable guards]
    Let $\texttt{x}, \texttt{y}$ be real-valued program variables. Then a transition \textbf{guard} is a boolean statement $c = c(x)\oplus c(y)$ where \begin{itemize}
        \item $c(x)\in \{\texttt{true}, \lguard[\texttt{x}], \gguard[\texttt{x}]\}$
        \item $c(y)\in \{\texttt{true}, \lguard[\texttt{y}], \gguard[\texttt{y}]\}$
        \item $\oplus \in \{\land, \lor\}$
    \end{itemize}
    As expected, if, for example, $c = c(x) \land \texttt{true}$, we will shorthand $c$ to $c(x)$ and if $c = c(x)\lor \texttt{true}$, we will shorthand $c$ to $\texttt{true}$. In general, we will use $c(x)$ and $c(y)$ to notate the $\texttt{x}$ and $\texttt{y}$ components of a two-variable guard. 

    Let $\mathcal{C}^{(2)}$ be the set of all possible guards with two variables \texttt{x} and \texttt{y}.
\end{defn}

\begin{defn}[2v-transitions]
    A two-variable transition (2v-transition) is a tuple $(q, q', c, \sigma, \tau)$ where \begin{itemize}
        \item $q\in Q$ is the initial state
        \item $q'\in Q$ is the destination state
        \item $c\in\mathcal{C}^{(2)}$ is a transition guard.
        \item $\sigma\in\Gamma\cup\{\texttt{insample}^{(x)}, \texttt{insample}^{(x)\prime}, \texttt{insample}^{(y)}, \texttt{insample}^{(y)\prime}\}$ is the output of the transition
        \item $\tau \in \{0, 1, 2\}$ indicates whether to assign into no variable, $\texttt{x}$, or $\texttt{y}$. In particular, note that only a single variable can be assigned into at a time. 
    \end{itemize}
\end{defn}

\subsubsection{Two Variable Program Semantics}

Two variable transitions semantically operate extremely similarly to single variable transitions: given some threshold values $\texttt{x}$ and $\texttt{y}$, each transition $t = (q, q', c, \sigma, \tau)$ will first read in a real number input $\texttt{in}$, 
sample two random variables $z^{(x)}\sim\Lap(0, \frac{1}{d\varepsilon})$ and $z^{(x)\prime}\sim\Lap(0, \frac{1}{d'\varepsilon})$ for comparing the input to $\texttt{x}$ and two more random variables $z^{(y)}\sim\Lap(0, \frac{1}{d\varepsilon})$ and $z^{(y)\prime}\sim\Lap(0, \frac{1}{d'\varepsilon})$ for comparing the input to $\texttt{y}$.
Using these noise variables, the transition then assigns four variables $\texttt{insample}^{(x)} = \texttt{in} + z^{(x)}$, $\texttt{insample}^{(x\prime)} = \texttt{in} + z^{(x)\prime}$, $\texttt{insample}^{(y)} = \texttt{in} + z^{(y)}$, and $\texttt{insample}^{(x)\prime} = \texttt{in} + z^{(y)\prime}$. 
If the guard $c$ is satisfied when comparing $\texttt{insample}^{(x)}$ to $\texttt{x}$ and $\texttt{insample}^{(y)}$ to $\texttt{y}$, then we transition to state $q'$, outputting $\sigma$ and, depending on $\tau$, optionally reassigning $\texttt{x} = \texttt{insample}^{(x)}$ or $\texttt{x} = \texttt{insample}^{(y)}$.

In particular, note that the noisy input that the threshold variables are compared to is independent for $\texttt{x}$ and $\texttt{y}$.

More formally, a program state is a tuple consisting of a program location and values for $\texttt{x}$ and $\texttt{y}$ Let $S = Q\times\RR\times \RR$ be the set of all possible program states. As expected, every possible input is simply an element of $\RR$. 
As before, the set of all possible output events is $\Gamma \cup \Sigma$, where $\Sigma$ is the standard $\sigma$-algebra of all Lebesgue measurable sets. 

Then the semantics of a 2v-transition $t$ can be defined as a function $\Phi((q, \texttt{x}), \texttt{in}): S\to dist(S\times (\Gamma\cup\Sigma\cup \lambda))$ that maps an initial program state and an input to a distribution of subsequent program states and an output event following the expected semantics; $\lambda$ here denotes the empty string (i.e. no output). 

The precise semantics are defined exactly analogously to the single variable case. 

We again denote the probability that a transition ``succeeds'' as $\PP[\texttt{x}, \texttt{y}, t, \texttt{in}, o]$, where $\texttt{x}, \texttt{y}\in \RR$ are the initial values of $\texttt{x}$ and $\texttt{y}$, respectively, $t$ is a 2v-transition, $\texttt{in}\in \RR$ is a real-valued input, and $o\in \Gamma\cup\Sigma$ is a possible output of $t$.

\begin{defn}[Valid Transition Alphabets]
    A finite 2v-transition alphabet $\Sigma_T$ is valid if it satisfies the following conditions: 
    \begin{itemize}
        \item \textbf{Initialization:} There exist some $t_{init}^{(x)}, t_{init}^{(y)}\in \Sigma_T$ such that $t_{init}^{(x)} = (q_0, q_1, \texttt{true}, \sigma_0, 1)$ and $t_{init}^{(y)} = (q_1, q_2, \texttt{true}, \sigma_1, 2)$ for some $q_0, q_1, q_2\in Q$, $\sigma_0, \sigma_1 \in \Gamma\cup\{\texttt{insample}, \texttt{insample}'\}$. 
        \item \textbf{Determinism}: If $\Sigma_T$ contains transition $t, t'$ such that $t=(q, q', c, \sigma, \tau)$ and $t'= (q, q^*, c', \sigma', \tau')$, then $c$ and $c'$ must be disjoint events. 
        \item \textbf{Output distinction}: If there exist some $\sigma, \sigma', \tau, \tau'$ such that $(q, q', c, \sigma, \tau)\in \Sigma_T$  and $(q, q^*, c', \sigma', \tau') \in \Sigma_T$ for distinct guards $c, c'$, then $\sigma \neq \sigma'$. Additionally, at least one of $\sigma\in \Gamma$, $\sigma'\in \Gamma$ is true.
        \item \textbf{Non-input state condition}: For all states $q\in Q_{non}$, if there exists a transition $t=(q, q', c, \sigma, \tau)$ such that $t\in \Sigma_T$, then $c = \texttt{true}$.
        \item \textbf{Assignment spread parameter condition}: There exists some constant $d_{at}>0$ such that for all transitions $t = (q, q', c, \sigma, \tau)\in \Sigma_T$ where $\tau \in \{1, 2\}$, $P(q) = (d_{at}, d_q')$.
    \end{itemize}
\end{defn}

- new condition, all assignment transitions have the same spread parameter on insample. 

\subsubsection{Multivariable Couplings}

\begin{lemma}
    Let $X\brangle{1}\sim \Lap(\mu_x\brangle{1}, \frac{1}{d_x\varepsilon}), X\brangle{2}\sim\Lap(\mu_x\brangle{2}, \frac{1}{d_x\varepsilon})$ be random variables be random variables representing possible initial values of $\texttt{x}$, respectively, 
    and $Y\brangle{1}\sim \Lap(\mu_y\brangle{1}, \frac{1}{d_y\varepsilon}), Y\brangle{2}\sim\Lap(\mu_y\brangle{2}, \frac{1}{d_y\varepsilon})$ be random variables be random variables representing possible initial values of $\texttt{x}$, respectively. 

    Let $t\in \Sigma_T$ be a 2v-transition $t = (q, q^*, c, \sigma, \tau)$ from $q$ to $q^*\in Q$. Let $P(q) = (d_q, d_q')$.

    Let $\texttt{in}\brangle{1}, \texttt{in}\brangle{2}$ be an arbitrary valid adjacent input pair for $t$ and let $o\brangle{1}$, $o\brangle{2}$ be random variables representing possible outputs of $t$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. 

    Then $\forall \varepsilon>0$ and for all $\gamma_T^{(x)}, \gamma_q^{(x)}, \gamma_q^{(x)\prime},\gamma_T^{(y)}, \gamma_q^{(y)}, \gamma_q^{(y)\prime}\in [-1, 1]$ that satisfy the constraints \[
        \begin{cases}
          \gamma_q^{(x)}\leq\gamma_T^{(x)} & c(x) = \lguard[\texttt{x}]\\
          \gamma_q^{(x)}\geq\gamma_T^{(x)} & c(x) = \gguard[\texttt{x}]\\
          \gamma_q^{(x)}=0 & \sigma = \texttt{insample}^{(x)}\\
          \gamma_q^{(x)\prime}=0 & \sigma = \texttt{insample}^{(x)\prime}\\
          \gamma_q^{(y)}\leq\gamma_T^{(y)} & c(y) = \lguard[\texttt{y}]\\
          \gamma_q^{(y)}\geq\gamma_T^{(y)} & c(y) = \gguard[\texttt{y}]\\
          \gamma_q^{(y)}=0 & \sigma = \texttt{insample}^{(y)}\\
          \gamma_q^{(y)\prime}=0 & \sigma = \texttt{insample}^{(y)\prime}
        \end{cases},
      \]
      the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for 
      $d = (|\mu_x\brangle{1}-\mu_x\brangle{2}+\gamma_T^{(x)}|)d_T^{(x)}+(|\mu_y\brangle{1}-\mu_y\brangle{2}+\gamma_T^{(y)}|)d_T^{(y)}+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(x)}|+|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(y)}|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(x)\prime}|+|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(y)\prime}|)d_q'$, and therefore $t$ is $d\varepsilon$-differentially private. 
\end{lemma}
\begin{proof}
    From lemma \ref{indTransitionCoupling}, we know that if these constraints are satisfied, we can create liftings such that \begin{itemize}
        \item $c(x)$ is satisfied in $\brangle{1}\implies c(x)$ is satisfied in $\brangle{2}$
        \item $c(y)$ is satisfied in $\brangle{1}\implies c(y)$ is satisfied in $\brangle{2}$
    \end{itemize}
    Further, $c$ being satisfied is equivalent to either $c(x)\land c(y)$ or $c(x)\lor c(y)$. In either case, we can immediately show that $c$ being satisfied in $\brangle{1}\implies c$ is satisfied in $\brangle{2}$.

    Finally, as before, if $\sigma \in \{\texttt{insample}^{(x)}, \texttt{insample}^{(x)\prime}, \texttt{insample}^{(y)},\texttt{insample}^{(y)\prime}\}$, then for all $\sigma$, $o\brangle{1}=\sigma \implies o\brangle{2} = \sigma$. By simply adding up the costs from lemma \ref{indTransitionCoupling}, we complete the proof.
\end{proof}



\begin{prop}
    If there exist coupling strategies $C_x, C_y$ that each independently satisfy the privacy constraint system for a 2v-transition $t$, then there exists a valid 2-coupling strategy $C$ for $t$ such that $cost(C) = cost(C_x)+cost(C_y)$. 
\end{prop}

\textbf{Cross-Couplings{\color{red}CHANGE NAME}}

We introduce a new type of coupling strategy for a single (2v-)transition:

{\color{red} need to define valid cross couplings}

We introduce a new coupling possibility - between different variable assignments


\begin{lemma}\label{mvIndTransitionCoupling}
    Let $X\brangle{1}\sim \Lap(\mu_x\brangle{1}, \frac{1}{d_x\varepsilon}), X\brangle{2}\sim\Lap(\mu_x\brangle{2}, \frac{1}{d_x\varepsilon})$ be random variables be random variables representing possible initial values of $\texttt{x}$, respectively, and $Y\brangle{1}\sim \Lap(\mu_y\brangle{1}, \frac{1}{d_y\varepsilon}), Y\brangle{2}\sim\Lap(\mu_y\brangle{2}, \frac{1}{d_y\varepsilon})$ be random variables be random variables representing possible initial values of $\texttt{x}$, respectively. 

    Let $t\in \Sigma_T$ be a  (2v-)transition $t = (q, q^*, c, \sigma, \tau)$ from $q$ to $q^*\in Q$. Let $P(q) = (d_q, d_q')$.

    Let $\texttt{in}\brangle{1}, \texttt{in}\brangle{2}$ be an arbitrary valid adjacent input pair for $t$ and let $o\brangle{1}$, $o\brangle{2}$ be random variables representing possible outputs of $t$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. 

    Then for all $\gamma_T^{(x)}, \gamma_q^{(x)}, \gamma_q^{(x)\prime},\gamma_T^{(y)}, \gamma_q^{(y)}, \gamma_q^{(y)\prime} \in [-1, 1]$ that satisfy the constraints \[
        \begin{cases}
          \gamma_q^{(x)}=0 & \sigma = \texttt{insample}^{(x)}\\
          \gamma_q^{(x)\prime}=0 & \sigma = \texttt{insample}^{(x)\prime}\\
          \gamma_q^{(y)}=0 & \sigma = \texttt{insample}^{(y)}\\
          \gamma_q^{(y)\prime}=0 & \sigma = \texttt{insample}^{(y)\prime}
        \end{cases},
      \]

    The following four statements hold:\begin{enumerate}
        \item If $c = \lguard[\texttt{x}] \land \gguard[\texttt{y}]$, then $\forall \varepsilon>0$, the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = |\min(\mu_y\brangle{1}-\mu_x\brangle{1}, 0)|+(|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_x+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$. 
        \item If $c = \gguard[\texttt{x}] \land \lguard[\texttt{y}]$, then $\forall \varepsilon>0$, the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = |\min(\mu_x\brangle{1}-\mu_y\brangle{1}, 0)|+(|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_x+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$. 
        \item If $c = \lguard[\texttt{x}] \lor \gguard[\texttt{y}]$, then $\forall \varepsilon>0$, the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = |\max(0, \mu_y\brangle{1}+ \gamma_T^{(y)}-\mu_x\brangle{1}-\gamma_T^{(x)})|+(|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_x+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$. 
        \item If $c = \gguard[\texttt{x}] \lor \lguard[\texttt{y}]$, then $\forall \varepsilon>0$, the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = |\max(0, \mu_x\brangle{1}+ \gamma_T^{(x)}-\mu_y\brangle{1}-\gamma_T^{(y)})|+(|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_x+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$. 
    \end{enumerate}
\end{lemma}
\begin{proof}
    For convenience, we will rewrite $X$ and $Y$ as $X = \mu_x + \zeta_x$ and $Y = \mu_y + \zeta_y$, where $\zeta_x \sim\Lap(0, \frac{1}{d_x\varepsilon})$ and $\zeta_y \sim\Lap(0, \frac{1}{d_x\varepsilon})$. 
    As before, we also write $\texttt{insample}^{(x)} = \texttt{in} + z^{(x)}$, where $z\sim\Lap(0, \frac{1}{d_q\varepsilon})$ and $\texttt{insample}^{(x)\prime} = \texttt{in} + z^{(x)\prime}$, where $z'\sim\Lap(0, \frac{1}{d_q'\varepsilon})$ (and symmetrically for $\texttt{insample}^{(y)}$, $\texttt{insample}^{(y)\prime}$).

    We show cases (1) and (3). Cases (2) and (4) follow symmetrically. 

    As in the single variable case, suppose that we have the liftings
    \begin{itemize}
        \item $X\brangle{1}+\gamma_T^{(x)} (=)^{\#(|\mu_x\brangle{1}-\mu_x\brangle{2}+\gamma_T^{(x)}|)d_x\varepsilon}X\brangle{2}$.
        \item $\texttt{insample}^{(x)}\brangle{1} +\gamma_q^{(x)}{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(x)}|)d_q\varepsilon}\texttt{insample}^{(x)}\brangle{2}$
        \item $\texttt{insample}^{(x)\prime}\brangle{1} +\gamma_q^{(x)\prime}{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(x)\prime}|)d_q'\varepsilon}\texttt{insample}^{(x)\prime}\brangle{2}$
        \item $Y\brangle{1}+\gamma_T^{(y)} (=)^{\#(|\mu_y\brangle{1}-\mu_y\brangle{2}+\gamma_T^{(y)}|)d_y\varepsilon}Y\brangle{2}$.
        \item $\texttt{insample}^{(y)}\brangle{1} +\gamma_q^{(y)}{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(y)}|)d_q\varepsilon}\texttt{insample}^{(y)}\brangle{2}$
        \item $\texttt{insample}^{(y)\prime}\brangle{1} +\gamma_q^{(y)\prime}{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(y)\prime}|)d_q'\varepsilon}\texttt{insample}^{(y)\prime}\brangle{2}$
    \end{itemize}

    \textbf{Case 1:}

    Create the lifting $\zeta_x\brangle{1} +\gamma_{xy}(=)^{\#|\gamma_{xy}|d_{at}\varepsilon}\zeta_y\brangle{1}$ where $\gamma_{xy} = -\min(\mu_y\brangle{1}-\mu_x\brangle{1}, 0)$. 

    Then observe that if $\mu_x\brangle{1}\geq \mu_y\brangle{1}$, \begin{align*}
        X\brangle{1}&= \mu_x\brangle{1} + \zeta_x\brangle{1}\\
        &= \mu_x\brangle{1} + \zeta_y\brangle{1}+\mu_y\brangle{1}-\mu-x\brangle{1}\\
        &=Y\brangle{1}
    \end{align*}

    Otherwise, if $\mu_x\brangle{1}<\mu_y\brangle{1}$, then \begin{align*}
        X\brangle{1}&= \mu_x\brangle{1} + \zeta_x\brangle{1}\\
        &\leq \mu_y\brangle{1}+\zeta_y\brangle{1}\\
        &=Y\brangle{1}
    \end{align*}
    so $X\brangle{1}\leq Y\brangle{1}$.

    Further, create the lifting $z^{(x)}\brangle{1}(=)^{\#0}z^{(y)}\brangle{1}$. Note that then $\texttt{insample}^{(x)}\brangle{1}=\texttt{in}_i\brangle{1} + z_i^{(x)}\brangle{1} =\texttt{in}_i\brangle{1} + z_i^{(y)}\brangle{1}=\texttt{insample}^{(y)}\brangle{1}$.

    Then because $x\brangle{1} \leq y\brangle{1}$, $\texttt{insample}^{(x)}\brangle{1}<x\brangle{1}\land\texttt{insample}^{(y)}\brangle{1}\geq y\brangle{1}$ must be false. Thus, $\texttt{insample}^{(x)}\brangle{1}<x\brangle{1}\land\texttt{insample}^{(y)}\brangle{1}\geq y\brangle{1}\implies \texttt{insample}^{(x)}<x\brangle{2}\land\texttt{insample}^{(y)}\geq y\brangle{2}$.

    This suffices to show that if the transition is taken in run $\brangle{1}$, then it is also taken in run $\brangle{2}$. Thus, if any of \begin{itemize}
        \item $\sigma \in \Gamma$
        \item $\sigma = \texttt{insample}^{(x)}$ and $\gamma_q^{(x)}=0$ 
        \item $\sigma = \texttt{insample}^{(x)\prime}$ and $\gamma_q^{(x)\prime}=0$ 
        \item $\sigma = \texttt{insample}^{(y)}$ and $\gamma_q^{(y)}=0$
        \item $\sigma = \texttt{insample}^{(y)\prime}$ and $\gamma_q^{(y)\prime}=0$
    \end{itemize}
    are true, then the lifting holds as desired. 

    \textbf{Case 3:}
    
    Create the lifting $\zeta_x\brangle{1} + \gamma_{xy} (=)^{\#|\gamma_{xy}|d_{at}\varepsilon} \zeta_y\brangle{1}$ where $\gamma_{xy} = -\max(0, \mu_y\brangle{1}+ \gamma_T^{(y)}-\mu_x\brangle{1}-\gamma_T^{(x)})$

    Then if $\mu_x\brangle{1}+\gamma_T^{(x)}\leq \mu_y\brangle{1}+\gamma_T^{(y)}$, \begin{align*}
        X\brangle{2} &= X\brangle{1} + \gamma_T^{(x)}\\
        &=\mu_x\brangle{1} + \zeta_x\brangle{1} + \gamma_T^{(x)}\\
        &=\mu_x\brangle{1} +\zeta_y\brangle{1} + \mu_y\brangle{1}+ \gamma_T^{(y)}-\mu_x\brangle{1}-\gamma_T^{(x)} +\gamma_T^{(x)}\\
        &=Y\brangle{1} + \gamma_T^{(y)}\\
        &= Y\brangle{2}
    \end{align*}

    Otherwise, if $\mu_x\brangle{1}+\gamma_T^{(x)}> \mu_y\brangle{1}+\gamma_T^{(y)}$, then \begin{align*}
        X\brangle{2} &= X\brangle{1} + \gamma_T^{(x)}\\
        &=\mu_x\brangle{1} + \zeta_x\brangle{1} + \gamma_T^{(x)}\\
        &\geq \mu_y\brangle{1} +\gamma_T^{(y)}+\zeta_y\brangle{1}\\
        &=Y\brangle{1} + \gamma_T^{(y)}\\
        &= Y\brangle{2}
    \end{align*}

    Thus, $X\brangle{2}\geq Y\brangle{2}$.

    Further, create the lifting $z^{(x)}\brangle{2}(=)^{\#0}z^{(y)}\brangle{2}$. Note that then $\texttt{insample}^{(x)}\brangle{2}=\texttt{in}_i\brangle{2} + z_i^{(x)}\brangle{2} =\texttt{in}_i\brangle{2} + z_i^{(y)}\brangle{2}=\texttt{insample}^{(y)}\brangle{2}$.

    Then because $X\brangle{2} \geq Y\brangle{2}$, $\texttt{insample}^{(x)}\brangle{2}<x\brangle{2}\lor \texttt{insample}^{(y)}\brangle{2}\geq y\brangle{2}$ must be true. Thus, $\texttt{insample}^{(x)}\brangle{1}<x\brangle{1}\lor\texttt{insample}^{(y)}\brangle{1}\geq y\brangle{1}\implies \texttt{insample}^{(x)}<x\brangle{2}\lor\texttt{insample}^{(y)}\geq y\brangle{2}$.

    As before, if any of \begin{itemize}
        \item $\sigma \in \Gamma$
        \item $\sigma = \texttt{insample}^{(x)}$ and $\gamma_q^{(x)}=0$ 
        \item $\sigma = \texttt{insample}^{(x)\prime}$ and $\gamma_q^{(x)\prime}=0$ 
        \item $\sigma = \texttt{insample}^{(y)}$ and $\gamma_q^{(y)}=0$
        \item $\sigma = \texttt{insample}^{(y)\prime}$ and $\gamma_q^{(y)\prime}=0$
    \end{itemize}
    are true, then the lifting holds as desired. 

\end{proof}

In essence, this allows us to construct liftings for certain transitions ``for free'' in a manner compatible with existing liftings. In particular, this construction applies to transitions whose guards intuitively correspond to checking if an input is within either the empty set or the entire real line. 

\begin{defn}
    Let $\Sigma_T$ be a valid 2v-transition alphabet. A 2v-path over $\Sigma_T$ is a sequence of transitions $\rho=t_0\cdot t_1\cdot \ldots \cdot t_{n-1}$ such that for all $i$ there exists a state $q_i\in Q$ such that $t_i = (q_i, q_{i+1}, c_i, \sigma_i, \tau_i)$. A 2v-path is \textbf{complete} if it is in the form $t_{init}^{(x)}t_{init}^{(y)}\cdot \rho$ for some $\rho\in \Sigma_T^*$.
\end{defn}

The semantics of a 2v-path are again defined exactly analogously to the single variable case; we denote the probability of a path $\rho$``succeeding'' as $\PP[\texttt{x}, \texttt{y}, \rho, \texttt{in}, \sigma]$ for initial values $\texttt{x}, \texttt{y}\in \RR$, input sequence $\texttt{in}$ and output sequence $\sigma$. 


Paths:
{\color{red} note: do we need to require that you can't derive contradictory inequalities???}

We allow couplings between different assignment transitions: from an $x$ assignment to a $y$ assignment. 

\begin{lemma}
    Let $\rho = q_0\to \ldots \to q_n$ be a complete path of length $n$. 
    Let $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ be arbitrary adjacent valid input sequences of length $n$. Additionally, fix some potential output $\sigma$ of $\rho$ of length $n$ and let $\sigma\brangle{1}$, $\sigma\brangle{2}$ be random variables representing possible outputs of $\rho$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. Additionally, for all $q_i$, let $P(q_i) = (d_i, d_i')$.

    Then $\forall \varepsilon>0$ and for all $\{\gamma_i, \gamma_i'\}_{i=0}^{n-1}$ that, for all $i$, satisfy the following constraints:\begin{enumerate}
        \item If $c_i(x) = \lguard[\texttt{x}]$, then at least one of the following is true: \begin{itemize}
            \item $\gamma_i^{(x)}\leq \gamma^{(x)}_{at_x(i)}$
            \item $c_i = \lguard[\texttt{x}]\lor\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_y(i)}\brangle{1}-\texttt{in}_{at_x(i)}\brangle{1}, 0)$
            \item $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_y(i)}\brangle{1}+ \gamma_{at_y(i)}^{(y)}-\texttt{in}_{at_x(i)}\brangle{1}-\gamma_{at_x(i)}^{(x)})$
        \end{itemize}
        \item If $c_i(x) = \gguard[\texttt{x}]$, then at least one of the following is true: \begin{itemize}
            \item $\gamma_i^{(x)}\geq \gamma^{(x)}_{at_x(i)}$
            \item $c_i = \gguard[\texttt{x}]\lor\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_x(i)}\brangle{1}-\texttt{in}_{at_y(i)}\brangle{1}, 0)$
            \item $c_i = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$
        \end{itemize}
        \item If $c_i(y) = \lguard[\texttt{y}]$, then at least one of the following is true: \begin{itemize}
            \item $\gamma_i^{(y)}\leq \gamma^{(y)}_{at_y(i)}$
            \item $c_i = \gguard[\texttt{x}]\lor\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_x(i)}\brangle{1}-\texttt{in}_{at_y(i)}\brangle{1}, 0)$
            \item $c_i = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$
        \end{itemize}
        \item If $c_i(y) = \gguard[\texttt{y}]$, then at least one of the following is true: \begin{itemize}
            \item $\gamma_i^{(x)}\geq \gamma^{(x)}_{at_x(i)}$
            \item $c_i = \lguard[\texttt{x}]\lor\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_y(i)}\brangle{1}-\texttt{in}_{at_x(i)}\brangle{1}, 0)$
            \item $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_y(i)}\brangle{1}+ \gamma_{at_y(i)}^{(y)}-\texttt{in}_{at_x(i)}\brangle{1}-\gamma_{at_x(i)}^{(x)})$
        \end{itemize}
        \item If $\sigma_i = \texttt{insample}^{(x)}$, then $\gamma_i^{(x)}=0$
        \item If $\sigma_i = \texttt{insample}^{(x)\prime}$, then $\gamma_i^{(x)\prime}=0$
        \item If $\sigma_i = \texttt{insample}^{(y)}$, then $\gamma_i^{(y)}=0$
        \item If $\sigma_i = \texttt{insample}^{(y)\prime}$, then $\gamma_i^{(y)\prime}=0$
    \end{enumerate}
      the lifting $\sigma\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}\sigma\brangle{2}$ is valid for $d = \sum_{i=0}^{n-1}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i' + \sum_{i_x, i_y}|\gamma_{(i_x, i_y)}|d_{at}$, and therefore $t$ is $d\varepsilon$-differentially private. 
\end{lemma}
\begin{proof}
    Follows from lemma \ref{mvIndTransitionCoupling} exactly as lemma \ref{multTransitionsCouplingProof} follows from lemma \ref{indTransitionCoupling}.
\end{proof}

This leads to a natural definition of two variable coupling strategies for paths:

\begin{defn}[Two Variable Coupling Strategies]
    
\end{defn}

\begin{defn}[Two Variable Looping Branches]
    A 2v-looping branch is simply a looping branch over a valid 2v-transition alphabet $\Sigma_T$.
\end{defn}

\begin{defn}
    Let $L$ be a 2v-looping branch over a valid transition alphabet $\Sigma_T$. If, for a candidate coupling strategy $C_L = (\gamma, \gamma', \gamma_{(i, j)})$ for $L$, the following constraints are satisfied for all possible inputs $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$ and all $i$: \begin{enumerate}
        \item If $c_i(x) = \lguard[\texttt{x}]$, at least one of the following is true:\begin{enumerate}
            \item $\gamma_i\leq\gamma_{at(i)}$
            \item $c_i = \lguard[\texttt{x}]\lor\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_y(i)}\brangle{1}-\texttt{in}_{at_x(i)}\brangle{1}, 0)$ 
            \item $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_y(i)}\brangle{1}+ \gamma_{at_y(i)}^{(y)}-\texttt{in}_{at_x(i)}\brangle{1}-\gamma_{at_x(i)}^{(x)})$ 
        \end{enumerate}
        \item If $c_i(x) = \gguard[\texttt{x}]$, then at least one of the following is true: \begin{enumerate}
            \item $\gamma_i^{(x)}\geq \gamma^{(x)}_{at_x(i)}$
            \item $c_i = \gguard[\texttt{x}]\lor\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_x(i)}\brangle{1}-\texttt{in}_{at_y(i)}\brangle{1}, 0)$ 
            \item $c_i = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$ 
        \end{enumerate}
        \item If $c_i(y) = \lguard[\texttt{y}]$, then at least one of the following is true: \begin{enumerate}
            \item $\gamma_i^{(y)}\leq \gamma^{(y)}_{at_y(i)}$
            \item $c_i = \gguard[\texttt{x}]\lor\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_x(i)}\brangle{1}-\texttt{in}_{at_y(i)}\brangle{1}, 0)$
            \item $c_i = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$
        \end{enumerate}
        \item If $c_i(y) = \gguard[\texttt{y}]$, then at least one of the following is true: \begin{enumerate}
            \item $\gamma_i^{(x)}\geq \gamma^{(x)}_{at_x(i)}$
            \item $c_i = \lguard[\texttt{x}]\lor\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_y(i)}\brangle{1}-\texttt{in}_{at_x(i)}\brangle{1}, 0)$ and $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_x(i)}\brangle{1}$
            \item $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_y(i)}\brangle{1}+ \gamma_{at_y(i)}^{(y)}-\texttt{in}_{at_x(i)}\brangle{1}-\gamma_{at_x(i)}^{(x)})$
        \end{enumerate}
        \item If $\sigma_i = \texttt{insample}^{(x)}$, then $\gamma_i^{(x)}=0$
        \item If $\sigma_i = \texttt{insample}^{(x)\prime}$, then $\gamma_i^{(x)\prime}=0$
        \item If $\sigma_i = \texttt{insample}^{(y)}$, then $\gamma_i^{(y)}=0$
        \item If $\sigma_i = \texttt{insample}^{(y)\prime}$, then $\gamma_i^{(y)\prime}=0$
        \item If $t_i$ is in a cycle, then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $t_i$ is in a cycle, then $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $t_i$ is in a cycle, then for all $j$, $\gamma_{(i, j)} = 0$ and $\gamma_{(j, i)} = 0$
        \item If $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_y(i)}\brangle{1}-\texttt{in}_{at_x(i)}\brangle{1}, 0)$, then $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_x(i)}\brangle{1}$
        \item If $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_y(i)}\brangle{1}+ \gamma_{at_y(i)}^{(y)}-\texttt{in}_{at_x(i)}\brangle{1}-\gamma_{at_x(i)}^{(x)})$, then $\texttt{in}_{at_y(i)}\brangle{1}\leq \texttt{in}_{at_x(i)}\brangle{1}$
        \item If $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_x(i)}\brangle{1}-\texttt{in}_{at_y(i)}\brangle{1}, 0)$, then $\texttt{in}_{at_x(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$
        \item If $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$, then $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$
    \end{enumerate}
    then we say that $C$ satisfies the privacy constraint system for $L$. 
\end{defn}

\begin{lemma}
    If a coupling strategy $C$ satisfies the privacy constraint system for a 2v-looping branch $L$, then $cost(C)<\infty$ and $L$ is $cost(C)\varepsilon$-differentially private. 
\end{lemma}

\begin{proof}
    Because $C$ satisfies the privacy constraint system, we know that $C$ is a valid coupling strategy. It remains to show that $C$ has finite cost. We can separate $cost(C)$ into cost contributed from $\gamma^{(x)}$ and $\gamma^{(x)\prime}$, $\gamma^{(y)}$ and $\gamma^{(y)\prime}$, and cross-coupling cost. We will denote these costs $c_x, c_{x\prime}, c_y, c_{y\prime}$, and $c_{xy}$ such that $cost(C) = c_x + c_{x\prime}+c_y+c_{y\prime}+c_{xy}$.

    From lemma \ref{finiteCostConstraintLemma}, we know that $c_x + c_{x\prime}+c_y+c_{y\prime}$ is finite because of constraints (9) and (10). 

    Similarly, observe that by constraints (12) through (15), $|\gamma_{(i, j)}|\leq 2$ because $\gamma_{at_x(i)}^{(x)},\gamma_{at_y(i)}^{(y)}\in [-1, 1]$. Because of constraint (11), this means that the $c_{xy}\leq 2m$, where $m$ is the total number of distinct assignment transitions in $L$, which is finite. This completes the proof.
\end{proof}

\begin{lemma}
    If no coupling strategy for a 2v-looping branch $L$ satisfies the privacy constraint system, then there exists a leaking cycle, non-cancelling leaking pair, disclosing cycle, or privacy violating path in a variable in $L$.
\end{lemma}
\begin{proof}
    Suppose that we have some maximally satisfied coupling strategy $C$ for $L$. There must be some constraint that is violated by $C$. Note that if constraint (11) is violated, then there must be a leaking cycle in $L$ since we only allow cross-couplings between assignment transitions. 

    Thus, we can assume that constraint (11) is not violated. 

    By lemma \ref{ProgramCounterexampleLemma}, there must then be either a leaking cycle, leaking pair, disclosing cycle, or privacy violating path with respect to a single variable. 

    We will show that, if there only exist leaking pairs in $L$, then at least one leaking pair must be a non-cancelling leaking pair. 

    For the sake of contradiction, suppose that every leaking pair $\kappa, \kappa'$ in $L$ is a cancelling leaking pair. 

    By definition, this means that for every two transitions $t_i, t_j$ in $\kappa, \kappa'$, $at_x(i) = at_x(j)$ and $at_y(i) = at_y(j)$.

    Without loss of generality, we will assume that every non-$\texttt{true}$ transition in $\kappa$ must either have guard $\lguard[\texttt{x}]\land\gguard[\texttt{y}]$ or $\lguard[\texttt{x}]\lor\gguard[\texttt{y}]$. Thus, every non-$\texttt{true}$ transition in $\kappa'$ must either have guard $\gguard[\texttt{x}]\land\lguard[\texttt{y}]$ or $\gguard[\texttt{x}]\lor\lguard[\texttt{y}]$, respectively. 

    Let $t_i$ be an arbitrary non-$\texttt{true}$ transition in $\kappa$ and $t_j$ be an arbitrary non-$\texttt{true}$ transition in $\kappa'$.

    Consider the case where $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $c_j = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$; the other case is symmetric.

    Observe that at least one of $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$ or $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$ must be true. Suppose that $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$. The case where $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$ is symmetric. 

    Then we can set $\gamma_{at_x(i)} = -1$, $\gamma_{at_y(i)}=1$, and $\gamma_{(at_x(i), at_y(i))} =  -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$. 
    
    Because there do not exist disclosing cycles, leaking cycles, or privacy violating paths in either variable, this cannot violate any further constraints. Thus, $C$ is not maximal, which is our contradiction, so $L$ must contain either a leaking cycle, disclosing cycle, privacy violating path, or non-cancelling leaking pair in at least one variable.
\end{proof}

\subsubsection{Couplings for GDiPA}

\begin{defn}
    A GDiPA $A$ is an 8-tuple $(Q, \Sigma, \mathcal{C}, \Gamma, q_{init}, X, P, \delta)$ where
    \begin{itemize}
        \item $Q$ is a finite set of states partitioned into input states $Q_{in}$ and non-input states $Q_{non}$. 
        \item $\Sigma = \RR$ is the input alphabet
        \item $\mathcal{C} = \mathcal{C}^{(2)}$ is a set of guard conditions
        \item $\Gamma$ is a finite output alphabet
        \item $q_{init}\in Q$ is the initial state
        \item $X = \{\texttt{x}, \texttt{y}, \texttt{insample}^{(x)}, \texttt{insample}^{(x)}\prime, \texttt{insample}^{(y)}, \texttt{insample}^{(y)}\prime\}$ is a set of variables
        \item $P: Q\to \QQ\times \QQ^{\geq 0}\times \QQ\times  \QQ^{\geq 0}$ is a parameter function that assigns sampling parameters for the Laplace distribution for each state
        \item $\delta:(Q\times \mathcal{C})\to (Q\times (\Gamma \cup \{\texttt{insample}^{(x)}, \texttt{insample}^{(x)}\prime, \texttt{insample}^{(y)}, \texttt{insample}^{(y)}\prime\})\times \{0, 1, 2\})$ is a partial transition function. 
    \end{itemize}
    In addition, $\delta$ must satisfy some additional conditions:
    \begin{itemize}
        \item \textbf{Determinism:} For any state $q\in Q$, if $\delta(q, c)$ and $\delta(q, c')$ are defined for distinct guards $c, c'$,  then $c$ and $c'$ must be logically disjoint events.

        \item \textbf{Output Distinction:} For any state $q\in Q$, if $\delta(q, c) = (q_1, o_1, b_1)$ and $\delta(q, c') = (q_2, o_2, b_2)$, for distinct guards $c, c'$, then $o_1\neq o_2$ and at least one of $o_1\in \Gamma$ and $o_2\in \Gamma$ is true.

        \item \textbf{Initialization:} The initial state $q_0$ has only one outgoing transition of the form $\delta(q_0, \texttt{true}) = (q_1, o, 1)$ and $q_1$ has only one outgoing transition of the form $\delta(q_1, \texttt{true}) = (q, o', 2)$.

        \item \textbf{Non-input transition:} From any $q\in Q_{non}$, if $\delta(q, c)$ is defined, then $c=\texttt{true}$.
    \end{itemize}
\end{defn}


Just as with DiPAs and Programs, we can equivalently define a GDiPA as regular language that can be described as a finite union of 2-variable looping branches over a valid 2v-transition alphabet $\Sigma_T$. 


\begin{lemma}
    If there does not exist a valid and finite cost coupling strategy for every looping branch of $A$, then there must exist either a leaking cycle, disclosing cycle, or privacy violating path in a single variable or a non-cancelling leaking pair. 
\end{lemma}

\begin{lemma}
    If there exists a leaking cycle, disclosing cycle, or privacy violating path in a single variable or a non-cancelling leaking pair in a single variable in a GDiPA $A$, then $A$ is not $dvarepsilon$-differentially private for any $d>0$. 
\end{lemma}

\begin{thm}
    A GDiPA $A$ is $d\varepsilon$-differentially private for some $d>0$ if and only if there exists a valid and finite cost coupling strategy for every looping branch of $A$. 
\end{thm}

\subsection{Beyond Two Variables}

- 

\section{Conclusion}
We have shown how to use coupling techniques to prove privacy for a class of SVT-like programs first defined in \cite{chadhaLinearTimeDecidability2021} and discovered that couplings additionally characterize this class. We additionally showed that this can be done tractably, and that couplings can help provide lower bounds on privacy costs of these algorithms. 

Future work most naturally would focus on extensions of the program model. For the model, potential areas include removing the requirement for output to be deterministic of a path through the automaton, which would allow for algorithms such as Report Noisy Max to be captured by the model. Similarly, the alphabet of the automaton could be expanded to incorporate more than comparisons between two real numbers. 
Such extensions would naturally also require extensions of the class of couplings we define here, which are limited to ``shifts''. 

Additionally, we believe that couplings should completely characterize GDiPAs as well as DiPAs; proving this requires showing that a lack of well-formedness in any single variable generates a counterexample to privacy. 
In this vein, we would like to explore using couplings to \textit{disprove} privacy; the fact that shift couplings completely characterize DiPAs hints at the possibility of ``anti-couplings'' to generate counterexamples.

\section{Related Work}
The DiPA model and counterexamples to privacy are drawn from \cite{chadhaLinearTimeDecidability2021}. Approximate liftings were developed in \cite{bartheKopfOlmedo2012ProbabilisticRelationalReasoningforDifferentialPriv,BartheOlmedo2013} and applied to algorithms such as SVT in \cite{BartheEtAl2016}.
A full exploration of approximate liftings can be found in \cite{HsuThesis2017}. \cite{AlbarghouthiHsu2018} uses couplings; and in particular the ``shift'' couplings family we use, to create a heuristiccally successful program for proving the correctness of possible differentially private algorithms. 


{\color{red} need to reformat some citations at some point}
\bibliography{./dipalibrary}


\section{Appendix}

\subsection{Proofs for section 4}

{\color{red} move these two lemmas away from this section (appendix or closer to usage in main theorem)}

\begin{lemma}\label{cycleGammaConstraints}
    If a coupling strategy $C=(\mathbf{\gamma}, \mathbf{\gamma}')$ for a lasso $L_\rho$ is valid and has finite cost, then the following must hold for all $i$:
    \begin{enumerate}
        \item If $t_i$ is in a cycle and $c_i = \lguard[\texttt{x}]$, then $\gamma_i = -\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}$ and $\gamma_{at(i)} = 1$.
        \item If $t_i$ is in a cycle and $c_i = \gguard[\texttt{x}]$, then $\gamma_i = -\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}$ and $\gamma_{at(i)} = -1$.
    \end{enumerate}
\end{lemma}
\begin{proof}
    We will show (1). (2) follows symmetrically.

    Consider some $t_i$ in a cycle where $c_i = \lguard[\texttt{x}]$. Because $C$ is has finite cost, we know from lemma \ref{finiteCostConstraintLemma} that $\gamma_i = -\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}$ for all  $\texttt{in}_i\brangle{1}\sim\texttt{in}_i\brangle{2}$. In particular, when $-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}=1$, then $\gamma_i=1$. 
    
    Further, because $\gamma_{at(i)}$ must be greater than $\gamma_i$ for all $\texttt{in}_i\brangle{1}\sim\texttt{in}_i\brangle{2}$ for $C$ to be valid, we must have that $\gamma_{at(i)}=1$.
\end{proof}
\begin{lemma}
    If a valid finite cost coupling strategy $C = (\gamma, \gamma')$ exists for a lasso $L_\rho$, then there exists a valid finite cost coupling strategy $C^*= (\gamma^*, \gamma^{*\prime})$ such that for all $i\in AT(L_\rho)$, $\gamma_i^*\in \{-1, 0, 1\}$. 
\end{lemma}
\begin{proof}
    Note that because $C$ is valid and has finite cost, there cannot be any assignment transitions in the cycle in $\rho$. 

    Further, there cannot be both a transition with guard $\lguard[\texttt{x}]$ and guard $\gguard[\texttt{x}]$ in the cycle in $\rho$ by the previous lemma. 

    Let $t_{at(k)}$ be the final assignment transition before the cycle in $\rho$. 

    By the previous lemma, $\gamma_{at(k)} \in \{-1, 1\}$ already. 

    - every previous assignment transition can either be changed without caring about $\gamma_{at(k)}$ or 

\end{proof}


\begin{proof}[Proof of proposition \ref{ClassCouplingStrategiesAreEnoughProp}]
    
    {\color{red} Make sure to put this proof after the DiPA counterexample proof}

    Because $\sup_{\rho\in [\rho]}cost(C_\rho)< \infty$, we can assume that there are no leaking cycles, disclosing cycles, leaking pairs, or privacy violating paths in $[\rho]$.


    For a given path $\rho$ and a coupling strategy $C_\rho$, recall that we effectively assign each transition $t_i$ in $\rho$ the cost $\max_{\Delta \in \{-1, 0, 1\}}|\Delta - \gamma_i(\Delta)| + |\Delta' - \gamma'_i(\Delta)|$. For convenience, we will shorthand this quantity as $\delta(\rho, t_i) + \delta'(\rho, t_i)$.


    For all $n\in \NN$, let $\rho_n$ be the path in $[\rho]$ with every cycle in $\rho_n$ repeated $n$ times. 

   Let $cycle([\rho])$ be the set of all transitions in $[\rho]$ that are contained within a cycle in $[\rho]$. Observe that for all $t\in cycle([\rho])$, \[
        \lim_{n\to\infty}\inf_{t_i\in\rho_n: t_i=t} \delta(\rho_n, t_i) = 0
    \]
    Informally, for every cycle transition $t$ in $[\rho]$, if the cycle it is contained in is iterated enough times, there must be some iteration $t_i$ of $t$ that is assigned costs approaching 0. 

    This can be shown by considering a transition $t$ in a cycle in $[\rho]$ whose minimum coupling cost is non-zero (i.e. $\inf_{\rho\in[\rho]; t_i=t} \delta(t_i) > 0$). Then for any finite $d>0$, there exists an path $\rho_n$ where $n>\lceil\frac{d}{\inf\delta(t_i)}\rceil+1$. Then $cost(C_{\rho^*})>d$, which implies that $\sup_{\rho\in [\rho]}cost(C_\rho) = \infty$, so the observation must hold. 

    Let $t_i$ be a transition in a cycle in $[\rho]$ and let $\mathcal{C}_i$ be the cycle containing $t_i$. 

    Then in particular, if $\mathcal{C}_i$ contains a transition with guard $\lguard[\texttt{x}]$, then for all $\psi>0$, there exists $n\in \NN$ such that for $\rho_n\in [\rho]$, $\gamma_{at(i)}> 1-\psi$ and if $\mathcal{C}_i$ contains a transition with guard $\lguard[\texttt{x}]$, then for all $\psi>0$, $\gamma_{at(i)}> -1+\psi$. 
    Informally, assignment transitions before an \lcycle\ have shifts that approach 1 and assignment transitions before a \gcycle\ have shifts that approach -1 in $\rho_n$ as $n\to\infty$. 

    Because we know that all coupling strategies $C_{\rho}$ are valid, this may also imply that other assignment transitions also have shifts that approach 1 or -1. 

    Further, if the shifts for an assignment transition $t_i$ approach 1, then the shifts for a transition $t_j$ such that $at(j) = i$ and $c_j = \gguard[\texttt{x}]$ must also approach 1; symmetrically, if the shifts for an assignment transition $t_i$ approach -1, then the shifts for a transition $t_j$ such that $at(j) = i$ and $c_j = \lguard[\texttt{x}]$ must also approach -1. 

    Let $T_1$ and $T_{-1}$ be the sets of assignment transitions in $[\rho]$ that approach 1 and -1, respectively. 

    Note that every other transition in $[\rho]$ is a non-cycle transition. Consider such a transition $t$ in $[\rho]$. Then for every path $\rho\in [\rho]$ and its corresponding coupling strategy $C_\rho$, there is exactly one shift assignment for $t$ because $t$ is not in a cycle. 

    Let the class coupling strategy $C' = (\gamma, \gamma')$ be partially defined as follows: \begin{align*}
        \gamma(t_i)(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= \begin{cases}
            1 & t_i \in T_1\\
            -1 & t_i \in T_{-1}\\
            \texttt{in}\brangle{1}-\texttt{in}\brangle{2} & c_i = \lguard[\texttt{x}]\land t_{at(i)}\in T_1\\
            \texttt{in}\brangle{1}-\texttt{in}\brangle{2} & c_i = \gguard[\texttt{x}]\land t_{at(i)}\in T_{-1}\\
            1 & c_i = \gguard[\texttt{x}]\land t_{at(i)}\in T_1\\
            -1 & c_i = \lguard[\texttt{x}]\land t_{at(i)}\in T_{-1}
        \end{cases}\\
        \gamma'(t_i)(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &=\begin{cases}
            0 & t_i\text{ outputs }\texttt{insample}'\\
            \texttt{in}\brangle{1}-\texttt{in}\brangle{2} & \text{otherwise}
        \end{cases}
    \end{align*}

    Let $T_{un}$ be the set of transitions in $[\rho]$ that are not assigned by $\gamma$ so far. Note that all transitions in $T_{un}$ are not in cycles. 

    Let $C^* = (\gamma^*, \gamma^{*\prime})$ be the minimal-cost valid class coupling strategy such that for all $t\notin T_{un}$, $\gamma^*(t) = \gamma(t)$. 

    In other words, $cost(C^*) = \inf_{\text{all such possible valid class coupling strategies } C} cost(C)$. Note that $C^*$ is valid. 

    We additionally claim that $cost(C^*)\leq \sup_{\rho\in [\rho]}cost(C_\rho)$. The cost of $C^*$ can be separated into costs attributed to $\gamma^{*\prime}$, costs attributed to all transitions not in $T_{un}$ by $\gamma^*$, and costs attributed to all transitions in $T_{un}$ by $\gamma^*$. 
    
    First, note that the coupling cost attributed to $\gamma^{*\prime}$ in $C^*$ must be at most the maximimum coupling cost attributed to $\gamma'$ over all path-specific coupling strategies. From before, we additionally know that the cost attributed to all transitions $t\notin T_{un}$ by $\gamma^*$ is at most the supremum of the costs attributed to $t$ over all paths in $[\rho]$, since we take the limit of all such shifts for $\rho_n$ as $n\to\infty$.

    Finally, since all path-specific coupling strategies are valid, taking the remaining transition shifts to minimize the overall cost while retaining a valid coupling strategy sufficies. 

    {\color{red} If i have time, come back to this argument - expressed poorly right now}
\end{proof}

\begin{proof}[Proof of lemma \ref{ProgramCounterexampleLemma}]
    Let $[\rho]$ be a path class in $P$ that does not have a coupling strategy that satisfies the privacy constraint system.

    Consider a ``maximially'' satisfied coupling strategy $C=(\mathbf{\gamma}, \mathbf{\gamma}')$ for $[\rho]$; i.e. there is no other coupling strategy $C'$ for $[\rho]$ such that $C'$ satisfies more constraints than $C$. By lemma [tbd], we are allowed to only consider coupling strategies $C=(\gamma, \gamma')$ such that, for all $i\in AT(A)$, $\gamma_i \in \{-1, 0, 1\}$. 

    Fix some path class $\rho$ in $A$ such that at least one constraint is not satisfied by $C$ as applied to $\rho$.

    By assumption, at least one constraint is unsatisfied by $C$. We will show that in every case, $A$ must contain at least one of a leaking cycle, leaking pair, disclosing cycle, or privacy violating path. By theorem \ref{DiPACounterexamplesThm}, this is sufficient to show that $A$ is not $d\varepsilon$-differentially private for any $d>0$.

    {\color{red} If I have time (low priority): rewrite this using a few helper lemmas to compress (e.g. $\gamma_{at(i)} =1\implies \lcycle$)}

    \textbf{Case 1: (1) is unsatisfied for $\gamma_i$}
    
    In this case, $c_i = \lguard[\texttt{x}]$ and $\gamma_i > \gamma_{at(i)}$. Note that $\gamma_{at(i)} \neq 1$. 

    We can assume that for all assignment transitions $t_{at(k)}$ in $\rho$ that $t_{at(k)}$ is not in a cycle, since otherwise there would be a leaking cycle in $A$. 

    \textbf{Case 1.1: $t_i$ is in a cycle}

    In this case, we can suppose that $t_i$ is not an assignment transition and $t_i$ does not output $\texttt{insample}$ or $\texttt{insample}'$, since otherwise either a leaking cycle or a disclosing cycle would clearly exist in $A$. We can thus additionally assume that constraint (5) is satisfied for $\gamma_i$. 
    
    Noe that the cycle containing $t_i$ is also an $\texttt{L}$-cycle by definition.

    Then attempting to resolve (1) for $\gamma_i$ by setting $\gamma_{at(i)} = 1$ must violate another constraint. In particular, either constraint (1) or (3) for $\gamma_{at(i)}$ or constraint (2) for some $\gamma_j$ such that $at(j) = at(i)$ must be newly violated. Note that constraint (5) for $\gamma_{at(i)}$ cannot be violated since we assumed that $t_{at(i)}$ is not in a cycle. 

    \textbf{Case 1.1.1: setting $\gamma_{at(i)} = 1$ violates constraint (1) for $\gamma_{at(i)}$}

    Let $t_{at(k)}$ be the earliest assignment transition before $t_{at(i)}$ such that, for all $at(k)\leq at(l)< at(i)$, $\gamma_{at(l)} <1$ and $c_{at(l)} = \lguard[\texttt{x}]$. Then there must be \textit{some} $\gamma_{at(l)}$ such that setting $\gamma_{at(l)} = 1$ would violate constraint (2) for some $\gamma_{l'}$ such that $at(l') = at(l)$. 

    Observe that $c_{l'} = \gguard[\texttt{x}]$ and there is an $\texttt{AL}$-path from $t_{l'}$ to $t_i$. 

    Then setting $\gamma_{l'}= 1$ must violate either constraint (3) or constraint (5) for $\gamma_{l'}$. If constraint (3) is violated, then $\gamma_{l'}$ is a transition with guard $\gguard[\texttt{x}]$ that outputs $\texttt{insample}$, so there is a privacy violating path from $t_{l'}$ to $t_i$. Otherwise if constraint (5) is violated, then $\gamma_{l'}$ is in a \gcycle, so there is a leaking pair composed of the cycles containing $t_{l'}$ and $t_i$, repectively. 

    \textbf{Case 1.1.2: Setting $\gamma_{at(i)}=1$ would violate (3) for $\gamma_{at(i)}$}

    Then $\gamma_{at(i)}$ is an assignment transition that outputs $\texttt{insample}$. Further, the path from $t_{at(i)}$ to $t_i$ is an $\texttt{AL}$-path, since there are no transitions on it. Thus, there is a privacy violating path from $t_i{at(i)}$ to $t_i$

    \textbf{Case 1.1.3: Setting $\gamma_{at(i)}=1$ would violate (2) for some $\gamma_j$ such that $at(j)= at(i)$}

    Note that, if $i<j$, the path from $t_i$ to $t_j$ (or vice versa, if $j<i$) is both an $\texttt{AL}$ and $\texttt{AG}$-path.

    Setting $\gamma_{j}= 1$ must violate either constraint (3) or constraint (5) for $\gamma_{j}$. 
    
    If constraint (3) is violated, then $\gamma_{j}$ is a transition with guard $\gguard[\texttt{x}]$ that outputs $\texttt{insample}$. Thus if $i<j$, there is a privacy violating path from $t_i$ to $t_j$ and if $j<i$, there is a privacy violating path from $t_j$ to $t_i$. 
    
    Otherwise if constraint (5) is violated, then $\gamma_{j}$ is in a \gcycle, so there is a leaking pair composed of the cycle containing $t_j$ and the cycle containing $t_i$ if $j<i$ or vice versa if $j>i$. 

    \textbf{Case 1.2: $t_i$ is not in a cycle}

    Note that $t_i$ must either be an assignment transition or output $\texttt{insample}$ or both, since otherwise, setting $\gamma_i = \gamma_{at(i)}$ would resolve constraint (1) for $\gamma_i$ without violating any other constraint. 

    \textbf{Case 1.2.1: $t_i$ outputs $\texttt{insample}$ and $t_i$ is an assignment transition}

    In this case, attempting to resolve constraint (1) without violating constraint (3) for $\gamma_i$ by setting $\gamma_i = \gamma_{at(i)} = 0$ must violate some other constraint. In particular, setting $\gamma_{at(i)} = 0$ can newly violate constraint (1) for $\gamma_{at(i)}$ or constraint (2) for some $\gamma_j$ such that $at(j) = at(i)$; note that setting $\gamma_{at(i)}=0$ cannot \textit{newly} violate constraint (1) for some $\gamma_j$ such that $at(j) = at(i)$. 
    Alternatively, setting $\gamma_i = 0$ could potentially newly violate either constraint (1) or constraint (2) for some $\gamma_j$ such that $at(j) = i$. 

    \textbf{Case 1.2.2.1: Setting $\gamma_{at(i)} =0$ violates constraint (1) for $\gamma_{at(i)}$}

    Let $t_{at(k)}$ be the earliest assignment transition before $t_{at(i)}$ such that, for all $at(k)\leq at(l)< at(i)$, $\gamma_{at(l)} = -1$ and $c_{at(l)} = \lguard[\texttt{x}]$. Then there must be \textit{some} $\gamma_{at(l)}$ such that setting $\gamma_{at(l)} = 0$ would violate constraint (2) for some $\gamma_{l'}$ such that $at(l') = at(l)$.  
    Additionally, note that setting $\gamma_{l'} = \gamma_{at(l)} = 0$ can only violate constraint (5) for $\gamma_{l'}$, since $\gamma_{l'}$ cannot be an assignment transition. 
    
    Thus, $t_{l'}$ is in a cycle, so the cycle containing $t_{l'}$ is a \gcycle. Note that the path from $t_{l'}$ to $t_i$ is an $\texttt{AL}$-path. Therefore, there is a privacy violating path from $t_{l'}$ to $t_i$.

    \textbf{Case 1.2.2.2: Setting $\gamma_{at(i)} =0$ violates constraint (2) for some $\gamma_j$ such that $at(j) = at(i)$}

    Note that $j\neq i$, meaning that $t_j$ is not an assignment transition. Then setting $\gamma_j = \gamma_{at(i)} = 0$ must violate constraint (5) for $\gamma_j$; this means that $t_j$ is in a \gcycle. 

    If $i<j$, then the path from $t_i$ to $t_j$ is an $\texttt{AL}$-path, so it is also a privacy violating path.

    Otherwise illustratef $j<i$, then the path from $t_j$ to $t_i$ is an $\texttt{AG}$ path, so it is also a privacy violating path.

    \textbf{Case 1.2.2.3: Setting $\gamma_i =0$ violates constraint (1) for some $\gamma_j$ such that $at(j) = i$}

    If $\gamma_j$ is not an assignment transition, then setting $\gamma_j = \gamma_i = 0$ must violate constraint (5) for $\gamma_j$, so $t_j$ is in an \lcycle. Then there is a privacy violating path from $t_i$ to $t_j$, since the path from $t_{i+1}$ to $t_j$ is an $\texttt{AL}$-path by virtue of not containing any assignment transitions. 

    Otherwise if $t_j$ is an assignment transition, then $\gamma_j$ must originally be set to 1. Let $t_{at(k)}$ be the latest assignment after $t_{i}$ such that, for all $i\leq at(l)< at(k)$, $\gamma_{at(l)} = 1$ and $c_{at(l)} = \lguard[\texttt{x}]$. Then there must be \textit{some} $\gamma_{at(l)}$ such that setting $\gamma_{at(l)} = 0$ would violate constraint (1) for some $\gamma_{l'}$ such that $at(l') = at(l)$.  
    Additionally, note that setting $\gamma_{l'} = \gamma_{at(l)} = 0$ can only violate constraint (5) for $\gamma_{l'}$, since $\gamma_{l'}$ cannot be an assignment transition. 

    Then $\gamma_{l'}$ must be in an \lcycle. Since the path from $t_i$ to $t_{l'}$ is an $\texttt{AL}$-path, there is a privacy violating path from $t_i$ to $t_{l'}$.

    \textbf{Case 1.2.2.4: Setting $\gamma_i =0$ violates constraint (2) for some $\gamma_j$ such that $at(j) = i$}

    This case is exactly symmetric to case 1.2.2.3.

    \textbf{Case 1.2.2: $t_i$ outputs $\texttt{insample}$ and $t_i$ is not an assignment transition}

    We can assume that $\gamma_{at(i)} = -1$ originally, since otherwise, setting $\gamma_i = 0$ would resolve constraint (1) without violating any additional ones.

    Thus attempting to resolve constraint (1) while preserving constraint (3) for $\gamma_i$ by setting $\gamma_{at(i)}=\gamma_i =0$ must violate constraint (1) for $\gamma_{at(i)}$. 
   
    Let $t_{at(k)}$ be the earliest assignment transition before $t_{at(i)}$ such that, for all $at(k)\leq at(l)< at(i)$, $\gamma_{at(l)} = -1$ and $c_{at(l)} = \lguard[\texttt{x}]$. Then there must be some $\gamma_{at(l)}$ such that setting $\gamma_{at(l)} = 0$ would violate constraint (2) for some $\gamma_{l'}$ such that $at(l') = at(l)$.  
    Additionally, note that setting $\gamma_{l'} = \gamma_{at(l)} = 0$ can only violate constraint (5) for $\gamma_{l'}$, since $\gamma_{l'}$ cannot be an assignment transition. 
    
    Thus, $t_{l'}$ is in a cycle, so the cycle containing $t_{l'}$ is a \gcycle. Note that the path from $t_{l'}$ to $t_i$ is an $\texttt{AL}$-path. Therefore, there is a privacy violating path from $t_{l'}$ to $t_i$.

    \textbf{Case 1.2.3: $t_i$ does not output $\texttt{insample}$ and $t_i$ is an assignment transition}

    In this case, attempting to resolve (1) by setting $\gamma_{at(i)} = 1$ must violate either constraint (1) or (3) for $\gamma_{at(i)}$, or constraint (2) for some $\gamma_j$ such that $at(j) = at(i)$. 

    Additionally, note that $\gamma_{at(i)} \in \{0, -1\}$. 

    \textbf{Case 1.2.3.1: $\gamma_{at(i)} =0$}

    Since originally, $\gamma_i > \gamma_{at(i)} \implies \gamma_i = 1$, we know that setting $\gamma_i = \gamma_{at(i)} = 0$ must violate constraint (1) for some $\gamma_j$ such that $at(j) = i$. If $t_{j}$ is not an assignment transition, then setting $\gamma_{j} = 0$ can only violate constraint (5) for $\gamma_{j}$, meaning that $t_j$ is in an \lcycle.

    Otherwise, if $t_j$ is an assignment transition, let $t_{at(k)}$ be the latest assignment transition after $t_{i}$ such that for all $j\leq at(l)< at(k)$, $\gamma_{at(l)} =1$ and $c_{at(k)} = \lguard[\texttt{x}]$. Then there must exist some $at(l), j\leq at(l)< at(k)$ such that setting $\gamma_{at(l)}=0$ would violate constraint (1) for some non-assignment $\gamma_{l'}$ where $at(l') = at(l)$. 

    Further, setting $\gamma_{l'} = 0$ must then violate constraint (5) for $\gamma_{l'}$, so $t_{l'}$ is in an \lcycle. 

    Therefore, there exists a $\texttt{AL}$-path from $t_i$ to some transition $t$ in an \lcycle. 

    \textbf{Case 1.2.3.1.1: Setting $\gamma_{at(i)} = 1$ would violate constraint (1) for $\gamma_{at(i)}$}

    Let $t_{at(j)}$ be the earliest assignment transition before $t_{at(i)}$ such that for all $at(j)\leq at(k)< at(i)$, $\gamma_{at(k)} =0$ and $c_{at(k)} = \lguard[\texttt{x}]$. Then there must exist some $at(k), at(j)\leq at(k)< at(i)$ such that setting $\gamma_{at(k)}=1$ would violate constraint (2) for some non-assignment $\gamma_l$ where $at(l) = at(k)$, so $c_l = \gguard[\texttt{x}]$

    Note that there is an $\texttt{AL}$-path from $t_l$ to $t_i$, and therefore an $\texttt{AL}$-path from $t_l$ to some transition $t_{o}$ in an \lcycle. 

    Further, setting $\gamma_l = \gamma_{at(k)} = 1$ must then violate either constraint (3) or (5) for $\gamma_l$. 

    If constraint (3) is violated, then $t_l$ outputs $\texttt{insample}$, so there is a privacy violating from $t_l$ to $t_o$.

    If constraint (5) is violated, then $t_l$ is in a \gcycle, so there is a leaking pair consisting of the cycle containing $t_l$ and the cycle containing $t_o$. 

    \textbf{Case 1.2.3.1.2: Setting $\gamma_{at(i)}=1$ would violate constraint (3) for $\gamma_{at(i)}$}

    Note that there is an $\texttt{AL}$ path from $t_{at(i)}$ to some transition $t_j$ such that $t_j$ is in an \lcycle.

    Then $t_{at(i)}$ is an assignment transition that outputs $\texttt{insample}$, so there is a privacy violating path from $t_{at(i)}$ to $t_j$. 
    
    \textbf{Case 1.2.3.1.3: Setting $\gamma_{at(i)}=1$ would violate constraint (2) for some $\gamma_j$ such that $at(j) = at(i)$}

    As before, note that there is an $\texttt{AL}$ path from $t_{j}$ to some transition $t_k$ such that $t_k$ is in an \lcycle.

    Then trying to set $\gamma_j = \gamma_{at(i)} = 1$ must violate either constraint (3) or constraint (5) for $\gamma_j$. If constraint (3) is violated, then $t_j$ outputs $\texttt{insample}$, so there is a privacy violating from $t_j$ to $t_k$. If constraint (5) is violated, then $t_j$ is in a \gcycle, so there is a leaking pair consisting of the cycle containing $t_j$ and the cycle containing $t_k$.  

    \textbf{Case 1.2.3.2: $\gamma_{at(i)} = -1$}

    Note that $\gamma_i \in \{0, 1\}$.

    First, if $\gamma_i = 0$, then setting $\gamma_i = -1$ must newly violate constraint (1) for some $\gamma_j$ where $at(j) = i$. If $t_{j}$ is not an assignment transition, then setting $\gamma_{j} = -1$ can only newly violate constraint (3) for $\gamma_{j}$, meaning that $t_j$ outputs $\texttt{insample}$.

    Otherwise, if $t_j$ is an assignment transition, let $t_{at(k)}$ be the latest assignment transition after $t_{i}$ such that for all $j\leq at(l)< at(k)$, $\gamma_{at(l)} =0$ and $c_{at(k)} = \lguard[\texttt{x}]$. Then there must exist some $at(l), j\leq at(l)< at(k)$ such that setting $\gamma_{at(l)}=-1$ would newly violate constraint (1) for some non-assignment $\gamma_{l'}$ where $at(l') = at(l)$; as before, this means that $t_{l'}$ outputs $\texttt{insample}$.  

    Otherwise, if $\gamma_i = 1$, then setting $\gamma_i = -1$ must newly violate constraint (1) for some $\gamma_j$ where $at(j) = i$. If $t_{j}$ is not an assignment transition, then setting $\gamma_{j} = -1$ can only newly violate constraint (5) for $\gamma_{j}$, meaning that $t_j$ is in an \lcycle. 

    Otherwise, if $t_j$ is an assignment transition, let $t_{at(k)}$ be the latest assignment transition after $t_{i}$ such that for all $j\leq at(l)< at(k)$, $\gamma_{at(l)} =0$ and $c_{at(k)} = \lguard[\texttt{x}]$. Then there must exist some $at(l), j\leq at(l)< at(k)$ such that setting $\gamma_{at(l)}=-1$ would newly violate constraint (1) for some non-assignment $\gamma_{l'}$ where $at(l') = at(l)$; as before, this means that $t_{l'}$ is in an \lcycle.  

    Thus, if $\gamma_i =0$, then there is $\texttt{AL}$-path from $t_i$ to some other transition that has guard $\lguard[\texttt{x}]$ and outputs $\texttt{insample}$. Otherwise, if $\gamma_i = 1$, there is an $\texttt{AL}$-path from $t_i$ to some other transition that is in an \lcycle. 

    \textbf{Case 1.2.3.2.1: Setting $\gamma_{at(i)} = \gamma_i$ would violate constraint (1) for $\gamma_{at(i)}$}

    Let $t_{at(j)}$ be the earliest assignment transition before $t_{at(i)}$ such that for all $at(j)\leq at(k)< at(i)$, $\gamma_{at(k)} =-1$ and $c_{at(k)} = \lguard[\texttt{x}]$. Then there must exist some $at(k), at(j)\leq at(k)< at(i)$ such that setting $\gamma_{at(k)}=\gamma_i$ would newly violate constraint (2) for some non-assignment $\gamma_l$ where $at(l) = at(k)$.

    First note that $c_l = \gguard[\texttt{x}]$ and there is an $\texttt{AL}$-path from $t_l$ to $t_i$. 
    
    If $\gamma_i = 0$, then setting $\gamma_l = \gamma_{at(k)} = \gamma_i = 0$ can only newly violate constraint (5) for $\gamma_l$. Thus, $\gamma_l$ is in a \gcycle. Since $\gamma_i = 0$, there exists some $t_{l'}$ such that there is an $\texttt{AL}$-path from $t_i$ to $t_{l'}$ and $t_{l'}$ has guard $\lguard[\texttt{x}]$ and outputs $\texttt{insample}$. Thus, there is an $\texttt{AL}$ path from $t_l$ to $t_{l'}$, and so there is a privacy violating path from $t_l$ to $t_{l'}$. 
    
    If $\gamma_i = 1$, then setting $\gamma_l = \gamma_{at(k)} = \gamma_i = 1$ can newly violate constraints (3) or (5) for $\gamma_l$. Further, since $\gamma_i =1$, there exists some $t_{l'}$ such that there is an $\texttt{AL}$-path from $t_i$ to $t_{l'}$ and $t_{l'}$ is in an \lcycle. Thus, there is an $\texttt{AL}$ path from $t_l$ to $t_{l'}$.
    
    If constraint (3) is newly violated, then $t_l$ is a transition with guard $\gguard[\texttt{x}]$ that outputs $\texttt{insample}$. Thus, there is a privacy violating path from $t_l$ to $t_{l'}$. 

    If constraint (5) is newly violated, then $t_l$ is in a \gcycle. Thus, there is a leaking pair composed of the cycles containing $t_l$ and $t_{l'}$, respectively.

    \textbf{Case 1.2.3.2.2: Setting $\gamma_{at(i)}=\gamma_i$ would violate constraint (3) for $\gamma_{at(i)}$}

    First, $t_{at(i)}$ is an assignment transition that outputs $\texttt{insample}$. Since $\gamma_i = 1$, there exists some $t_j$ such that there is an $\texttt{AL}$-path from $t_{at(i)}$ to $t_j$ and $t_j$ is in an \lcycle. Then there is a privacy violating path from $t_{at(i)}$ to $t_j$.

    \textbf{Case 1.2.3.2.3: Setting $\gamma_{at(i)}=\gamma_i$ would violate constraint (2) for some $\gamma_j$ such that $at(j) = at(i)$}

    Observe that $t_j$ is not an assignment transition and has guard $\gguard[\texttt{x}]$. Additionally, there is an $\texttt{AL}$-path from $t_j$ to $t_i$ since there are no assignments between $t_j$ and $t_i$. 

    If $\gamma_i =0$, then setting $\gamma_j = \gamma_{at(i)} = 0$ can only newly violate constraint (5) for $\gamma_j$. Thus, $\gamma_j$ is in a \gcycle. Since $\gamma_i = 0$, there exists some $t_{k}$ such that there is an $\texttt{AL}$-path from $t_i$ to $t_{k}$. Thus, there is an $\texttt{AL}$ path from $t_j$ to $t_{k}$, and so there is a leaking pair composed of the cycles containing $t_j$ and $t_{k}$, respectively. 

    If $\gamma_i = 1$, then setting $\gamma_j = \gamma_{at(i)}=1$ can newly violate constraints (3) or (5) for $\gamma_l$. Further, since $\gamma_i =1$, there exists some $t_{k}$ such that there is an $\texttt{AL}$-path from $t_i$ to $t_{k}$ and $t_{k}$ is in an \lcycle. Thus, there is an $\texttt{AL}$ path from $t_j$ to $t_{k}$.
    
    If constraint (3) is newly violated, then $t_j$ is a transition with guard $\gguard[\texttt{x}]$ that outputs $\texttt{insample}$. Thus, there is a privacy violating path from $t_j$ to $t_{k}$. 

    If constraint (5) is newly violated, then $t_j$ is in a \gcycle. Thus, there is a leaking pair composed of the cycles containing $t_j$ and $t_{k}$, respectively.

    \textbf{Case 2: (2) is unsatisfied for $\gamma_i$}

    This case is exactly symmetric to case (1).

    \textbf{Case 3: (3) is unsatisfied for $\gamma_i$}

    First note that if $t_i$ is in a cycle, then that cycle will be a disclosing cycle because $t_i$ outputs $\texttt{insample}$. Thus, we will assume that $t_i$ is not in a cycle.

    Because $C$ is maximal, setting $\gamma_i=0$ must violate at least one of constraints (1) or (2) for $\gamma_i$ or (1) for some $\gamma_l$ such that $at(l) = i$.

    \textbf{Case 3.1: Satisfying (3) for $\gamma_i$ would violate (1) for $\gamma_i$}

    This means that $\gamma_{at(i)}<0\implies \gamma_{at(i)} = -1$. Further, $c_i = \lguard[\texttt{x}]$. Then changing $\gamma_{at(i)}=0$ can newly violate constraints (1) or (5) for $\gamma_{at(i)}$ or constraint (2) for some $\gamma_j$ such that $at(j) = at(i)$.

    If constraint (5) is newly violated, then $t_{at(i)}$ is in a cycle. In particular, the cycle must be a leaking cycle; if $t_i$ and $t_{at(i)}$ are both contained in a cycle, then it must be leaking because $c_i = \lguard[\texttt{x}]$. Otherwise, there still must be some transition in the cycle containing $t_{at(i)}$ that has a non-$\texttt{true}$ guard since otherwise a path from $t_{at(i)}$ to $t_i$ could not exist. 

    By similar reasoning, we can assume that for every assignment transition $t_{at(j)}$before $t_{at(i)}$ on a complete path to $t_i$, $t_{at(j)}$ is not in a cycle. 

    If constraint (1) is newly violated for $\gamma_{at(i)}$, then $c_{at(i)} = \lguard[\texttt{x}]$. Let $t_{at(j)}$ be the earliest assignment transition before $t_{at(i)}$ such that $\gamma_{at(l)} = -1$ and for all assignment transitions $t_{at(k)}$ between $t_{at(j)}$ and $t_{at(i)}$, $c_{at(k)} = \lguard[\texttt{x}]$ and $\gamma_{at(k)} = -1$. 
    
    Then there must exist some assignment transition $t_{at(k)}$, $at(j)\leq at(k)\leq at(i)$ between $t_{at(j)}$ and $t_{at(i)}$ such that setting $\gamma_{at(k)} = 0$ would newly violate constraint (2) for some $l$ where $at(l) = at(k)$. In particular, this must be because $t_l$ is in a cycle and setting $\gamma_l = 0$ would violate constraint (5). Thus, $t_l$ is in a $\texttt{G}$-cycle. Then there is an $\texttt{AL}$-path from $t_l$ to $t_i$, creating a privacy violating path from $t_l$ to $t_i$. 

    If changing $\gamma_{at(i)}$ from $-1$ to $0$ means that constraint (2) would be newly violated for some $\gamma_j$ such that $at(j) = at(i)$, note that $\gamma_j < 0$ and $c_j = \gguard[\texttt{x}]$. 
    
    So setting $\gamma_j = 0$ can violate either (2) for some $\gamma_l$ where $at(l) = j$ or (5) for $\gamma_j$. 

    If setting $\gamma_j = 0$ would violate constraint (2) for some $\gamma_l$ where $at(l) = j$, then let let $t_{at(m)}$ be the latest assignment transition after $t_{at(j)}$ such that $\gamma_{at(m)} = -1$ and for all assignment transitions $t_{at(k)}$ between $t_{at(j)}$ and $t_{at(m)}$, $c_{at(k)} = \gguard[\texttt{x}]$ and $\gamma_{at(k)} = -1$. 
    
    Then there must exist some assignment transition $t_{at(k)}$, $at(j)\leq at(k)\leq at(m)$ between $t_{at(j)}$ and $t_{at(m)}$ such that setting $\gamma_{at(k)} = 0$ would newly violate constraint (2) for some $l'$ where $at(l') = at(k)$. 
    In particular, this must be because $t_{l'}$ is in a cycle and setting $\gamma_l = 0$ would violate constraint (5). Thus, $t_l$ is in a $\texttt{G}$-cycle. Then there is an $\texttt{AG}$-path from $t_i$ to $t_l$, creating a privacy violating path from $t_i$ to $t_l$. 

    Otherwise, if setting $\gamma_j = 0$ would violate constraint (5) for $\gamma_j$, then $t_j$ is in a $\texttt{G}$-cycle. We can assume that $j\neq i$ because otherwise, the cycle containing $t_j$ would be a disclosing cycle. Additionally, note that there are no assignment transitions between $t_i$ and $t_j$ or vice versa, since $at(j) = at(i)$.
    Thus, if $j<i$, then there is an $\texttt{AL}$-path from $t_j$ to $t_i$, which forms a privacy violating path. Symmetrically, if $i<j$, then there is an $\texttt{AG}-$path from $t_i$ to $t_j$, which again forms a privacy violating path. 

    \textbf{Case 3.2: Satisfying (3) for $\gamma_i$ would violate (2) for $\gamma_i$}

    This case is exactly symmetric to case (3a).

    \textbf{Case 3.3: Satisfying (3) for $\gamma_i$ would violate (1) for some $\gamma_l$ where $at(l) = i$}

    Note that $t_i$ must be an assignment transition. Further, we know that $\gamma_l>0$ and $c_l = \lguard[\texttt{x}]$. 
    
    Because $C$ is maximal, setting $\gamma_l=0$ would now violate either constraint (1) for some $\gamma_{l'}$ where $at(l') = l$ or constraint (5) for $\gamma_l$. Note that because $\gamma_l>0$, constraint (2) cannot be newly violated for some $\gamma_{l'}$ where $at(l') = l$.

    If constraint (5) would be newly violated for $\gamma_l$, then $\gamma_l$ is in an $\texttt{L}$-cycle. Additionally, note that the path from $t_{i+1}$ to $t_l$ is an $\texttt{AL}$-path, so there is a privacy violating path from $t_i$ to $t_l$. 

    Otherwise, if setting $\gamma_l = 0$ would violate constraint (1) for some $\gamma_{l'}$ where $at(l')=l$, let $t_{at(j)}$ be the latest assignment transition such that $c_{at(j)} = \lguard[\texttt{x}]$ and $\gamma_{at(j)}<1$ and, for all assignment transitions $t_{at(k)}$ between $t_l$ and $t_{at(j)}$, $c_{at(k)} = \lguard[\texttt{x}]$ and $\gamma_{at(k)}<1$. 

    If $at(j) = l$, then $l'$ is not an assignment transition. Then, setting $\gamma_{l'} = 0$ could only violate constraint (5). In this case, as before, there is a privacy violating path from $t_i$ to $t_l$. 

    Otherwise, since $C$ is maximal, we cannot set $\gamma_{at(k)}=0$ for any $l<at(k)\leq at(j)$ without violating another constraint. In particular, there must be some $at(k)$ such that setting $\gamma_{at(k)} = 0$ would violate constraint (1) for some $\gamma_{k'}$ such that $at(k') = at(k)$. Note that there must be an \texttt{AL}-path from $t_i$ to $t_{k'}$. Then, as before, there must be a privacy violating path from $t_i$ to $t_{k'}$. 


    \textbf{Case 3.4: Satisfying (3) for $\gamma_i$ would violate (2) for some $\gamma_l$ where $at(l) = i$} 

    This case is exactly symmetric to case (3c).

    \textbf{Case 4: (4) is unsatisfied for $\gamma_i'$}
    
    Because $C$ is maximal, setting $\gamma_i'=0$ must violate some other constraint. In particular, this must mean that constraint (6) is now violated. However, this would imply that $t_i$ is in a cycle, and so the cycle containing $t_i$ would be a disclosing cycle.

    \textbf{Case 5: (5) is unsatisfied for $t_i$:} Because $C$ is maximal, we know that if $\gamma_i = -\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}$ then another constraint must be violated. In particular, at least one of constraints (1), (2), or (3) must be violated for $\gamma_i$. 
    
    \textbf{Case 5.1: Satisfying (5) for $t_i$ would violate (1)}

    If (1) is now violated, then either $t_i$ is an assignment transition or $c_i = \lguard[\texttt{x}]$ and $\gamma_{at(i)}<1$. If $t_i$ is an assignment transition, then the cycle containing $t_i$ has a transition with a non-$\texttt{true}$ guard ($t_i$) and an assignment transition, so it must be a leaking cycle. 

    Otherwise, if $t_i$ is not an assignment transition, $c_i = \lguard[\texttt{x}]$, and constraint (1) is violated for $\gamma_i$, we must have that $\gamma_{at(i)}<1$ due to other constraints.
    
    Consider all assignment transitions in $\rho$ before $t_i$. Note that if any such assignment transition is in a cycle, then that cycle must be a leaking cycle since either the assignment transition is in the same cycle as $t_i$ or there must be some non-$\texttt{true}$ transition in the cycle because otherwise $t_i$ is unreachable. {\color{red} make sure to add a condition to programs so that this is bad}

    So assume that all assignment transitions in $\rho$ before $t_i$ are not in a cycle. Then if $c_{at(i)} \neq \lguard[\texttt{x}]$, because $C$ is maximal, this must mean that $t_{at(i)}$ outputs $\texttt{insample}$. Note that the path from $t_{at(i)+1}$ to $t_i$ is an $\texttt{AL}$-path (since there are no assignment transitions on it) and $t_i$ is in an $\texttt{L}$-cycle since $t_i$ is in a cycle and $c_i = \lguard[\texttt{x}]$. 
    Then the path from $t_{at(i)}$ (an assignment transition that outputs $\texttt{insample}$) to $t_i$ is a privacy violating path. 

    If $c_{at(i)} = \lguard[\texttt{x}]$, then let $c_{at(j)}$ be the earliest assignment transition such that $c_{at(j)} = \lguard[\texttt{x}]$ and $\gamma_{at(j)} < 1$ and, for all assignment transitions $t_{at(k)}$ between $t_{at(j)}$ and $t_i$, $c_{at(k)} = \lguard[\texttt{x}]$ and $\gamma_{at(k)} < 1$. Note that such an $t_{at(j)}$ must exist. 

    If $t_{at(j)} = t_{at(i)}$, then setting $\gamma_{at(i)} =1$ must violate either constraint (2) for some other $\gamma_l$ such that $at(l)=at(i)$, or constraint (3) for $\gamma_{at(i)}$. Without loss of generality, we will assume that $l\neq i$. If constraint (3) would be violated, then as before, there exists a privacy violating path from $t_{at(j)}$ to $t_i$. 
    If constraint (2) would be violated for some $\gamma_l$ such that $at(l)=at(i)$, then either $t_l$ must output $\texttt{insample}$ or $t_l$ must be in a cycle. 
    
    Suppose that $i<l$; then that the path from $t_i$ to $t_l$ is both an $\texttt{AG}$-path and an $\texttt{AL}$-path (since there are no assignment transitions on it). Thus, if $t_l$ outputs $\texttt{insample}$, there exists a privacy violating path from $t_i$ to $t_l$ and if $t_l$ is in a cycle, then the cycle containing $t_i$ and the cycle containing $t_l$ together make up a leaking pair, since the cycle containing $t_l$ is a $\texttt{G}$-cycle by definition. 
    Symmetrically, if $l>i$, then either the path from $t_l$ to $t_i$ is a privacy violating path or the cycle containing $t_l$ and the cycle containing $t_i$ make up a leaking pair.
    
    Otherwise, note that the path from $t_{at(j)}$ to $t_i$ is an $\texttt{AL}-$path. Since $C$ is maximal, we cannot set $\gamma_{at(k)}=1$ for $\gamma_{at(j)}$ or for any of the other assignment transitions $t_{at(k)}$ between $t_{at(j)}$ and $t_i$ without violating another constraint. 
    In particular, there must be some $t_{at(k)}$ where $at(j)\leq at(k)<i$ such that setting $\gamma_{at(k)} = 1$ would mean that either constraint (2) for some $\gamma_l$ such that $at(l) = at(k)$ or constraint (3) would be violated for $\gamma_{at(k)}$. 
    If constraint (3) would be violated for $\gamma_{at(k)}$ then $t_{at(k)}$ outputs $\texttt{insample}$, so as before, there is a privacy violating path from $t_{at(k)}$ to $t_i$. Otherwise if constraint (2) would be violated for some $\gamma_l$ such that $at(l) = at(k)$, then as before, $\gamma_l$ must either output $\texttt{insample}$ or $t_l$ is in a cycle. 
    Just like before, this means that there must be either a privacy violating path from $t_l$ to $t_i$ or the cycle containing $t_l$ and the cycle containing $t_i$ together make up a leaking pair. 

    \textbf{Case 5.2: Satisfying (5) for $t_i$ would violate (2)}

    This case is exactly symmetric to case (5a).

    \textbf{Case 5.3: Satisfying (5) for $t_i$ would violate (3)}

    If (3) would be violated, then $t_i$ must output $\texttt{insample}$. Then the cycle containing $t_i$ must be a disclosing cycle. 
    
    \textbf{Case 6: (6) is unsatisfied for $t_i$:} Because $C$ is maximal, we know that if $\gamma_i' = -\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}$ then another constraint must be violated for $\gamma_i'$. In particular, constraint (4) must be violated, since no other constraint involves $\gamma_i'$. 
    Then $t_i$ is a transition in a cycle that outputs $\texttt{insample}'$, so $A$ has a disclosing cycle.
\end{proof}


\begin{defn}[Leaking Cycles \cite{chadhaLinearTimeDecidability2021}]
    A path $\rho = q_0\to\ldots \to q_n$ in a DiPA $A$ is a leaking path if there exist indices $i, j$ where $0\leq i < j < n$ such that the $i$'th transition $q_i\to q_{i+1}$ in $\rho$ is an assignment transition and the guard of the transition $q_j \to q_{j+1}$ is not $\texttt{true}$. If $\rho$ is also a cycle, then we call it a leaking cycle.
\end{defn}

\begin{defn}[\cite{chadhaLinearTimeDecidability2021}]
    A cycle $\rho$ in a DiPA $A$ is an \lcycle~if for some transition $q_i\to q_{i+1}$ in $\rho$, $\guard(q_i\to q_{i+1}) = \lguard[\texttt{x}]$. Similarly, $\rho$ is a \gcycle~if for some transition $q_i\to q_{i+1}$ in $\rho$, $\guard(q_i\to q_{i+1}) = \gguard[\texttt{x}]$.
    
    Additionally, a path $\rho$ of a DiPA $A$ is an \texttt{AL}-path (respectively, \texttt{AG}-path) if all assignment transitions in $\rho$ have guard $\lguard[\texttt{x}]$ (respectively, $\gguard[\texttt{x}]$)
\end{defn}

\begin{defn}[Leaking Pairs \cite{chadhaLinearTimeDecidability2021}]
    A pair of cycles $(C, C')$ is called a leaking pair if one of the following two conditions is satisfied.
    \begin{enumerate}
        \item $C$ is an \lcycle, $C'$ is a \gcycle~ and there is an \texttt{AG}-path from a state in $C$ to a state in $C'$.
        \item $C$ is a \gcycle, $C'$ is an \lcycle~and there is an \texttt{AL}-path from a state in $C$ to a state in $C'$.
    \end{enumerate}
\end{defn}

\begin{defn}[Disclosing Cycles \cite{chadhaLinearTimeDecidability2021}]
    A cycle $C = q_0\to \ldots \to q_n \to q_0$ of a DiPA $A$ is a disclosing cycle if there is an $i$, $0 \leq i < |C|$ such that $q_i\in Q_{in}$ and the transition $q_i\to q_{i+1}$ that outputs either \texttt{insample} or \texttt{insample}'.
\end{defn}

\begin{defn}[Privacy Violating Paths \cite{chadhaLinearTimeDecidability2021}]
    We say that a path $\rho = q_0\to\ldots \to q_n $ of a DiPA $A$ is a privacy violating path if one of the following conditions hold:
    \begin{itemize}
        \item  $tail(\rho)$ is an \texttt{AG}-path (resp., \texttt{AL}-path) such that $last(\rho)$ is in a \gcycle~(resp., \lcycle) and the 0th transition $q_0\to q_1$ is an assignment transition that outputs \texttt{insample}.
        \item $\rho$ is an \texttt{AG}-path (resp., \texttt{AL}-path) such that $q_n$ is in a \gcycle~(resp., \lcycle) and the first transition $q_0\to q_1$ has guard $\lguard[\texttt{x}]$ (resp., $\gguard[\texttt{x}]$) and outputs \texttt{insample}
        \item $\rho$ is an \texttt{AG}-path (resp., \texttt{AL}-path) such that $q_0$ is in an \lcycle~(resp., \gcycle) and the last transition $q_{n-1}\to q_n$ has guard $\gguard[\texttt{x}]$ (resp., $\lguard[\texttt{x}]$) and outputs \texttt{insample}
    \end{itemize}
\end{defn}


\end{document} 