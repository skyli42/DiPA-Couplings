
\subsection{Unbounded Programs}

We now discuss our full program model. We allow for programs with looping and branching constructs, which can be represented by a control flow graph $G = (V, E)$ in the standard manner. 

We take $V$ to be a finite set of program locations. We also associate every control flow graph $G$ with a finite alphabet of output symbols $\Gamma_G$.

We limit the class of programs we consider to those that support coupling proofs by restricting the set of possible program statements to be exactly the set of transitions $t = (c, \sigma, \tau)$ (defn. \ref{svTransDef}); we label each edge $e\in E$ with a function $T(e)$ such that $T(e) = (c_e, \sigma_e, \tau_e)$, where $\sigma_e \in \Gamma_G$. 

We impose additional constraints on the graph of any program to ensure that the graph meaningfully represents a coherent program\sky{come back to this phrasing / presentation}.

\begin{defn}[Proper Program Graphs]
    A control flow graph $G = (V, E)$ is \textbf{proper} if it satisfies the following conditions: 
    \begin{itemize}
        \item \textbf{Initialization:} $V$ contains some unique initial location $\ell_{init}\in V$ such that there is exactly one edge $e_{init}\in E$ whose source is $\ell_{init}$ and $e_{init}$ is labeled with the transition $t_{init} = (\texttt{true}, \sigma, \texttt{true})$.
        \item \textbf{Determinism:} For all locations $\ell\in V$, if there exists an edge $(\ell, \ell')$ labeled by $t'=(c, \sigma', \tau')$, then no other edge $(\ell, \ell^*)$ labeled by a transition of the form $t^* = (c, \sigma^*, \tau^*)$ exists. 
        Additionally, if there exists an edge $(\ell, \ell')\in E$ labeled by a transition of the form $(\texttt{true}, \sigma, \tau)$, then there does not exist another edge in $E$ with source at $\ell$.
        \item \textbf{Shared Noise:} For all locations $\ell\in V$ and any two edges $(\ell, \ell')$ labeled by $t'=(c', \sigma', \tau')$ and $(\ell, \ell^*)$ labeled by $t^* = (c^*, \sigma^*, \tau^*)$, $P(t') = P(t^*)$. 
        \item \textbf{Public Input:} For all locations $\ell\in V$, if there exists some edge $e = (\ell, \ell') \in E$ such that $e$ is labeled by a public transition, then every other edge from $\ell$ must also be labeled by a public transition. 
\end{itemize}
\end{defn}


An \textbf{execution} of the program represented by $G$ is any path in $G$ that starts at $\ell_{init}$; thus, an execution of a program represented by $G$ can be represented by a string $\ell_{init}t_{init}\ell_1t_1\ldots t_{n-1}\ell_n$ for locations $\ell_i\in V$ and transitions $t_i$.

For any execution of a program, we can treat it as a path program (as previously defined) by dropping all states from the execution. For a execution $r=\ell_0t_0\ell_1t_1\ldots t_{n-1}\ell_n$, we will use the function $\Psi(r) = t_0t_1\ldots t_{n-1}$ to denote this homomorphism. Observe that, because $G$ satisfies determinism, $\Psi(r)$ is invertible. 

In particular, if $t_0t_1\ldots t_{n-1} = \Psi(r)$ for some execution $r$ of $G = (V, E)$, then we abuse notation and define $\Psi^{-1}(t_i) = \ell_i\to\ell_{i+1}$ as a function that maps transitions to the edge that ``generated'' it. Similarly, we say that $\{\Psi(r): r\text{ is a execution of }G\}$ is the set of paths \textbf{generated} by a labeled graph $G$. 

This leads to a natural definition for our full program model: 
\begin{defn}[Programs]
    A program $P$ is a language over a finite alphabet of transitions generated by a proper program graph $G$.
\end{defn}

Observe that any program $P$ is specifically a regular language: if $P$ is generated by $G = (V, E)$, then the DFA $(V, \Sigma_T, \delta, \ell_{init}, V)$, where $\Sigma_T$ is the finite set of transitions that label edges in $E$ and $\delta$ is defined by the labels of $E$, accepts $P$. \sky{maybe this explanation isn't necessary}

It may seem that it is impossible to compute optimal coupling strategies for a program, since, naively, we must somehow choose a single coupling strategy for each of the possibly infinite number of paths in the program. However, we show that it is possible to partition any program into a finite collection of infinitely sized subsets such that each subset can be collectively assigned a single optimal coupling strategy, turning the problem into a decidable one.

We call these partitions \textbf{looping branches}; as mentioned, each looping branch is associated with a single coupling strategy. 

Intuitively, a looping branch is a single, straight-line path except that we allow for cycles to be inserted within the path. Looping branches are, indeed, simply examples of the more general class of ``star-dot'' or union-free regular languages and their associated 1-cycle-free-path-automata (see, for example, \cite{nagy2006union}). Indeed, the graph $G_L$, by definition, will also be the graph of a 1-cycle-free-path automaton. \azadeh{this should be a prop + citation}

In particular, it is known (see, for example, \cite{afoninMinimalUnionFreeDecompositions2009}) that every regular language can be represented by a finite union of union-free regular expressions. \sky{look into if the \textit{minimal} decomposition can be relevant at all}

\begin{cor}
    For any regular language $P$ over a finite alphabet of transitions, there exist a finite number of union-free regular languages $L_1,\ldots, L_m$ over the same alphabet such that $P = \bigcup_{i=1}^m L_i$.
\end{cor}

This motivates the formal definition of looping branches:

\begin{defn}
    A looping branch $L$ is a union-free regular language generated by a proper program graph $G_L$.
\end{defn}

% For a looping branch $L$, we use $R_L$ to denote the minimal union-free regular expression that defines $L$. \sky{double check if this ever gets used}

% Observe that the generating graphs for the constituent looping branches of a program $P$ are subgraphs of the generating graph for $P$. \sky{also not sure this is relevant}

We will associate entire looping branches with a \textbf{single} coupling strategy.

\begin{defn}[Coupling strategy for a looping branch]
    Let $L$ be a looping branch generated by the graph $G_L = (V_L, E_L)$. Then a coupling strategy $C = (\gamma, \gamma')$ for a looping branch is a function $C:E_L\times\RR \times\RR\to [-1, 1]\times[-1, 1]$ that computes shifts for each transition-labeled edge in $L$ as a function of two adjacent inputs.
\end{defn}

We will sometimes call these coupling strategies ``class'' coupling strategies when necessary to distinguish them from coupling strategies for individual paths.

Observe that a class coupling strategy implicitly defines a coupling strategy for each path in $L$.

\begin{defn}[Induced Coupling Strategy]\label{svInducedCouplingStrategy}
    Given a coupling strategy $C = (\gamma, \gamma')$ for a looping branch $L$ and a specific path $\rho\in L$, the coupling strategy for $\rho=t_0\cdots t_{n-1}$ induced by $C$ is the pair of functions $\gamma_\rho, \gamma'_\rho$ such that 
    \begin{align*}
        \gamma_\rho(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= (\gamma(\Psi^{-1}(t_0))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}), \ldots,\gamma(\Psi^{-1}(t_{n-1}))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) )\\
        \gamma'_\rho(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= (\gamma'(\Psi^{-1}(t_0))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}),\ldots,\gamma'(\Psi^{-1}(t_{n-1}))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) )
    \end{align*}
\end{defn}

Naturally, we can use class coupling strategies to construct a proof of privacy for a program.

\begin{lemma}
    If, for every looping branch $L$ in $P$, there exists a valid coupling strategy $C_L$, then $P$ is $(\max_{L\subseteq P} cost(C_L))\varepsilon$-differentially private. 
\end{lemma}


Note that, because of the introduction of cycles to our model, it is possible for a looping branch to fail to be private for \textit{any} $d>0$; in other words, every coupling strategy for a looping branch has infinite cost. We can characterize whether or not a coupling strategy has infinite cost through a single constraint:

\begin{lemma}\label{finiteCostConstraintLemma}
    For a looping branch $L$ generated by $G_L$, a valid coupling strategy $C = (\mathbf{\gamma}, \mathbf{\gamma}')$ has finite cost $cost(C)<\infty$ if and only if the following constraint applies for all $i$:
    \begin{itemize}
        \item If $t_i$ is contained within a star in $R_L$ (i.e. $\Psi^{-1}(t_i)$ is in a cycle in $G_L$), then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$ and $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$.
    \end{itemize}
\end{lemma}

Intuitively, a finite-cost coupling strategy must assign shifts such that every cycle transition has 0 privacy cost. 

In particular, we can combine this constraint that gives us \textit{finite cost} class coupling strategies with the four constraints that ensure that coupling strategies are valid. 

\begin{defn}[Privacy Constraint System]\label{privacyConstraintSystem}
    Let $L$ be a looping branch generated by the graph $G_L$. If, for a candidate coupling strategy $C_L = (\gamma, \gamma')$ for $L$, the following constraints are satisfied for all $i$: \begin{enumerate}
        \item If $c_i = \lguard[\texttt{x}]$, then $\gamma_i\leq\gamma_{at(i)}$
        \item If $c_i = \gguard[\texttt{x}]$, then $\gamma_i\geq\gamma_{at(i)}$
        \item If $\sigma_i = \texttt{insample}$, then $\gamma_i=0$
        \item If $\sigma_i = \texttt{insample}'$, then $\gamma_i'=0$
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
    \end{enumerate}
    then we say that $C$ satisfies the privacy constraint system for $L$. 
\end{defn}

It follows immediately from lemma \ref{finiteCostConstraintLemma} that if there exists a solution to the privacy constraint system for a looping branch $L$, then $L$ is private.

\begin{prop}\label{privacyFiniteCostProp}
    If there exists a coupling strategy $C$ for a looping branch $L$ that satisfies the privacy constraint system, then there exists a finite $d>0$ such that $L$ is $d\varepsilon$-differentially private. 
\end{prop}

\begin{cor}
    If, for every looping branch $L\subseteq P$ in a program $P$, there exists a coupling strategy $C_L$ that satisfies the privacy constraint system, then there exists some finite $d>0$ such that $P$ is $d\varepsilon$-differentially private.    
\end{cor}

