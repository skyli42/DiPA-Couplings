
\subsection{Unbounded Programs}\label{svProgramsSection}

We now introduce our full program model. Our model allows for looping and branching constructs, which can be represented by a control flow graph $G = (V, E)$ in the standard manner. 

We take $V$ to be a finite set of program locations. We also associate every control flow graph $G$ with a finite alphabet of output symbols $\Gamma_G$.

We limit the class of programs we consider to those that support coupling proofs by restricting the set of possible program statements to be exactly the set of transitions $t = (c, \sigma, \tau)$ (defn. \ref{svTransDef}); we label each edge $e\in E$ with a function $T(e)$ such that $T(e) = (c_e, \sigma_e, \tau_e)$, where $\sigma_e \in \Gamma_G\cup\{\texttt{insample}, \texttt{insample}'\}$. 

We impose additional constraints on the graph of any program. 

\begin{defn}[Proper Program Graphs]
    A control flow graph $G = (V, E)$ is \textbf{proper} if it satisfies the following conditions: 
    \begin{itemize}
        \item \textbf{Initialization:} $V$ contains some unique initial location $\ell_{init}\in V$ such that there is exactly one edge $e_{init}\in E$ whose source is $\ell_{init}$ and $e_{init}$ is labeled with the transition $t_{init} = (\texttt{true}, \sigma, \texttt{true})$.
        \item \textbf{Determinism:} For all locations $\ell\in V$, if there exists an edge $(\ell, \ell')$ labeled by $t'=(c, \sigma', \tau')$, then no other edge $(\ell, \ell^*)$ labeled by a transition of the form $t^* = (c, \sigma^*, \tau^*)$ exists. 
        Additionally, if there exists an edge $(\ell, \ell')\in E$ labeled by a transition of the form $(\texttt{true}, \sigma, \tau)$, then there does not exist another edge in $E$ with source at $\ell$.
        \item \textbf{Shared Noise:} For all locations $\ell\in V$ and any two edges $(\ell, \ell')$ labeled by $t'=(c', \sigma', \tau')$ and $(\ell, \ell^*)$ labeled by $t^* = (c^*, \sigma^*, \tau^*)$, $P(t') = P(t^*)$. 
        \item \textbf{Public Input:} For all locations $\ell\in V$, if there exists some edge $e = (\ell, \ell') \in E$ such that $e$ is labeled by a public transition, then every other edge from $\ell$ must also be labeled by a public transition. 
\end{itemize}
\end{defn}


An \textbf{execution} of the program represented by $G$ is any path in $G$ that starts at $\ell_{init}$; thus, an execution of a program represented by $G$ can be represented by a string $\ell_{init}t_{init}\ell_1t_1\ldots t_{n-1}\ell_n$ for locations $\ell_i\in V$ and transitions $t_i$.

For any execution of a program, we can treat it as a straight line program by dropping all states from the execution. For a execution $r=\ell_0t_0\ell_1t_1\ldots t_{n-1}\ell_n$, we will use the function $\Psi(r) = t_0t_1\ldots t_{n-1}$ to denote this homomorphism. Observe that, because $G$ satisfies determinism, $\Psi(r)$ is invertible. 

In particular, if $t_0t_1\ldots t_{n-1} = \Psi(r)$ for some execution $r$ of $G = (V, E)$, then we abuse notation and define $\Psi^{-1}(t_i) = \ell_i\to\ell_{i+1}$ as a function that maps transitions to the edge that ``generated'' it. Similarly, we say that $\{\Psi(r): r\text{ is a execution of }G\}$ is the set of SLPs \textbf{generated} by a labeled graph $G$. 

This leads to a natural definition for our full program model: 
\begin{defn}[Programs]
    A program $P$ is a language over a finite alphabet of transitions generated by a proper program graph $G$.
\end{defn}

Observe that a program $P$ must be a regular language: if $P$ is generated by $G = (V, E)$, then the DFA $(V, \Sigma_T, \delta, \ell_{init}, V)$, where $\Sigma_T$ is the finite set of transitions that label edges in $E$ and $\delta$ is defined by the labels of $E$, accepts $P$.

It may seem to be impossible to compute optimal coupling strategies for a program, since, naively, we must somehow choose a single coupling strategy for each of the possibly infinite number of SLPs in the program. However, we show that it is possible to partition any program into a finite collection of infinitely sized subsets such that each subset can be collectively assigned a single optimal coupling strategy, turning the problem into a tractable one.

We call these partitions \textbf{periodic programs}.
Intuitively, a periodic program is a single straight line program except that we allow for cycles to be inserted within the SLP. Periodic programs are, indeed, examples of the more general class of ``star-dot'' or union-free regular languages and their associated 1-cycle-free-path-automata (see, for example, \cite{nagyUnionfreeRegularLanguages2006}).

Importantly, it is known (see, for example, \cite{afoninMinimalUnionFreeDecompositions2009}) that every regular language can be represented by a finite union of union-free regular expressions. 

\begin{cor}
    For any regular language $P$ over a finite alphabet of transitions, there exist a finite number of union-free regular languages $L_1,\ldots, L_m$ over the same alphabet such that $P = \bigcup_{i=1}^m L_i$.
\end{cor}

This motivates the formal definition of periodic programs:

\begin{defn}
    A periodic program $L$ is a union-free regular language generated by a proper program graph $G_L$.
\end{defn}

We observe that there exist deterministic algorithms for computing a ``minimal'' decomposition of any regular language into union-free regular languages \cite{afoninMinimalUnionFreeDecompositions2009}; thus, we allow ourselves to refer to a ``single'' decomposition of programs into periodic programs for convenience. 
For a periodic program $L$, we use $R_L$ to denote the minimal union-free regular expression that defines $L$.

We associate entire periodic programs with a \textbf{single} coupling strategy.

\begin{defn}[Coupling strategy for a periodic program]
    Let $L$ be a periodic program generated by the graph $G_L = (V_L, E_L)$. Then a coupling strategy $C = (\gamma, \gamma')$ for a periodic program is a function $C:E_L\times\RR \times\RR\to [-1, 1]\times[-1, 1]$ that computes shifts for each transition-labeled edge in $G_L$ as a function of two adjacent inputs.
\end{defn}

Observe that a coupling strategy for a periodic program $L$ implicitly defines a coupling strategy for each SLP in $L$. 

\begin{defn}[Induced Coupling Strategy]\label{svInducedCouplingStrategy}
    Given a coupling strategy $C = (\gamma, \gamma')$ for a periodic program $L$ and a specific SLP $\rho\in L$, the coupling strategy for $\rho=t_0\cdots t_{n-1}$ induced by $C$ is the pair of functions $\gamma_\rho, \gamma'_\rho$ such that 
    \begin{align*}
        \gamma_\rho(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= (\gamma(\Psi^{-1}(t_0))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}), \ldots,\gamma(\Psi^{-1}(t_{n-1}))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) )\\
        \gamma'_\rho(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= (\gamma'(\Psi^{-1}(t_0))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}),\ldots,\gamma'(\Psi^{-1}(t_{n-1}))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) )
    \end{align*}
\end{defn}

We define the ``cost'' of a periodic program coupling strategy to be the supremum of the costs of the coupling strategies it induces on every constituent SLP: $cost(C_L) = \sup_{\rho\in L}cost(C_\rho)$, where $C_\rho$ is the coupling strategy for $\rho$ induced by $C_L$. 

Naturally, we can use periodic program coupling strategies to construct a proof of privacy for a program.

\begin{lemma}
    If, for every periodic program $L$ in $P$, there exists a valid coupling strategy $C_L$, then $P$ is $(\max_{L\subseteq P} cost(C_L))\varepsilon$-differentially private.
\end{lemma}

\begin{proof}
    Follows directly from definition \ref{setOfPathsDPDefn} and corollary \ref{pathCostCor}.
\end{proof}


Note that, because of the introduction of cycles to our model, it is possible for a periodic program to fail to be private for \textit{any} $d>0$. We can characterize whether or not a coupling strategy has infinite cost through a single constraint:

\begin{lemma}\label{finiteCostConstraintLemma}
    For a periodic program $L$ generated by $G_L$, a valid coupling strategy $C = (\mathbf{\gamma}, \mathbf{\gamma}')$ has finite cost $cost(C)<\infty$ if and only if the following constraint applies for all $i$:
    \begin{itemize}
        \item If $t_i$ is contained within a star in $R_L$ (i.e. $\Psi^{-1}(t_i)$ is in a cycle in $G_L$), then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$ and $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$.
    \end{itemize}
\end{lemma}

Intuitively, lemma \ref{finiteCostConstraintLemma} states that a finite-cost coupling strategy must assign shifts such that every cycle transition has 0 coupling cost. 

We can combine this constraint that gives us \textit{finite cost} class coupling strategies with the four constraints that ensure that coupling strategies are valid. 

\begin{defn}[Privacy Constraint System]\label{privacyConstraintSystem}
    Let $L$ be a periodic program generated by the graph $G_L$. If, for a candidate coupling strategy $C_L = (\gamma, \gamma')$ for $L$, the following constraints are satisfied for all $i$: \begin{enumerate}
        \item If $c_i = \lguard[\texttt{x}]$, then $\gamma_i\leq\gamma_{at(i)}$
        \item If $c_i = \gguard[\texttt{x}]$, then $\gamma_i\geq\gamma_{at(i)}$
        \item If $\sigma_i = \texttt{insample}$, then $\gamma_i=0$
        \item If $\sigma_i = \texttt{insample}'$, then $\gamma_i'=0$
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
    \end{enumerate}
    then we say that $C$ satisfies the privacy constraint system for $L$. 
\end{defn}

It follows immediately from lemma \ref{finiteCostConstraintLemma} that if there exists a solution to the privacy constraint system for a periodic program $L$, then $L$ is private.

\begin{prop}\label{privacyFiniteCostProp}
    If there exists a coupling strategy $C$ for a periodic program $L$ that satisfies the privacy constraint system, then there exists a finite $d>0$ such that $L$ is $d\varepsilon$-differentially private. 
\end{prop}

\begin{cor}\label{svProgramPrivacyCorollary}
    If, for every periodic program $L\subseteq P$ in a program $P$, there exists a coupling strategy $C_L$ that satisfies the privacy constraint system, then there exists some finite $d>0$ such that $P$ is $d\varepsilon$-differentially private.    
\end{cor}

