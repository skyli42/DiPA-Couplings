
\subsection{Unbounded Programs}

We now discuss our full program model. We allow for programs with looping and branching constructs, which can be represented by a control flow graph $G = (V, E)$ in the standard manner. 

We take $V$ to be a finite set of program locations and edges $e\in E$ between program locations to represent program statements. We also associate every control flow graph $G$ with a finite alphabet of output symbols $\Gamma_G$.

We will limit the class of programs we consider to those that support coupling proofs by restricting program statements to exactly transitions $t = (c, \sigma, \tau)$ (defn. \ref{svTransDef}); thus, each edge $e\in E$ is labeled by a transition $t_e = (c_e, \sigma_e, \tau_e)$, where $\sigma_e \in \Gamma_G$. 

Additionally, to ensure that $G$ represents a coherent program, we require that a program with control flow graph $G = (V, E)$ satisfies the following conditions: 

\begin{itemize}
    \item \textbf{Initialization:} $V$ contains some unique initial location $\ell_{init}\in V$ such that there is exactly one edge $e_{init}\in E$ whose source is $\ell_{init}$ and $e_{init}$ is labeled with the transition $t_{init} = (\texttt{true}, \sigma, \texttt{true})$.
    \item \textbf{Determinism:} For all locations $\ell\in V$, if there exists an edge $(\ell, \ell')$ labeled by $t'=(c, \sigma', \tau')$, then no other edge $(\ell, \ell^*)$ labeled by a transition of the form $t^* = (c, \sigma^*, \tau^*)$ exists. 
    Additionally, if there exists an edge $(\ell, \ell')\in E$ labeled by a transition of the form $(\texttt{true}, \sigma, \tau)$, then there does not exist another edge in $E$ with source at $\ell$.
    \item \textbf{Shared Noise:} For all locations $\ell\in V$ and any two edges $(\ell, \ell')$ labeled by $t'=(c', \sigma', \tau')$ and $(\ell, \ell^*)$ labeled by $t^* = (c^*, \sigma^*, \tau^*)$, $P(t') = P(t^*)$. 
    \item \textbf{Public Input: } For all locations $\ell\in V$, if there exists some edge $e = (\ell, \ell') \in E$ such that $e$ is labeled by a public transition, then every other edge from $\ell$ must also be labeled by a public transition. 
\end{itemize}

An \textbf{execution} of the program represented by $G$ is simply a path in $G$ that starts at $\ell_{init}$; thus, an execution of a program represented by $G$ takes the form of a string $\ell_{init}t_{init}\ell_1t_1\ldots t_{n-1}\ell_n$ for locations $\ell_i\in V$ and transitions $t_i$.

For any execution of a program, we can transform it into a program path as previously defined by dropping all states from the execution. For a execution $r=\ell_0t_0\ell_1t_1\ldots t_{n-1}\ell_n$, we will use the function $\Psi(r) = t_0t_1\ldots t_{n-1}$ to denote this homomorphism. We observe that, because $G$ satisfies determinism, $\Psi(r)$ is invertible. 

In particular, if $t_0t_1\ldots t_{n-1} = \Psi(r)$ for some execution $r$ of $G = (V, E)$, then we abuse notation and define $\Psi^{-1}(t_i) = \ell_i\to\ell_{i+1}$ as a function that maps transitions to the edge that ``generated'' it. 

We will say that $\{\Psi(r): r\text{ is a execution of }G\}$ is the set of paths generated by a labeled graph $G$. 

This leads to a natural definition for our full program model: 
\begin{defn}[Programs]
    A program $P$ is a language over a finite alphabet of transitions generated by a structured program graph $G$. In other words, $P$ is a possibly infinite set of complete paths. 
\end{defn}

We observe that any program $P$ is specifically a regular language. \sky{does this require further justification}

Proposition \ref{noSharingStrategiesProp} would suggest that it is impossible to compute optimal coupling strategies for a program, since programs can contain potentially an infinite number of paths, and a unique coupling strategy must naively be chosen for each path.

However, we show that it is possible to partition any program into a finite collection of infinitely sized subsets such that each subset can be collectively assigned a single optimal coupling strategy, turning the problem into a tractable one again.

\subsection{Looping Branches}
\sky{figure out a new name for this section}

We introduce \textbf{looping branches}, which we use to partition any program into a finite collection. As mentioned, each looping branch will be associated with a single coupling strategy. 

\begin{defn}
    A looping branch $L$ is a set of complete paths generated by a structured program graph $G_L$ such that $L$ is a language described by a single union-free regular expression over a finite alphabet of transitions. 
\end{defn}

For a looping branch $L$, we will use $R_L$ to denote the minimal union-free regular expression that defines $L$. 

Intuitively, a looping branch is a single, straight-line path except that we allow for cycles to be inserted within the path. Looping branches are, indeed, simply examples of the more general class of ``star-dot'' or union-free regular languages and their associated 1-cycle-free-path-automata (see, for example, \cite{nagy2006union}). Indeed, the graph $G_L$, by definition, will also be the graph of a 1-cycle-free-path automaton. 

In particular, it is known \sky{citation needed, can't seem to find the actual original papers right now, only other people citing them} that every regular language can be represented by a finite union of union-free regular expressions. 

\begin{prop}
    For any program $P$, there exist a finite number of looping branches $L_1,\ldots, L_m$ such that $P = \bigcup_{i=1}^m L_i$.
\end{prop}

Observe that the generating graphs for the constituent looping branches of a program $P$ are subgraphs of the generating graph for $P$. 

We will associate entire looping branches with a \textbf{single} coupling strategy.

\begin{defn}[Coupling strategy for a looping branch]
    Let $L$ be a looping branch generated by the graph $G_L = (V_L, E_L)$. Then a coupling strategy $C = (\gamma, \gamma')$ for a looping branch is a function $C:E_L\times\RR \times\RR\to [-1, 1]\times[-1, 1]$ that computes shifts for each transition-labeled edge in $L$ as a function of two adjacent inputs.
\end{defn}

We will sometimes call these coupling strategies ``class'' coupling strategies when necessary to distinguish them from coupling strategies for individual paths.

Observe that a class coupling strategy implicitly defines a coupling strategy for each path in $L$.

\begin{defn}[Induced Coupling Strategy]\label{svInducedCouplingStrategy}
    Given a coupling strategy $C = (\gamma, \gamma')$ for a looping branch $L$ and a specific path $\rho\in L$, the coupling strategy for $\rho=t_0\cdots t_{n-1}$ induced by $C$ is the pair of functions $\gamma_\rho, \gamma'_\rho$ such that 
    \begin{align*}
        \gamma_\rho(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= (\gamma(\Psi^{-1}(t_0))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}), \ldots,\gamma(\Psi^{-1}(t_{n-1}))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) )\\
        \gamma'_\rho(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= (\gamma'(\Psi^{-1}(t_0))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}),\ldots,\gamma'(\Psi^{-1}(t_{n-1}))(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) )
    \end{align*}
\end{defn}

Naturally, we can use class coupling strategies to construct a proof of privacy for a program.

\begin{lemma}
    If, for every looping branch $L$ in $P$, there exists a valid coupling strategy $C_L$, then $P$ is $(\max_{L\subseteq P} cost(C_L))\varepsilon$-differentially private. 
\end{lemma}

We show that it is in fact optimal to only consider a single coupling strategy for an entire looping branch; not only is finding individual coupling strategies for every single path in a looping branch intractable, but it also does not lead to a better overall privacy cost. 

\begin{prop}\label{ClassCouplingStrategiesAreEnoughProp}
    If there exists a valid coupling strategy $C_\rho$ with cost $cost(C_\rho)$ for every path $\rho$ of looping branch $L$ and $\sup_{\rho\in L}cost(C_\rho)< \infty$, then there exists a valid class coupling strategy $C'$ for $L$ such that $cost(C') \leq \sup_{\rho\in L}cost(C_\rho)$. 
\end{prop}

Note that, because of the introduction of cycles to our model, it is possible for a looping branch to fail to be private for \textit{any} $d>0$; in other words, every coupling strategy for a looping branch has infinite cost. We can characterize whether or not a coupling strategy has infinite cost through a single constraint:

\begin{lemma}\label{finiteCostConstraintLemma}
    For a looping branch $L$ generated by $G_L$, a valid coupling strategy $C = (\mathbf{\gamma}, \mathbf{\gamma}')$ has finite cost $cost(C)<\infty$ if and only if the following constraint applies for all $i$:
    \begin{itemize}
        \item If $t_i$ is contained within a star in $R_L$ (i.e. $\Psi^{-1}(t_i)$ is in a cycle in $G_L$), then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$ and $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$.
    \end{itemize}
\end{lemma}

Intuitively, a finite-cost coupling strategy must assign shifts such that every cycle transition has 0 privacy cost. 

In particular, we can combine this constraint that gives us \textit{finite cost} class coupling strategies with the four constraints that ensure that coupling strategies are valid.

\begin{defn}[Privacy Constraint System]\label{privacyConstraintSystem}
    Let $L$ be a looping branch generated by the graph $G_L$. If, for a candidate coupling strategy $C_L = (\gamma, \gamma')$ for $L$, the following constraints are satisfied for all $i$: \begin{enumerate}
        \item If $c_i = \lguard[\texttt{x}]$, then $\gamma_i\leq\gamma_{at(i)}$
        \item If $c_i = \gguard[\texttt{x}]$, then $\gamma_i\geq\gamma_{at(i)}$
        \item If $\sigma_i = \texttt{insample}$, then $\gamma_i=0$
        \item If $\sigma_i = \texttt{insample}'$, then $\gamma_i'=0$
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
    \end{enumerate}
    then we say that $C$ satisfies the privacy constraint system for $L$. 
\end{defn}

As expected, if there exists a solution to the privacy constraint system for a looping branch $L$, then $L$ is private.

\begin{prop}\label{privacyFiniteCostProp}
    If there exists a coupling strategy $C$ for a looping branch $L$ that satisfies the privacy constraint system, then there exists a finite $d>0$ such that $L$ is $d\varepsilon$-differentially private. 
\end{prop}

\begin{cor}
    If, for every looping branch $L\subseteq P$ in a program $P$, there exists a coupling strategy $C_L$ that satisfies the privacy constraint system, then there exists some finite $d>0$ such that $P$ is $d\varepsilon$-differentially private.    
\end{cor}

Perhaps surprisingly, we now show that, under certain conditions, the privacy constraint system is complete; that is, if there does not exist a solution to the privacy constraint system, we can prove that there also does not exist any finite $d>0$ such that $L$ is $d\varepsilon$-differentially private. 