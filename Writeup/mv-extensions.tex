
\section{Program Model Extensions}

The class of programs we have defined is rather limited, leading to the natural question of whether our results can be extended to more powerful program models. 

Some `natural' extensions of DiPA end up reducing directly to DiPA. For example, we considered an extension of DiPA that included a single integral ``counter'' variable $n$; this program model also allowed for branching conditional on $n$ being greater than a threshold value. 
We discovered that every DiPA equipped with a counter can be rewritten as a standard DiPA by using a power set-style automata construction. \sky{is more elaboration here necessary?}

However, there are other extensions that warrant further study. In particular, we analyze one extension of DiPA that allows for two real-valued program variables $\texttt{x}, \texttt{y}$.

\subsection{Two-Variable Programs: GDiPA}

\subsubsection{Multivariable Transitions}

We begin by defining two-variable transitions to construct a transition alphabet, as in the single variable case.

\begin{defn}[Two-variable guards]
    Let $\texttt{x}, \texttt{y}$ be real-valued program variables. Then a transition \textbf{guard} is a boolean statement $c = c(x)\oplus c(y)$ where \begin{itemize}
        \item $c(x)\in \{\texttt{true}, \lguard[\texttt{x}], \gguard[\texttt{x}]\}$
        \item $c(y)\in \{\texttt{true}, \lguard[\texttt{y}], \gguard[\texttt{y}]\}$
        \item $\oplus \in \{\land, \lor\}$
    \end{itemize}
    As expected, if, for example, $c = c(x) \land \texttt{true}$, we will shorthand $c$ to $c(x)$ and if $c = c(x)\lor \texttt{true}$, we will shorthand $c$ to $\texttt{true}$. In general, we will use $c(x)$ and $c(y)$ to notate the $\texttt{x}$ and $\texttt{y}$ components of a two-variable guard. 

    Let $\mathcal{C}^{(2)}$ be the set of all possible guards with two variables \texttt{x} and \texttt{y}.
\end{defn}

We can now define two variable transitions, which differ from single variable transitions only in their guard and in the ability to choose which variable to optionally assign into. 

\begin{defn}[2v-transitions]
    A two-variable transition (2v-transition) is a tuple $(q, q', c, \sigma, \tau)$ where \begin{itemize}
        \item $q\in Q$ is the initial location
        \item $q'\in Q$ is the destination location
        \item $c\in\mathcal{C}^{(2)}$ is a transition guard.
        \item $\sigma\in\Gamma\cup\{\texttt{insample}^{(x)}, \texttt{insample}^{(x)\prime}, \texttt{insample}^{(y)}, \texttt{insample}^{(y)\prime}\}$ is the output of the transition
        \item $\tau \in \{0, 1, 2\}$ indicates whether to assign $\texttt{insample}$ into no variable, $\texttt{x}$, or $\texttt{y}$. In particular, note that only a single variable can be assigned into at a time. 
    \end{itemize}
\end{defn}

\subsubsection{Two Variable Program Semantics}

Two variable transitions semantically operate extremely similarly to single variable transitions: given some threshold values $\texttt{x}$ and $\texttt{y}$ and a transition $t = (q, q', c, \sigma, \tau)$, let $P(q) = (d, d')$. Then $t$ will first read in a real number input $\texttt{in}$, 
sample two random variables $z^{(x)}\sim\Lap(0, \frac{1}{d\varepsilon})$ and $z^{(x)\prime}\sim\Lap(0, \frac{1}{d'\varepsilon})$ for comparing the input to $\texttt{x}$ and two more random variables $z^{(y)}\sim\Lap(0, \frac{1}{d\varepsilon})$ and $z^{(y)\prime}\sim\Lap(0, \frac{1}{d'\varepsilon})$ for comparing the input to $\texttt{y}$.
Using these noise variables, the transition then assigns four variables $\texttt{insample}^{(x)} = \texttt{in} + z^{(x)}$, $\texttt{insample}^{(x)\prime} = \texttt{in} + z^{(x)\prime}$, $\texttt{insample}^{(y)} = \texttt{in} + z^{(y)}$, and $\texttt{insample}^{(x)\prime} = \texttt{in} + z^{(y)\prime}$. 
If the guard $c$ is satisfied when comparing $\texttt{insample}^{(x)}$ to $\texttt{x}$ and $\texttt{insample}^{(y)}$ to $\texttt{y}$, then we transition to location $q'$, outputting $\sigma$ and, depending on $\tau$, optionally reassigning $\texttt{x} = \texttt{insample}^{(x)}$, $\texttt{y} = \texttt{insample}^{(y)}$, or neither.

In particular, note that the noisy input that the threshold variables are compared to is independent for $\texttt{x}$ and $\texttt{y}$.

More formally, a program state is a tuple consisting of a program location and values for $\texttt{x}$ and $\texttt{y}$. Let $S = Q\times\RR\times \RR$ be the set of all possible program states. As expected, every possible input is simply an element of $\RR$. 
As before, the set of all possible output events is $\Gamma \cup \Sigma$, where $\Sigma$ is the standard $\sigma$-algebra of all Lebesgue measurable sets. 

Then the semantics of a 2v-transition $t$ can be defined as a function $\Phi_t((q, \texttt{x}, \texttt{y}), \texttt{in}): S\to dist(S\times (\Gamma\cup\RR\cup \lambda))$ that maps an initial program state and an input to a distribution of subsequent program states and an output event following the expected semantics; $\lambda$ here denotes the empty string (i.e. no output). 

The precise semantics are defined exactly analogously to the single variable case. 

We again denote the probability that a transition $t= (q, q', c, \sigma, tau)$ ``succeeds'' as $\PP[\texttt{x}, \texttt{y}, t, \texttt{in}, o] = \int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\PP[\texttt{x}\gets x']\PP[\texttt{y}\gets y']\Phi_t((q, \texttt{x}, \texttt{y}))((q', x', y'), o)dx'dy'$, where $\texttt{x}, \texttt{y}\in \RR$ are the initial values of $\texttt{x}$ and $\texttt{y}$, respectively, $\texttt{in}\in \RR$ is a real-valued input, and $o\in \Gamma\cup\Sigma$ is a possible output of $t$.

\begin{defn}[Valid Transition Alphabets]
    A finite 2v-transition alphabet $\Sigma_T$ is valid if it satisfies the following conditions: 
    \begin{itemize}
        \item \textbf{Initialization:} There exist some $t_{init}^{(x)}, t_{init}^{(y)}\in \Sigma_T$ such that $t_{init}^{(x)} = (q_0, q_1, \texttt{true}, \sigma_0, 1)$ and $t_{init}^{(y)} = (q_1, q_2, \texttt{true}, \sigma_1, 2)$ for some $q_0, q_1, q_2\in Q$, $\sigma_0, \sigma_1 \in \Gamma\cup\{\texttt{insample}, \texttt{insample}'\}$. 
        \item \textbf{Determinism}: If $\Sigma_T$ contains transition $t, t'$ such that $t=(q, q', c, \sigma, \tau)$ and $t'= (q, q^*, c', \sigma', \tau')$, then $c$ and $c'$ must be logically disjoint. 
        \item \textbf{Output distinction}: If there exist some $\sigma, \sigma', \tau, \tau'$ such that $(q, q', c, \sigma, \tau)\in \Sigma_T$  and $(q, q^*, c', \sigma', \tau') \in \Sigma_T$ for distinct guards $c, c'$, then $\sigma \neq \sigma'$. Additionally, at least one of $\sigma\in \Gamma$, $\sigma'\in \Gamma$ is true.
        \item \textbf{Non-input location condition}: For all locations $q\in Q_{non}$, if there exists a transition $t=(q, q', c, \sigma, \tau)$ such that $t\in \Sigma_T$, then $c = \texttt{true}$.
        \item \textbf{Assignment spread parameter condition}: There exists some constant $d_{at}>0$ such that for all transitions $t = (q, q', c, \sigma, \tau)\in \Sigma_T$ where $\tau \in \{1, 2\}$, $P(q) = (d_{at}, d_q')$.
    \end{itemize}
\end{defn}

For technical reasons that will become clear later, we introduce a new validity condition (the ``assignment spread parameter condition'') that requires that all assignment transitions have the same spread parameter on their Laplace noise.

\subsubsection{Multivariable Couplings}

In this section, we introduce two methods for constructing two variable couplings for 2v-transitions; one method combines couplings in parallel and the other combines couplings for different variables together. 

We first show that if we can create couplings for each variable in isolation, then we can immediately create a coupling for a combined 2v-transition. 

\begin{lemma}\label{mvParallelCouplingsLemma}
    Let $X\brangle{1}\sim \Lap(\mu_x\brangle{1}, \frac{1}{d_{at}\varepsilon}), X\brangle{2}\sim\Lap(\mu_x\brangle{2}, \frac{1}{d_{at}\varepsilon})$ respectively be random variables representing two possible initial values of $\texttt{x}$, 
    and $Y\brangle{1}\sim \Lap(\mu_y\brangle{1}, \frac{1}{d_{at}\varepsilon}), Y\brangle{2}\sim\Lap(\mu_y\brangle{2}, \frac{1}{d_{at}\varepsilon})$ respectively be random variables representing two possible initial values of $\texttt{y}$.

    Let $t\in \Sigma_T$ be a 2v-transition $t = (q, q^*, c, \sigma, \tau)$ from $q$ to $q^*\in Q$. Let $P(q) = (d_q, d_q')$.

    Let $\texttt{in}\brangle{1}, \texttt{in}\brangle{2}$ be an arbitrary valid adjacent input pair for $t$ and let $o\brangle{1}$, $o\brangle{2}$ be random variables representing possible outputs of $t$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. 

    Then $\forall \varepsilon>0$ and for all $\gamma_T^{(x)}, \gamma_q^{(x)}, \gamma_q^{(x)\prime},\gamma_T^{(y)}, \gamma_q^{(y)}, \gamma_q^{(y)\prime}\in [-1, 1]$ that satisfy the constraints \[
        \begin{cases}
          \gamma_q^{(x)}\leq\gamma_T^{(x)} & c(x) = \lguard[\texttt{x}]\\
          \gamma_q^{(x)}\geq\gamma_T^{(x)} & c(x) = \gguard[\texttt{x}]\\
          \gamma_q^{(x)}=0 & \sigma = \texttt{insample}^{(x)}\\
          \gamma_q^{(x)\prime}=0 & \sigma = \texttt{insample}^{(x)\prime}\\
          \gamma_q^{(y)}\leq\gamma_T^{(y)} & c(y) = \lguard[\texttt{y}]\\
          \gamma_q^{(y)}\geq\gamma_T^{(y)} & c(y) = \gguard[\texttt{y}]\\
          \gamma_q^{(y)}=0 & \sigma = \texttt{insample}^{(y)}\\
          \gamma_q^{(y)\prime}=0 & \sigma = \texttt{insample}^{(y)\prime}
        \end{cases},
      \]
      the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for 
      $d = (|\mu_x\brangle{1}-\mu_x\brangle{2}+\gamma_T^{(x)}|)d_{at}^{(x)}+(|\mu_y\brangle{1}-\mu_y\brangle{2}+\gamma_T^{(y)}|)d_{at}^{(y)}+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(x)}|+|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(y)}|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(x)\prime}|+|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(y)\prime}|)d_q'$.
\end{lemma}
\begin{proof}
    From lemma \ref{indTransitionCoupling}, we know that if these constraints are satisfied, we can create liftings such that \begin{itemize}
        \item $c(x)$ is satisfied in $\brangle{1}\implies c(x)$ is satisfied in $\brangle{2}$
        \item $c(y)$ is satisfied in $\brangle{1}\implies c(y)$ is satisfied in $\brangle{2}$
    \end{itemize}
    Further, $c$ being satisfied is equivalent to either $c(x)\land c(y)$ or $c(x)\lor c(y)$. In either case, we can immediately show that $c$ being satisfied in $\brangle{1}\implies c$ is satisfied in $\brangle{2}$.

    Finally, as before, if $\sigma \in \{\texttt{insample}^{(x)}, \texttt{insample}^{(x)\prime}, \texttt{insample}^{(y)},\texttt{insample}^{(y)\prime}\}$, then for all $\sigma$, $o\brangle{1}=\sigma \implies o\brangle{2} = \sigma$. By simply adding up the costs from lemma \ref{indTransitionCoupling}, we complete the proof.
\end{proof}

This provides an extremely straightforward method of combining coupling strategies for different variables together; indeed, this specific result is immediately extensible to an arbitrary number of variables. 

\begin{cor}
    If there exist coupling strategies $C_x, C_y$ that each independently satisfy the privacy constraint system for a 2v-transition $t$, then there exists a valid 2-coupling strategy $C$ for $t$ such that $cost(C) = cost(C_x)+cost(C_y)$. 
\end{cor}

\textbf{Cross-Couplings}

We now introduce a new type of coupling strategy for a single (2v-)transition:

\begin{lemma}\label{mvIndTransitionCoupling}
    Let $X\brangle{1}\sim \Lap(\mu_x\brangle{1}, \frac{1}{d_{at}\varepsilon}), X\brangle{2}\sim\Lap(\mu_x\brangle{2}, \frac{1}{d_{at}\varepsilon})$ respectively be random variables representing two possible initial values of $\texttt{x}$, 
    and $Y\brangle{1}\sim \Lap(\mu_y\brangle{1}, \frac{1}{d_{at}\varepsilon}), Y\brangle{2}\sim\Lap(\mu_y\brangle{2}, \frac{1}{d_{at}\varepsilon})$ respectively be random variables representing two possible initial values of $\texttt{y}$. 

    Let $t\in \Sigma_T$ be a (2v-)transition $t = (q, q^*, c, \sigma, \tau)$ from $q$ to $q^*\in Q$. Let $P(q) = (d_q, d_q')$.

    Let $\texttt{in}\brangle{1}, \texttt{in}\brangle{2}$ be an arbitrary valid adjacent input pair for $t$ and let $o\brangle{1}$, $o\brangle{2}$ be random variables representing possible outputs of $t$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. 

    Then for all $\gamma_T^{(x)}, \gamma_q^{(x)}, \gamma_q^{(x)\prime},\gamma_T^{(y)}, \gamma_q^{(y)}, \gamma_q^{(y)\prime} \in [-1, 1]$ that satisfy the constraints \[
        \begin{cases}
          \gamma_q^{(x)}=0 & \sigma = \texttt{insample}^{(x)}\\
          \gamma_q^{(x)\prime}=0 & \sigma = \texttt{insample}^{(x)\prime}\\
          \gamma_q^{(y)}=0 & \sigma = \texttt{insample}^{(y)}\\
          \gamma_q^{(y)\prime}=0 & \sigma = \texttt{insample}^{(y)\prime}
        \end{cases},
      \]

    The following four statements hold:\begin{enumerate}
        \item If $c = \lguard[\texttt{x}] \land \gguard[\texttt{y}]$, then $\forall \varepsilon>0$, the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = |\min(\mu_y\brangle{1}-\mu_x\brangle{1}, 0)|+(|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_{at}+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$. 
        \item If $c = \gguard[\texttt{x}] \land \lguard[\texttt{y}]$, then $\forall \varepsilon>0$, the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = |\min(\mu_x\brangle{1}-\mu_y\brangle{1}, 0)|+(|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_{at}+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$. 
        \item If $c = \lguard[\texttt{x}] \lor \gguard[\texttt{y}]$, then $\forall \varepsilon>0$, the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = |\max(0, \mu_y\brangle{1}+ \gamma_T^{(y)}-\mu_x\brangle{1}-\gamma_T^{(x)})|+(|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_{at}+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$. 
        \item If $c = \gguard[\texttt{x}] \lor \lguard[\texttt{y}]$, then $\forall \varepsilon>0$, the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = |\max(0, \mu_x\brangle{1}+ \gamma_T^{(x)}-\mu_y\brangle{1}-\gamma_T^{(y)})|+(|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_{at}+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$. 
    \end{enumerate}
\end{lemma}
\begin{proof}
    For convenience, we will rewrite $X$ and $Y$ as $X = \mu_x + \zeta_x$ and $Y = \mu_y + \zeta_y$, where $\zeta_x \sim\Lap(0, \frac{1}{d_{at}\varepsilon})$ and $\zeta_y \sim\Lap(0, \frac{1}{d_{at}\varepsilon})$. 
    As before, we also write $\texttt{insample}^{(x)} = \texttt{in} + z^{(x)}$, where $z\sim\Lap(0, \frac{1}{d_q\varepsilon})$ and $\texttt{insample}^{(x)\prime} = \texttt{in} + z^{(x)\prime}$, where $z'\sim\Lap(0, \frac{1}{d_q'\varepsilon})$ (and symmetrically for $\texttt{insample}^{(y)}$, $\texttt{insample}^{(y)\prime}$).

    We show cases (1) and (3). Cases (2) and (4) follow symmetrically. 

    As in the single variable case, suppose that we have the liftings
    \begin{itemize}
        \item $X\brangle{1}+\gamma_T^{(x)} (=)^{\#(|\mu_x\brangle{1}-\mu_x\brangle{2}+\gamma_T^{(x)}|)d_x\varepsilon}X\brangle{2}$.
        \item $\texttt{insample}^{(x)}\brangle{1} +\gamma_q^{(x)}{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(x)}|)d_q\varepsilon}\texttt{insample}^{(x)}\brangle{2}$
        \item $\texttt{insample}^{(x)\prime}\brangle{1} +\gamma_q^{(x)\prime}{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(x)\prime}|)d_q'\varepsilon}\texttt{insample}^{(x)\prime}\brangle{2}$
        \item $Y\brangle{1}+\gamma_T^{(y)} (=)^{\#(|\mu_y\brangle{1}-\mu_y\brangle{2}+\gamma_T^{(y)}|)d_y\varepsilon}Y\brangle{2}$.
        \item $\texttt{insample}^{(y)}\brangle{1} +\gamma_q^{(y)}{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(y)}|)d_q\varepsilon}\texttt{insample}^{(y)}\brangle{2}$
        \item $\texttt{insample}^{(y)\prime}\brangle{1} +\gamma_q^{(y)\prime}{(=)}^{\#(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q^{(y)\prime}|)d_q'\varepsilon}\texttt{insample}^{(y)\prime}\brangle{2}$
    \end{itemize}

    \textbf{Case 1:}

    Create the lifting $\zeta_x\brangle{1} +\gamma_{xy}(=)^{\#|\gamma_{xy}|d_{at}\varepsilon}\zeta_y\brangle{1}$ where $\gamma_{xy} = -\min(\mu_y\brangle{1}-\mu_x\brangle{1}, 0)$. 

    Then observe that if $\mu_x\brangle{1}\geq \mu_y\brangle{1}$, \begin{align*}
        X\brangle{1}&= \mu_x\brangle{1} + \zeta_x\brangle{1}\\
        &= \mu_x\brangle{1} + \zeta_y\brangle{1}+\mu_y\brangle{1}-\mu-x\brangle{1}\\
        &=Y\brangle{1}
    \end{align*}

    Otherwise, if $\mu_x\brangle{1}<\mu_y\brangle{1}$, then \begin{align*}
        X\brangle{1}&= \mu_x\brangle{1} + \zeta_x\brangle{1}\\
        &\leq \mu_y\brangle{1}+\zeta_y\brangle{1}\\
        &=Y\brangle{1}
    \end{align*}
    so $X\brangle{1}\leq Y\brangle{1}$.

    Further, create the lifting $z^{(x)}\brangle{1}(=)^{\#0}z^{(y)}\brangle{1}$. Note that then $\texttt{insample}^{(x)}\brangle{1}=\texttt{in}_i\brangle{1} + z_i^{(x)}\brangle{1} =\texttt{in}_i\brangle{1} + z_i^{(y)}\brangle{1}=\texttt{insample}^{(y)}\brangle{1}$.

    Then because $x\brangle{1} \leq y\brangle{1}$, $\texttt{insample}^{(x)}\brangle{1}<x\brangle{1}\land\texttt{insample}^{(y)}\brangle{1}\geq y\brangle{1}$ must be false. Thus, $\texttt{insample}^{(x)}\brangle{1}<x\brangle{1}\land\texttt{insample}^{(y)}\brangle{1}\geq y\brangle{1}\implies \texttt{insample}^{(x)}<x\brangle{2}\land\texttt{insample}^{(y)}\geq y\brangle{2}$.

    This suffices to show that if the transition is taken in run $\brangle{1}$, then it is also taken in run $\brangle{2}$. Thus, if any of \begin{itemize}
        \item $\sigma \in \Gamma$
        \item $\sigma = \texttt{insample}^{(x)}$ and $\gamma_q^{(x)}=0$ 
        \item $\sigma = \texttt{insample}^{(x)\prime}$ and $\gamma_q^{(x)\prime}=0$ 
        \item $\sigma = \texttt{insample}^{(y)}$ and $\gamma_q^{(y)}=0$
        \item $\sigma = \texttt{insample}^{(y)\prime}$ and $\gamma_q^{(y)\prime}=0$
    \end{itemize}
    are true, then the lifting holds as desired. 

    \textbf{Case 3:}
    
    Create the lifting $\zeta_x\brangle{1} + \gamma_{xy} (=)^{\#|\gamma_{xy}|d_{at}\varepsilon} \zeta_y\brangle{1}$ where $\gamma_{xy} = -\max(0, \mu_y\brangle{1}+ \gamma_T^{(y)}-\mu_x\brangle{1}-\gamma_T^{(x)})$

    Then if $\mu_x\brangle{1}+\gamma_T^{(x)}\leq \mu_y\brangle{1}+\gamma_T^{(y)}$, \begin{align*}
        X\brangle{2} &= X\brangle{1} + \gamma_T^{(x)}\\
        &=\mu_x\brangle{1} + \zeta_x\brangle{1} + \gamma_T^{(x)}\\
        &=\mu_x\brangle{1} +\zeta_y\brangle{1} + \mu_y\brangle{1}+ \gamma_T^{(y)}-\mu_x\brangle{1}-\gamma_T^{(x)} +\gamma_T^{(x)}\\
        &=Y\brangle{1} + \gamma_T^{(y)}\\
        &= Y\brangle{2}
    \end{align*}

    Otherwise, if $\mu_x\brangle{1}+\gamma_T^{(x)}> \mu_y\brangle{1}+\gamma_T^{(y)}$, then \begin{align*}
        X\brangle{2} &= X\brangle{1} + \gamma_T^{(x)}\\
        &=\mu_x\brangle{1} + \zeta_x\brangle{1} + \gamma_T^{(x)}\\
        &\geq \mu_y\brangle{1} +\gamma_T^{(y)}+\zeta_y\brangle{1}\\
        &=Y\brangle{1} + \gamma_T^{(y)}\\
        &= Y\brangle{2}
    \end{align*}

    Thus, $X\brangle{2}\geq Y\brangle{2}$.

    Further, create the lifting $z^{(x)}\brangle{2}(=)^{\#0}z^{(y)}\brangle{2}$. Note that then $\texttt{insample}^{(x)}\brangle{2}=\texttt{in}_i\brangle{2} + z_i^{(x)}\brangle{2} =\texttt{in}_i\brangle{2} + z_i^{(y)}\brangle{2}=\texttt{insample}^{(y)}\brangle{2}$.

    Then because $X\brangle{2} \geq Y\brangle{2}$, $\texttt{insample}^{(x)}\brangle{2}<x\brangle{2}\lor \texttt{insample}^{(y)}\brangle{2}\geq y\brangle{2}$ must be true. Thus, $\texttt{insample}^{(x)}\brangle{1}<x\brangle{1}\lor\texttt{insample}^{(y)}\brangle{1}\geq y\brangle{1}\implies \texttt{insample}^{(x)}<x\brangle{2}\lor\texttt{insample}^{(y)}\geq y\brangle{2}$.

    As before, if any of \begin{itemize}
        \item $\sigma \in \Gamma$
        \item $\sigma = \texttt{insample}^{(x)}$ and $\gamma_q^{(x)}=0$ 
        \item $\sigma = \texttt{insample}^{(x)\prime}$ and $\gamma_q^{(x)\prime}=0$ 
        \item $\sigma = \texttt{insample}^{(y)}$ and $\gamma_q^{(y)}=0$
        \item $\sigma = \texttt{insample}^{(y)\prime}$ and $\gamma_q^{(y)\prime}=0$
    \end{itemize}
    are true, then the lifting holds as desired. 

\end{proof}

Depending on the initial threshold values, this allows us to construct liftings for certain transitions ``for free'' in a manner compatible with existing liftings. In particular, this construction applies to transitions whose guards intuitively correspond to checking if an input is within either the empty set or the entire real line, which are either always true or always false. 

\begin{defn}
    Let $\Sigma_T$ be a valid 2v-transition alphabet. A 2v-path over $\Sigma_T$ is a sequence of transitions $\rho=t_0\cdot t_1\cdot \ldots \cdot t_{n-1}$ such that for all $i$ there exists a location $q_i\in Q$ such that $t_i = (q_i, q_{i+1}, c_i, \sigma_i, \tau_i)$. A 2v-path is \textbf{complete} if it is in the form $t_{init}^{(x)}t_{init}^{(y)}\cdot \rho$ for some $\rho\in \Sigma_T^*$.
\end{defn}

The semantics of a 2v-path are again defined exactly analogously to the single variable case; we denote the probability of a path $\rho$ ``succeeding'' as $\PP[\texttt{x}, \texttt{y}, \rho, \texttt{in}, \sigma]$ for initial values $\texttt{x}, \texttt{y}\in \RR$, input sequence $\texttt{in}$ and output sequence $\sigma$. 

\sky{redefine privacy?}

We will allow cross-couplings only between assignment transitions of different variables; to avoid redundancy, we require that a cross-coupling is \textit{from} an assignment into $\texttt{x}$ and \textit{to} an assignment into $\texttt{y}$.

Combining our ``parallel'' and ``cross'' coupling strategies gives us the major lemma for multivariable path couplings.

\begin{lemma}\label{mvcouplinglemma}
    Let $\rho = q_0\to \ldots \to q_n$ be a complete path of length $n$. 
    Let $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ be arbitrary adjacent valid input sequences of length $n$. Additionally, fix some potential output $\sigma$ of $\rho$ of length $n$ and let $\sigma\brangle{1}$, $\sigma\brangle{2}$ be random variables representing possible outputs of $\rho$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. Additionally, for all $q_i$, let $P(q_i) = (d_i, d_i')$.

    Then $\forall \varepsilon>0$ and for all $\{\gamma_i, \gamma_i'\}_{i=0}^{n-1}$ that, for all $i$, satisfy the following constraints:\begin{enumerate}
        \item If $c_i(x) = \lguard[\texttt{x}]$, then at least one of the following is true: \begin{itemize}
            \item $\gamma_i^{(x)}\leq \gamma^{(x)}_{at_x(i)}$
            \item $c_i = \lguard[\texttt{x}]\lor\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_y(i)}\brangle{1}-\texttt{in}_{at_x(i)}\brangle{1}, 0)$
            \item $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_y(i)}\brangle{1}+ \gamma_{at_y(i)}^{(y)}-\texttt{in}_{at_x(i)}\brangle{1}-\gamma_{at_x(i)}^{(x)})$
        \end{itemize}
        \item If $c_i(x) = \gguard[\texttt{x}]$, then at least one of the following is true: \begin{itemize}
            \item $\gamma_i^{(x)}\geq \gamma^{(x)}_{at_x(i)}$
            \item $c_i = \gguard[\texttt{x}]\lor\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_x(i)}\brangle{1}-\texttt{in}_{at_y(i)}\brangle{1}, 0)$
            \item $c_i = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$
        \end{itemize}
        \item If $c_i(y) = \lguard[\texttt{y}]$, then at least one of the following is true: \begin{itemize}
            \item $\gamma_i^{(y)}\leq \gamma^{(y)}_{at_y(i)}$
            \item $c_i = \gguard[\texttt{x}]\lor\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_x(i)}\brangle{1}-\texttt{in}_{at_y(i)}\brangle{1}, 0)$
            \item $c_i = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$
        \end{itemize}
        \item If $c_i(y) = \gguard[\texttt{y}]$, then at least one of the following is true: \begin{itemize}
            \item $\gamma_i^{(x)}\geq \gamma^{(x)}_{at_x(i)}$
            \item $c_i = \lguard[\texttt{x}]\lor\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_y(i)}\brangle{1}-\texttt{in}_{at_x(i)}\brangle{1}, 0)$
            \item $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_y(i)}\brangle{1}+ \gamma_{at_y(i)}^{(y)}-\texttt{in}_{at_x(i)}\brangle{1}-\gamma_{at_x(i)}^{(x)})$
        \end{itemize}
        \item If $\sigma_i = \texttt{insample}^{(x)}$, then $\gamma_i^{(x)}=0$
        \item If $\sigma_i = \texttt{insample}^{(x)\prime}$, then $\gamma_i^{(x)\prime}=0$
        \item If $\sigma_i = \texttt{insample}^{(y)}$, then $\gamma_i^{(y)}=0$
        \item If $\sigma_i = \texttt{insample}^{(y)\prime}$, then $\gamma_i^{(y)\prime}=0$
    \end{enumerate}
      the lifting $\sigma\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}\sigma\brangle{2}$ is valid for $d = \sum_{i=0}^{n-1}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i' + \sum_{i_x, i_y}|\gamma_{(i_x, i_y)}|d_{at}$, and therefore $t$ is $d\varepsilon$-differentially private. 
\end{lemma}
\begin{proof}
    Follows from lemma \ref{mvIndTransitionCoupling} exactly as lemma \ref{multTransitionsCouplingProof} follows from lemma \ref{indTransitionCoupling}.
\end{proof}

This leads to a natural definition of two variable coupling strategies for paths:

\begin{defn}[Two Variable Coupling Strategies]
    A (2v)-coupling strategy for a 2v-path $\rho$ is a collection of shifts $(\gamma^{(x)}, \gamma^{(x)\prime}, \gamma^{(y)}, \gamma^{(y)\prime}, \gamma_{(i, j)})$ such that \begin{itemize}
        \item $\gamma^{(x)}, \gamma^{(x)\prime}, \gamma^{(y)}$, and $\gamma^{(y)\prime}$ are functions of a transition $t_i$ in $\rho$ as well as two adjacent inputs $\texttt{in}_i\brangle{1}$ and $\texttt{in}_i\brangle{2}$ that output a shift in the range [-1, 1]. 
        \item $\gamma_{(i, j)}$ is a function of an $\texttt{x}$-assignment transition $t_i$ and a $\texttt{y}$-assignment transition $t_j$ as well as the inputs $\texttt{in}_{i}\brangle{1}$ and $\texttt{in}_j\brangle{1}$ that outputs a real-valued shift. 
        \item In particular, we require that $\gamma_{(i, j)}(\texttt{in}_{i}\brangle{1},\texttt{in}_{j}\brangle{1}) \in \{-\min(\texttt{in}_{j}\brangle{1}-\texttt{in}_{i}\brangle{1}, 0),-\max(0, \texttt{in}_{j}\brangle{1}+ \gamma_{j}^{(y)}-\texttt{in}_{i}\brangle{1}-\gamma_{i}^{(x)}), -\min(\texttt{in}_{i}\brangle{1}-\texttt{in}_{j}\brangle{1}, 0), -\max(0, \texttt{in}_{i}\brangle{1}+ \gamma_{i}^{(x)}-\texttt{in}_{j}\brangle{1}-\gamma_{j}^{(y)})\}$
    \end{itemize}
\end{defn}

The extension of 2v-paths to looping branches and programs is natural and follows exactly the same structure as single variable programs. 

\begin{defn}[Two Variable Looping Branches]
    A 2v-looping branch is a looping branch (i.e. a language of complete paths that can be represented by a union-free regular expression) over a valid 2v-transition alphabet $\Sigma_T$.
\end{defn}

Just as with the single variable, a single constraint system can fully capture privacy for two variable programs.

We can also similarly define coupling strategies for looping branches:

\begin{defn}
    Let $r$ be the union-free regular expression describing paths in a looping branch $L$. Let $T_r$ be the set of all transitions that appear in $r$. Then a coupling strategy $C = (\gamma, \gamma', \gamma_{xy})$ for a looping branch is a function $C:T_r\times\RR \times\RR\to [-1, 1]\times[-1, 1]$ that computes shifts for each transition in $L$ as a function of two adjacent inputs.
\end{defn}

\begin{defn}\label{mvPrivacyConstraintSystem}
    Let $L$ be a 2v-looping branch over a valid transition alphabet $\Sigma_T$. If, for a coupling strategy $C_L = (\gamma, \gamma', \gamma_{(i, j)})$ for $L$, the constraints from lemma \ref{mvcouplinglemma} and the following constraints are satisfied for all possible inputs $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$ and all $i$: \begin{enumerate}
        \setcounter{enumi}{8}
        \item If $t_i$ is in a cycle, then $\gamma_i = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $t_i$ is in a cycle, then $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $t_i$ is in a cycle, then for all $j$, $\gamma_{(i, j)} = 0$ and $\gamma_{(j, i)} = 0$
        \item If $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_y(i)}\brangle{1}-\texttt{in}_{at_x(i)}\brangle{1}, 0)$, then $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_x(i)}\brangle{1}$
        \item If $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_y(i)}\brangle{1}+ \gamma_{at_y(i)}^{(y)}-\texttt{in}_{at_x(i)}\brangle{1}-\gamma_{at_x(i)}^{(x)})$, then $\texttt{in}_{at_y(i)}\brangle{1}\leq \texttt{in}_{at_x(i)}\brangle{1}$
        \item If $\gamma_{(at_x(i), at_y(i))} = -\min(\texttt{in}_{at_x(i)}\brangle{1}-\texttt{in}_{at_y(i)}\brangle{1}, 0)$, then $\texttt{in}_{at_x(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$
        \item If $\gamma_{(at_x(i), at_y(i))} = -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$, then $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$
    \end{enumerate}
    then we say that $C$ satisfies the privacy constraint system for $L$. 
\end{defn}


\begin{lemma}
    If a coupling strategy $C$ satisfies the privacy constraint system for a 2v-looping branch $L$, then $cost(C)<\infty$ and $L$ is $cost(C)\varepsilon$-differentially private. 
\end{lemma}

\begin{proof}
    Because $C$ satisfies the privacy constraint system, we know that $C$ is a valid coupling strategy by lemma~\ref{mvcouplinglemma}. It remains to show that $C$ has finite cost. We can separate $cost(C)$ into cost contributed from $\gamma^{(x)}$ and $\gamma^{(x)\prime}$, $\gamma^{(y)}$ and $\gamma^{(y)\prime}$, and cross-coupling cost. We will denote these costs $c_x, c_{x\prime}, c_y, c_{y\prime}$, and $c_{xy}$ such that $cost(C) = c_x + c_{x\prime}+c_y+c_{y\prime}+c_{xy}$.

    From lemma \ref{finiteCostConstraintLemma}, we know that $c_x + c_{x\prime}+c_y+c_{y\prime}$ is finite because of constraints (9) and (10). 

    Similarly, observe that by constraints (12) through (15), $|\gamma_{(i, j)}|\leq 2$ because $\gamma_{at_x(i)}^{(x)},\gamma_{at_y(i)}^{(y)}\in [-1, 1]$. Because of constraint (11), this means that $c_{xy}\leq 2m$, where $m$ is the total number of distinct assignment transitions in $L$, which is finite because $L$ is constructed from a finite transition alphabet. This completes the proof.
\end{proof}

\subsubsection{Couplings for GDiPA}

We introduce a two-variable analogue to DiPA, which allows us to reason about counterexamples more easily. 

\begin{defn}
    A GDiPA $A$ is an 8-tuple $(Q, \Sigma, \mathcal{C}, \Gamma, q_{init}, X, P, \delta)$ where
    \begin{itemize}
        \item $Q$ is a finite set of locations partitioned into input locations $Q_{in}$ and non-input locations $Q_{non}$. 
        \item $\Sigma = \RR$ is the input alphabet
        \item $\mathcal{C} = \mathcal{C}^{(2)}$ is a set of guard conditions
        \item $\Gamma$ is a finite output alphabet
        \item $q_{init}\in Q$ is the initial location
        \item $X = \{\texttt{x}, \texttt{y}, \texttt{insample}^{(x)}, \texttt{insample}^{(x)}\prime, \texttt{insample}^{(y)}, \texttt{insample}^{(y)}\prime\}$ is a set of variables
        \item $P: Q\to \QQ\times \QQ^{\geq 0}\times \QQ\times  \QQ^{\geq 0}$ is a parameter function that assigns sampling parameters for the Laplace distribution for each location
        \item $\delta:(Q\times \mathcal{C})\to (Q\times (\Gamma \cup \{\texttt{insample}^{(x)}, \texttt{insample}^{(x)}\prime, \texttt{insample}^{(y)}, \texttt{insample}^{(y)}\prime\})\times \{0, 1, 2\})$ is a partial transition function. 
    \end{itemize}
    In addition, $\delta$ must satisfy some additional conditions:
    \begin{itemize}
        \item \textbf{Determinism:} For any location $q\in Q$, if $\delta(q, c)$ and $\delta(q, c')$ are defined for distinct guards $c, c'$,  then $c$ and $c'$ must be logically disjoint events.

        \item \textbf{Output Distinction:} For any location $q\in Q$, if $\delta(q, c) = (q_1, o_1, b_1)$ and $\delta(q, c') = (q_2, o_2, b_2)$, for distinct guards $c, c'$, then $o_1\neq o_2$ and at least one of $o_1\in \Gamma$ and $o_2\in \Gamma$ is true.

        \item \textbf{Initialization:} The initial location $q_0$ has only one outgoing transition of the form $\delta(q_0, \texttt{true}) = (q_1, o, 1)$ and $q_1$ has only one outgoing transition of the form $\delta(q_1, \texttt{true}) = (q, o', 2)$.

        \item \textbf{Non-input transition:} From any $q\in Q_{non}$, if $\delta(q, c)$ is defined, then $c=\texttt{true}$.
    \end{itemize}
\end{defn}

Just as with DiPAs and Programs, we can equivalently define a GDiPA as regular language that can be described as a finite union of 2-variable looping branches over a valid 2v-transition alphabet $\Sigma_T$. 

Like the single variable case, whenever the privacy constraint system is not satisfiable for a 2v-program, we can identify at least one of four types of graph structures in the corresponding GDiPA.

\begin{lemma}
    If no coupling strategy for a 2v-looping branch $L$ satisfies the privacy constraint system, then there exists a leaking cycle, non-cancelling leaking pair, disclosing cycle, or privacy violating path in a variable in $L$.
\end{lemma}
\begin{proof}
    Suppose that we have some maximally satisfied coupling strategy $C$ for $L$. There must be some constraint that is violated by $C$. Note that if constraint (11) is violated, then there must be a leaking cycle in $L$ since we only allow cross-couplings between assignment transitions. 

    Thus, we can assume that constraint (11) is not violated. 

    By lemma \ref{ProgramCounterexampleLemma}, there must then be either a leaking cycle, leaking pair, disclosing cycle, or privacy violating path with respect to a single variable. 

    We will show that, if there only exist leaking pairs in $L$, then at least one leaking pair must be a non-cancelling leaking pair. 

    For the sake of contradiction, suppose that every leaking pair $\kappa, \kappa'$ in $L$ is a cancelling leaking pair. 

    By definition, this means that for every two transitions $t_i, t_j$ in $\kappa, \kappa'$, $at_x(i) = at_x(j)$ and $at_y(i) = at_y(j)$.

    Without loss of generality, we will assume that every non-$\texttt{true}$ transition in $\kappa$ must either have guard $\lguard[\texttt{x}]\land\gguard[\texttt{y}]$ or $\lguard[\texttt{x}]\lor\gguard[\texttt{y}]$. Thus, every non-$\texttt{true}$ transition in $\kappa'$ must either have guard $\gguard[\texttt{x}]\land\lguard[\texttt{y}]$ or $\gguard[\texttt{x}]\lor\lguard[\texttt{y}]$, respectively. 

    Let $t_i$ be an arbitrary non-$\texttt{true}$ transition in $\kappa$ and $t_j$ be an arbitrary non-$\texttt{true}$ transition in $\kappa'$.

    Consider the case where $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $c_j = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$; the other case is symmetric.

    Observe that at least one of $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$ or $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$ must be true. Suppose that $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$. The case where $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$ is symmetric. 

    Then we can set $\gamma_{at_x(i)} = -1$, $\gamma_{at_y(i)}=1$, and $\gamma_{(at_x(i), at_y(i))} =  -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$. 
    
    Because there do not exist disclosing cycles, leaking cycles, or privacy violating paths in either variable, this cannot violate any further constraints. Thus, $C$ is not maximal, which is our contradiction, so $L$ must contain either a leaking cycle, disclosing cycle, privacy violating path, or non-cancelling leaking pair in at least one variable.
\end{proof}

We also extend the DiPA counterexample results to show that the presence of any these four graph structures in a GDiPA must lead to a violation of privacy, which allows us to conclude that, even with two variables, coupling proofs are complete for 2v-programs.

\begin{lemma}
    If there exists a leaking cycle, disclosing cycle, or privacy violating path in a single variable or a non-cancelling leaking pair in a single variable in a GDiPA $A$, then $A$ is not $dvarepsilon$-differentially private for any $d>0$. 
\end{lemma}

\begin{thm}
    A GDiPA $A$ is $d\varepsilon$-differentially private for some $d>0$ if and only if there exists a valid and finite cost coupling strategy for every looping branch of $A$. 
\end{thm}

\subsection{Beyond Two Variables}

It is straightforward to extend the definitions of 2v-transitions, paths, looping branches, etc. to more than two variables; it is additionally straightforward to extend results like lemma \ref{mvParallelCouplingsLemma} to apply more than two variables. However, it is not immediately clear how cross-couplings would be extended to additional variables;
one obvious possibility is to allow for cross-couplings between \textit{all} possible pairs, but the completeness result likely would not generalize in the same fashion. 

\section{Conclusion}
We have shown how to use coupling techniques to prove privacy for a class of SVT-like programs first defined in \cite{chadhaLinearTimeDecidability2021} and discovered that couplings additionally characterize this class. We additionally showed that this can be done tractably, and that couplings can help provide lower bounds on privacy costs of these algorithms. 

Future work most naturally would focus on extensions of the program model. For the model, potential areas include removing the requirement for output to be deterministic of a path through the automaton, which would allow for algorithms such as Report Noisy Max to be captured by the model. Similarly, the alphabet of the automaton could be expanded to incorporate more than comparisons between two real numbers. 
Such extensions would naturally also require extensions of the class of couplings we define here, which are limited to ``shifts''. 

Additionally, we believe that couplings should completely characterize GDiPAs as well as DiPAs; proving this requires showing that a lack of well-formedness in any single variable generates a counterexample to privacy. 
In this vein, we would like to explore using couplings to \textit{disprove} privacy; the fact that shift couplings completely characterize DiPAs hints at the possibility of ``anti-couplings'' to generate counterexamples.