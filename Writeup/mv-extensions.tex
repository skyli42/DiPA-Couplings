
\section{Program Model Extensions - Multivariable Programs}


\sky{this intro section is kind of orphaned - move it to the intro / somewhere else maybe? and just focus this section on multivariable programs}

The class of programs we have defined is rather limited, leading to the natural question of whether our results can be extended to more powerful program models. 

Some `natural' extensions of DiPA end up reducing directly to DiPA. For example, we considered an extension of DiPA that included a single integral ``counter'' variable $n$; this program model also allowed for branching conditional on $n$ being greater than a threshold value. 
We discovered that every DiPA equipped with a counter can be rewritten as a standard DiPA by using a power set-style automata construction. \sky{is more elaboration here necessary?}

However, there are other extensions that warrant further study. In particular, we extend our program model to allow for an arbitrary finite number of threshold variables.

\subsection{Multivariable Transitions}

We begin by defining a multiple-variable transition, as in the single variable case. 

\begin{defn}[$k$-variable guards]
    Let $\texttt{x}_1, \ldots \texttt{x}_k$ be real-valued program variables. Then a \textbf{$k$-variable guard} is a boolean statement $c = c^{(\texttt{x}_1)}\oplus_1 c^{(\texttt{x}_2)}\oplus_2\ldots\oplus_{k-1}c^{(\texttt{x}_k)}$ where for all $i$, \begin{itemize}
        \item $c^{(\texttt{x}_i)}\in \{\texttt{true}, \mvlguard[\texttt{x}_i], \mvgguard[\texttt{x}_i]\}$
        \item $\oplus_i \in \{\land, \lor\}$
    \end{itemize}
    Without loss of generality, we will assume that every $k$-variable guard is in its most simplified form. 
    
    
    % For example, we will disallow any guards of the form $c = \ldots \texttt{true}\lor \lguard[\texttt{x}_i]\ldots$, since the guard would simplify to $\texttt{true}$ (in which case, we suppose that for all $i$, $c^{(\texttt{x}_i)} = \texttt{true}$ and $\oplus_i = \land$). 

    Let $\mathcal{C}^{(k)}$ be the set of all possible guards with $k$ variables $\texttt{x}_1, \ldots \texttt{x}_k$.
\end{defn}

\sky{the associativity details of the guard have to be defined - we can assume left-associative or allow for any possible groupings; I think the results don't care about the actual grouping as long as its fixed}

\begin{defn}[$k$-variable transitions]
    A $k$-variable transition ($k$v-transition) is a tuple $(c, \sigma, \tau)$ where \begin{itemize}
        \item $c\in\mathcal{C}^{(k)}$ is a transition guard.
        \item $\sigma\in\Gamma\cup\{\texttt{insample}^{(\texttt{x}_1)}, \ldots, \texttt{insample}^{(\texttt{x}_k)}, \texttt{insample}'\}$ is the output of the transition
        \item $\tau \in \{0\} \cup [k]$ indicates whether to assign $\texttt{insample}^{(\texttt{x}_\tau)}$ into no variable (when $\tau = 0$) or $\texttt{x}_\tau$. In particular, note that only a single variable can be assigned into at a time and that every variable $\texttt{x}_i$ can only take its ``corresponding'' input value $\texttt{insample}^{(\texttt{x}_i)}$. 
    \end{itemize}
\end{defn}

As with single variable transitions, we associate every transition $t$ with two real-valued noise parameters $P(t) = (d, d')$

\subsection{$k$-Variable Program Semantics}

$k$-variable transitions semantically operate analogously to single variable transitions. Given some threshold values $\texttt{x}_i$ and a transition $t = (c, \sigma, \tau)$, let $P(t) = (d, d')$. Then $t$ will first read in a real number input $\texttt{in}$, 
sample $k$ \textbf{independent} random variables $z^{(\texttt{x}_1)}\sim\Lap(0, \frac{1}{d\varepsilon}),\ldots, z^{(\texttt{x}_k)}\sim\Lap(0, \frac{1}{d\varepsilon})$ for comparing a noised version of the input to each threshold variable as well as one random variable $z' \sim\Lap(0, \frac{1}{d\varepsilon})$ to potentially be used for outputting a re-noised version of the input. 

Using these noise variables, the transition then assigns $k$ variables $\texttt{insample}^{(\texttt{x}_i)} = \texttt{in} + z^{(x)}$ and an additional variable $\texttt{insample}' = \texttt{in} + z'$. 
If the guard $c$ is satisfied when comparing $\texttt{insample}^{(\texttt{x}_i)}$ to $\texttt{x}_i$ for all $i$, then the transition outputs $\sigma$ and, if $\tau\neq 0$, reassigns $\texttt{x}_{\tau} = \texttt{insample}^{(\texttt{x}_\tau)}$.

More formally, a program state is a tuple consisting of values for every threshold variable $\texttt{x}_i$ and an output value. Let $S = dist(\RR^k\times (\Gamma\cup \RR)^*)$ be the set of distributions over all possible program states. As expected, every possible input is simply an element of $\RR$. 

Then the semantics of a $k$v-transition $t$ can be defined as a function $\Phi_t: dist_\downarrow(S)\times \RR\to dist_\downarrow(S)$ that maps an initial program state and an input to a distribution of subsequent program states.

The precise semantics are defined analogously to the single variable case. 

We again denote the probability that a transition $t=(c, \sigma, \tau)$ outputs a specific measurable output event $o$ as $\PP[\vec{\texttt{x}}, t, \texttt{in}, o]$, where $\vec{\texttt{x}}\in \RR^k$ is a vector of initial values of all threshold values $\texttt{x}_i$, $\texttt{in}\in \RR$ is a real-valued input, and $o\subseteq \Gamma\cup\RR$ is a possible measurable output event of $t$.

Specifically, if $\vec{\texttt{x}}$ is a distribution over $\RR^k$ and $o$ is a measurable output event of $t$, then $\PP[\vec{\texttt{x}}, t, \texttt{in}, o]$ is the marginal of $\Phi_t((\vec{\texttt{x}}, \lambda), \texttt{in})$ on $(\cdot, o)$.

\subsection{Multivariable Couplings}

In this section, we introduce two methods for constructing two variable couplings for $k$v-transitions; one method combines couplings in parallel across each variable and the other couples different variables together. 

We begin by showing that if we can create couplings for each variable in isolation, then we can immediately create a coupling for a combined $k$v-transition. 

First, we define what it means to isolate a variable in a transition: 

\begin{defn}[Isolating a variable]
    Let $t = (c, \sigma, \tau)$ be a $k$-variable transition. For all $i$, $t^{(\texttt{x}_i)}$ is the single variable transition $t^{(\texttt{x}_i)} = (c^{(\texttt{x}_i)}, \sigma^{(\texttt{x}_i)}, \tau^{(\texttt{x}_i)})$, where $c^{(\texttt{x}_i)}$ is the $\texttt{x}_i$-component of $c$ as defined above, $\sigma^{(\texttt{x}_i)} = \begin{cases}
        \sigma & \sigma \in \Gamma\\
        \sigma & \sigma = \texttt{insample}^{(\texttt{x}_i)}\\
        \bot & \text{otherwise}
    \end{cases}$ and $\tau^{(\texttt{x}_i)} = \begin{cases}
        \texttt{true} & \tau = i\\
        \texttt{false} & \tau \neq i
    \end{cases}$, where $\bot$ is a unique ``junk'' symbol. We call $t^{(\texttt{x}_i)}$ the $\texttt{x}_i$-\textbf{isolated} version of $t$. 
\end{defn}

By lemma \ref{simplifiedIndTransitionCoupling}, we know that, given a $k$v-transition $t$, we can create couplings for each $\texttt{x}_i$-isolated version of $t$. We demonstrate that this is sufficient to create couplings for $t$ as a whole. 

As in the single variable case, we create couplings from \textbf{coupling strategies}, i.e. a collection of shifts $\gamma_{x_1}, \ldots, \gamma_{x_k}, \gamma_t^{(x_1)}, \ldots, \gamma_t^{(x_k)}, \gamma_t'$. Such a collection is valid if it satisfies the constraints below. 

\begin{lemma}\label{simplifiedMvParallelCouplingsLemma}
    For all $\varepsilon>0$, for any $k$v-transition $t$, measurable output event $\sigma$ of $t$, and adjacent inputs $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$, if we are given $2k+1$ real number ``shifts'' $\gamma_{x_1}, \ldots, \gamma_{x_k}, \gamma_t^{(x_1)}, \ldots, \gamma_t^{(x_k)}, \gamma_t'$ such that for all $1\leq i\leq k$, \[
        \begin{cases}
            \gamma_t^{(x_i)}\leq\gamma_{x_i} & c = \lguard[\texttt{x}_i]\\
            \gamma_t^{(x_i)}\geq\gamma_{x_i} & c = \gguard[\texttt{x}_i]\\
            \gamma_t^{(x_i)}=0 & \sigma = \texttt{insample}^{(\texttt{x}_i)}\\
            \gamma_t'=0 & \sigma = \texttt{insample}'
      \end{cases},
      \]
      then we can construct an approximate lifting that proves $\PP[\vec{X}\brangle{1}, t, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\vec{X}\brangle{2}, t, \texttt{in}\brangle{2}, \sigma]$ for some bounded $d>0$ and initial threshold Laplace-distributed variables $\vec{X}\brangle{1}$, $\vec{X}\brangle{2}$. 
\end{lemma}

A more precise version can be found as lemma \ref{mvParallelCouplingsLemma} in the appendix.

This provides an extremely straightforward method of combining coupling strategies for different variables together; indeed, this specific result is immediately extensible to an arbitrary number of variables. 

\sky{this might be redundant}
\begin{cor}
    For a $k$v-transition $t$, if, for all $1\leq i\leq k$, there exists a coupling strategy $C_i$ such that $C_i$ is a valid coupling strategy for the isolated transition $t^{(x_i)}$, then there exists a valid coupling strategy $C$ for $t$ such that $cost(C)\leq \sum_{i=1}^k cost(C_i)$.
\end{cor}

\subsubsection{Cross-Couplings}

We introduce cross-couplings, which couple together \textit{different} program variables to produce valid approximate liftings. 

\begin{lemma}\label{mvCrossCoupling}
    Let $\vec{X}\brangle{1} = (X_1\brangle{1}, \ldots X_k\brangle{1})$ where $X_i\brangle{1}\sim \Lap(\mu_i\brangle{1}, \frac{1}{d_x\varepsilon})$ are independent random variables and $\vec{X}\brangle{2} = (X_1\brangle{2}, \ldots X_k\brangle{2})$ where $X_i\brangle{2}\sim \Lap(\mu_{x_i}\brangle{2}, \frac{1}{d_{x_i}\varepsilon})$ are independent random variables be such that, for all $i$, $\mu_i\brangle{1}\sim \mu_i\brangle{2}$.

    Then for any valid coupling strategy $\gamma_{x_1}, \ldots, \gamma_{x_k}, \gamma_t^{(x_1)}, \ldots, \gamma_t^{(x_k)}, \gamma_t'$ for a transition $t = (c, \sigma,\tau)$, if one of the following is true: \begin{itemize}
        \item The boolean expression produced from $c$ by setting all $\texttt{insample}^{(\texttt{x}_i)}$ equal to each other and setting $\texttt{x}_i = \mu_i\brangle{1}$ for all $i$ is a contradiction.
        \item The boolean expression produced from $c$ by setting all $\texttt{insample}^{(\texttt{x}_i)}$ equal to each other and setting $\texttt{x}_i = \mu_i\brangle{2}-\gamma_{x_i}$ for all $i$ is a tautology.
    \end{itemize}
    then we can construct an approximate lifting that proves $\PP[\vec{X}\brangle{1}, t, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\vec{X}\brangle{2}, t, \texttt{in}\brangle{2}, \sigma]$ for some constant $d>0$ dependent only on $d_x$ and $\gamma$. 
\end{lemma}

We note that cross couplings require every single component of the initial variable distribution to have the same spread parameter.

Cross couplings allow us to construct liftings for certain transitions ``for free'' in a manner compatible with existing liftings, dependent on the initial threshold distributions. In particular, this construction applies to transitions whose guards correspond to checking if an input is within either the empty set or the entire real line, which are either always true or always false. 

\sky{make this a definition?}
We say that a collection of means $\{\mu_i\brangle{1}, \mu_i\brangle{2}\}_{i=1}^k$ and shifts $\gamma_{x_1},\ldots,\gamma_{x_k}$ \textbf{allow for a cross coupling} for a transition $t$ if either of the conditions in the above lemma are satisfied for $\mu$ and $\gamma$. 

\begin{defn}[$k$-variable paths]
    A $k$-variable path ($k$v-path) is a finite string of $k$v-transitions. Analogously to single variable paths, we call a $k$v-path $\rho = t_0t_1\ldots t_{n-1}$, \textbf{complete} if, for all $0\leq i < k$, $t_i = (\texttt{true}, \sigma_i, i+1)$ for some $\sigma_i$.
\end{defn}

The semantics of a $k$v-path are again defined exactly by composing the semantics of each individual transition in the path; we will again denote the probability of a path $\rho$ outputting a specific input $\sigma$ given initial threshold distributions $\vec{\texttt{x}}$ and input sequence $\texttt{in}$ as $\PP[\vec{\texttt{x}}, \rho, \texttt{in}, \sigma]$, which we shorthand to $\PP[\rho, \texttt{in}, \sigma]$ when $\rho$ is complete.

Analogously to single variable paths, we will use the notation $t_{at_j(i)}$ to refer to the assignment transition for variable $\texttt{x}_j$ that immediately precedes transition $t_i$ within a path. 

As previously noted, cross couplings require that the spread parameter of threshold variables are identical across variables; we thus say that a path $\rho = t_0\ldots t_{n-1}$ \textbf{allows for cross couplings} if there exists some constant $d_{at}>0$ such that, for every assignment transition $t_i$ of $\rho$, $P(t_i) = (d_{at}, d'_i)$. 


Combining our ``parallel'' and ``cross'' coupling strategies gives us the major lemma for multivariable path couplings.

\begin{lemma}\label{mvPathCouplingLemma}
    Let $\rho = t_0\ldots t_{n-1}$ be a complete $k$v-path of length $n$ where $t_i = (c_i, \sigma_i, \tau_i)$ and $P(t_i) = (d_i, d'_i)$ for all $i$. 
    Let $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ be arbitrary adjacent input sequences of length $n$. Additionally, fix some potential output $\sigma$ of $\rho$ of length $n$ and let $\sigma\brangle{1}$, $\sigma\brangle{2}$ be random variables representing possible outputs of $\rho$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. 

    Then $\forall \varepsilon>0$ and for all $\{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{n-1}$ that, for all $0\leq i\leq n-1$ and $1\leq j\leq k$ satisfy the following constraints:\begin{enumerate}
        \item If $c_i$ is satisfied in run $\brangle{1}$, then $c_i$ is satisfied in run $\brangle{2}$; i.e. at least one of the following is true:\begin{enumerate}
            \item $\{\texttt{in}_{at_1(i)}\brangle{1}, \texttt{in}_{at_1(i)}\brangle{2}, \ldots, \texttt{in}_{at_k(i)}\brangle{1}, \texttt{in}_{at_k(i)}\brangle{2}\}$ and $\gamma_{at_1(i)}^{(\texttt{x}_1)}, \ldots, \gamma_{at_k(i)}^{(\texttt{x}_k)}$ allow for a cross coupling for $t_i$.
            \item For all $1\leq j \leq k$, if $c_i^{(\texttt{x}_j)} = \mvlguard[\texttt{x}_j]$, then $\gamma_i^{(\texttt{x}_j)}\leq \gamma^{(\texttt{x}_j)}_{at_j(i)}$ and if $c_i^{(\texttt{x}_j)} = \mvgguard[\texttt{x}_j]$, then $\gamma_i^{(\texttt{x}_j)}\geq \gamma^{(\texttt{x}_j)}_{at_j(i)}$.
            \item \sky{could be worth including the explicit $c_i =\texttt{true}$ case for clarity even if its technically covered already}
        \end{enumerate}
        \item If $t_i$ outputs the specific value $o_i$ in run $\brangle{1}$, then $t_i$ also outputs $o_i$ in run $\brangle{2}$; i.e. both of the following must be true: \begin{enumerate}
            \item If $\sigma_i = \texttt{insample}^{(\texttt{x}_j)}$, then $\gamma_i^{(\texttt{x}_j)}=0$
            \item If $\sigma_i = \texttt{insample}'$, then $\gamma_i'=0$
        \end{enumerate}
    \end{enumerate}
     we can construct an approximate lifting that proves $\PP[\rho, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\rho, \texttt{in}\brangle{2}, \sigma]$ for $d = \sum_{i=0}^{n-1}\left(|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}-\gamma_i'|d_i'+\sum_{j=1}^k|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}-\gamma_i^{(\texttt{x}_j)}|d_i\right)$.
\end{lemma}

\begin{proof}
    Follows from lemmas \ref{simplifiedMvParallelCouplingsLemma} and \ref{mvCrossCoupling} exactly as lemma \ref{multTransitionsCouplingProof} follows from lemma \ref{indTransitionCoupling}.
\end{proof}

This leads to a natural definition of coupling strategies for $k$v-paths:

\begin{defn}[$k$-variable Coupling Strategies]
    A $k$v-coupling strategy for a $k$v-path $\rho$ of length $n$ is a collection of shifts $\{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{n-1}$ such that every $\{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{n-1}$ is a function of two adjacent input sequences $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ with range $[-1, 1]$. 
    We call a coupling strategy \textbf{valid} if, for \textbf{all} input sequences $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$, it satisfies the constraints in lemma \ref{mvPathCouplingLemma}.
\end{defn}

We denote the cost of a coupling strategy $C=\{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{n-1}$ for a $k$v-path $\rho$ as $cost(C) = \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n-1}\left(|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}-\gamma_i'|d_i'+\sum_{j=1}^k|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}-\gamma_i^{(\texttt{x}_j)}|d_i\right)$.

\subsection{Syntactic structure}

As in the single variable case, we model programs that can be represented by a finite control flow graph $G = (V, E)$, where $V$ is a finite set of program locations, and each edge $e\in E$ is labeled with a function $T(e)$ such that $T(e)$ is a $k$v-transition. 

For clarity, we call control flow graphs for $k$-variable programs $k$v-CFGs. 

\begin{defn}
    A $k$v-CFG $G = (V, E)$ is \textbf{proper} if it satisfies the following conditions: 
    \begin{itemize}
        \item \textbf{Initialization:} Every program variable is initialized at the beginning of a program. In other words, $V$ contains unique initial locations $\ell_{init}^{(x_1)}, \ldots \ell_{init}^{(x_k)}\in V$ such that for all $1\leq i \leq k$, exactly one edge with source at $\ell_{init}^{(x_i)}$ $e_{init}^{(x_i)} = (\ell_{init}^{(x_i)}, \ell_{i+1})\in E$ such that $T(e_{init}^{(x_i)})$ is of the form $(\texttt{true}, \sigma_i, i)$ for some $\sigma_i$ 
        and, for all $1\leq i <k$, $\ell_{i+1} = \ell_{init}^{(x_{i+1})}$
        \item \textbf{Determinism:} For all locations $\ell\in V$, if there exist distinct edges $(\ell, \ell')$ labeled by $t'=(c', \sigma', \tau')$ and $(\ell, \ell')$ labeled by $t'=(c', \sigma', \tau')$ labeled by $t^* = (c^*, \sigma^*, \tau^*)$, then $c'$ and $c^*$ must be logically disjoint; i.e. the boolean expression $c' \land c^*$ must be a contradiction. 
        In particular, note that this means that if there exists an edge $(\ell, \ell')\in E$ labeled by a transition of the form $(\texttt{true}, \sigma, \tau)$, then there does not exist another edge in $E$ with source at $\ell$.
        \item \textbf{Shared Noise:} For all locations $\ell\in V$ and any two edges $(\ell, \ell')$ labeled by $t'=(c', \sigma', \tau')$ and $(\ell, \ell^*)$ labeled by $t^* = (c^*, \sigma^*, \tau^*)$, $P(t') = P(t^*)$. 
        % \item \textbf{Public Input:} For all locations $\ell\in V$, if there exists some edge $e = (\ell, \ell') \in E$ such that $e$ is labeled by a public transition, then every other edge from $\ell$ must also be labeled by a public transition. 
        \item \textbf{Cross Coupling Compatibility:} There exists some constant $d_{at}>0$ such that for every edge $e\in E$ labeled by the transition $t = (c, \sigma, \tau)$, if $\tau \neq 0$ (i.e. $t$ is an assignment transition), $P(t) = (d_{at}, d'_t)$ for some $d'_t >0$.
    \end{itemize}
\end{defn}

We will again use $\Psi(r)$ to denote the forgetful homomorphism from an execution $r$ of $G$ that drops all states from $r$ to produce a $k$v-path and say that $\{\Psi(r): r\text{ is a execution of }G\}$ is the set of $k$v-paths \textbf{generated} by a proper $k$v-CFG $G$. 

Naturally, $k$v-programs can be defined using a $k$v-CFG in analogy to the single variable case. 

\begin{defn}
    A $k$v-program $P$ is a language over a finite alphabet of $k$v-transitions generated by a proper $k$v-CFG $G$. 
\end{defn}

We again analyze the possibly infinite number of paths in a $k$v-program by decomposing a program into a finite set of \textbf{looping branches}. 

\begin{defn}[$k$-variable Looping Branches]
    A $k$v-looping branch $L$ is a union-free regular language generated by a proper $k$v-CFG $G$. 
\end{defn}

We again associate a single coupling strategy with every $k$v-looping branches:

\begin{defn}[Coupling strategy for a $k$v-looping branch]
    Let $L$ be a $k$v-looping branch generated by the graph $G_L = (V_L, E_L)$, where $m = |E_L|$. Then a coupling strategy $C = \{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{m-1}$ for $L$ is a function $C:E_L\times\RR \times\RR\to [-1, 1]^{m(k+1)}$ that computes $k+1$ shifts for each transition-labeled edge in $L$ as a function of two adjacent inputs.
\end{defn}

Observe that a coupling strategy for a $k$v-looping branch $L$ induces a coupling strategy for each $k$v-path in $L$ in the same manner as the single variable case (see definition \ref{svInducedCouplingStrategy}). 

As expected, the cost $cost(C)$ of a coupling strategy $C$ for a $k$v-looping branch $L$ is the supremum of the costs of the $k$v-path coupling strategies induced by $C$ over all paths in $L$.

We translate the constraints for finite cost from single variable looping branches: 

\begin{defn}\label{mvPrivacyConstraintSystem}
    Let $L$ be a $k$v-looping branch generated by $G_L = (V_L, E_L)$ and let $C = \{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{m-1}$ be a coupling strategy for $L$. If, for every path $\rho$ in $L$, the coupling strategy for $\rho$ induced by $C$ satisfies the constraints from lemma \ref{mvPathCouplingLemma} as well as the following constraints for all input sequences $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$ and all $i$: \begin{enumerate}
        \setcounter{enumi}{2}
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then for all $1\leq j\leq k$, $\gamma_i^{(\texttt{x}_j)} = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
    \end{enumerate}
    then we say that $C$ satisfies the privacy constraint system for $L$. 
\end{defn}

\begin{lemma}
    If a coupling strategy $C$ satisfies the privacy constraint system for a $k$v-looping branch $L$, then $cost(C)<\infty$ and $L$ is $cost(C)\varepsilon$-differentially private. 
\end{lemma}

\begin{proof}
    Because the privacy constraint system includes constraints for validity by definition, we know that $C$ is a valid coupling strategy. In particular, by lemma \ref{mvPathCouplingLemma}, this means that $C$ will produce a proof that $L$ is $cost(C)\varepsilon$-differentially private. 
    
    It remains to show that $C$ has finite cost. For every path $\rho\in L$, let $\rho^{(\texttt{x}_i)}$ be the single variable path created from $\rho$ by isolating every transition to the variable $\texttt{x}_i$. 

    Because of constraints (3) and (4), we know that, for all $\texttt{x}_i$, $\sup_{\rho\in L}\sum_{i=0}^{|\rho|-1}|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}+\gamma_i^{(\texttt{x}_i)}|d_i + |\texttt{in}\brangle{2}-\texttt{in}\brangle{1}+\gamma_i'|d_i'$ is finite by applying lemma \ref{finiteCostConstraintLemma} to $\rho^{(\texttt{x}_i)}$ and a single variable coupling strategy constructed using $(\gamma^{(\texttt{x}_i)}, \gamma')$. 

    This immediately implies that $cost(C)$ is finite as well, since there are a finite number of program variables. 
\end{proof}

Finally, we extend our single variable programs and results to $k$ variables.

\begin{defn}
    A $k$-variable program $P$ is a finite union of $k$v-looping branches such that $P$ is generated by a structured program graph $G_P$.
\end{defn}

\begin{lemma}
    If, for every looping branch $L$ in $P$, there exists a valid coupling strategy $C_L$, then $P$ is $cost(P) = (\max_{L\subseteq P} cost(C_L))\varepsilon$-differentially private. In particular, if for every $L\subseteq P$ there exists a coupling strategy for $L$ that satisfies the privacy constraint system, then $P$ is $d\varepsilon$-differentially private for some finite $d>0$.
\end{lemma}

\subsection{Counterexamples when $k=2$}

We show that in the special case when we have two variables (which we now label $\texttt{x}$ and $\texttt{y}$) the privacy constraint system for a 2v-program is complete for output-distinct programs. 

Like with the single variable case, if the privacy constraint system is unsatisfiable for a program $P$ generated by $G$, we demonstrate that there must exist specific graph structures that correspond to a violation of privacy.

In general, these graph structures directly correspond to the single variable case; indeed, with one exception, we can identify these structures by looking at the generating graph of a program \textit{isolated} to a single variable. 

We will use $G^{(\texttt{x}_i)}$ to denote the $k$v-CFG $G = (V, E)$ where each edge label $T(e)$ is replaced by the $\texttt{x}_i$-isolation of $T(e)$. 

Identifying leaking cycles, disclosing cycles, and privacy violating paths in any variable $\texttt{x}_i$ for the $\texttt{x}$-isolated graph $G$ is sufficient to produce a violation of privacy in the two variable case; we must account for a special kind of leaking pair that turns out to be provably private using cross-couplings. 

\sky{triple check this definition since it's a bit finicky}
\begin{defn}
    Let $G = (V, E)$ be a 2v-transition labeled graph with variables $\texttt{x}$, $\texttt{y}$ and let $(C, C')$ be a leaking pair in either $G^{(\texttt{x})}$ or $G^{(\texttt{y})}$ such that there is a path from $C$ to $C'$ with no assignment transitions into the other variable. For every edge $e\in E$, let $t_e = (c_e, \sigma_e, \tau_e)$ be the 2v-transition that labels $e$. 
    If one of the following is true for $C, C'$: \begin{itemize}
        \item For all $e\in C\cup C'$, $c_e \in \{\texttt{true}, \mvlguard[\texttt{x}]\land\mvgguard[\texttt{y}], \mvgguard[\texttt{x}]\land\mvlguard[\texttt{y}]\}$
        \item For all $e\in C\cup C'$, $c_e \in \{\texttt{true}, \mvlguard[\texttt{x}]\lor\mvgguard[\texttt{y}], \mvgguard[\texttt{x}]\lor\mvlguard[\texttt{y}]\}$
\end{itemize}
then we $(C, C')$ is a cancelling leaking pair. 
\end{defn}

Intuitively, the reason that cancelling leaking pairs are private is that for any threshold variable distributions with means at $\mu_x,\mu_y$, at least one of $\mu_x\geq\mu_y$ or $\mu_x\leq \mu_y$ must always be true no matter what input sequence we are given. 
Thus, for example, either all of the transitions with guard $\mvlguard[\texttt{x}]\land\mvgguard[\texttt{y}]$ or all of the transitions with guard $\mvgguard[\texttt{x}]\land\mvlguard[\texttt{y}]$ allow for a ``free'' cross coupling, while the other set of transitions can be coupled for finite cost in a standard manner.

Incorporating this exception, we show that an unsatisfiable coupling strategy still implies the presence of these ``bad'' graph structures. 

\begin{lemma}
    If no coupling strategy for a 2v-looping branch $L$ satisfies the privacy constraint system, then there exists a leaking cycle, non-cancelling leaking pair, disclosing cycle, or privacy violating path in either $\texttt{x}$ or $\texttt{y}$ in $L$.
\end{lemma}
\begin{proof}
    Suppose that we have some maximally satisfied coupling strategy $C$ for $L$. There must be some constraint that is violated by $C$. Note that if constraint (11) is violated, then there must be a leaking cycle in $L$ since we only allow cross-couplings between assignment transitions. 

    Thus, we can assume that constraint (11) is not violated. 

    By lemma \ref{ProgramCounterexampleThm}, there must then be either a leaking cycle, leaking pair, disclosing cycle, or privacy violating path with respect to a single variable. 

    We will show that, if there only exist leaking pairs in $L$, then at least one leaking pair must be a non-cancelling leaking pair. 

    For the sake of contradiction, suppose that every leaking pair $\kappa, \kappa'$ in $L$ is a cancelling leaking pair. 

    By definition, this means that for every two transitions $t_i, t_j$ in $\kappa, \kappa'$, $at_x(i) = at_x(j)$ and $at_y(i) = at_y(j)$.

    Without loss of generality, we will assume that every non-$\texttt{true}$ transition in $\kappa$ must either have guard $\lguard[\texttt{x}]\land\gguard[\texttt{y}]$ or $\lguard[\texttt{x}]\lor\gguard[\texttt{y}]$. Thus, every non-$\texttt{true}$ transition in $\kappa'$ must either have guard $\gguard[\texttt{x}]\land\lguard[\texttt{y}]$ or $\gguard[\texttt{x}]\lor\lguard[\texttt{y}]$, respectively. 

    Let $t_i$ be an arbitrary non-$\texttt{true}$ transition in $\kappa$ and $t_j$ be an arbitrary non-$\texttt{true}$ transition in $\kappa'$.

    Consider the case where $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $c_j = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$; the other case is symmetric.

    Observe that at least one of $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$ or $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$ must be true. Suppose that $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$. The case where $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$ is symmetric. 

    Then we can set $\gamma_{at_x(i)} = -1$, $\gamma_{at_y(i)}=1$, and $\gamma_{(at_x(i), at_y(i))} =  -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$. 
    
    Because there do not exist disclosing cycles, leaking cycles, or privacy violating paths in either variable, this cannot violate any further constraints. Thus, $C$ is not maximal, which is our contradiction, so $L$ must contain either a leaking cycle, disclosing cycle, privacy violating path, or non-cancelling leaking pair in at least one variable.
\end{proof}

Finally, through a careful analysis, we extend the single variable DiPA counterexample results to two variables to show that the presence of these bad graph structures in a generating graph $G$ for a program $P$ implies that $P$ is not differentially private. 

As in the single variable case, this result holds for the class of programs whose paths can be uniquely identified with specific outputs, which we call output-distinct (see definition \ref{outputDistinctionDef}).


\begin{lemma}
    Consider a 2v-program $P$ generated by $G$. If $G$ satisfies output distinction and there exists a leaking cycle, disclosing cycle, or privacy violating path in a single variable or a non-cancelling leaking pair in either $\texttt{x}$ or $\texttt{y}$, then $P$ is not $d\varepsilon$-differentially private for any $d>0$. 
\end{lemma}

We conclude that the privacy constraint system completely characterizes privacy even for 2 variable programs.

\begin{thm}
    A 2v-program $P$ is $d\varepsilon$-differentially private for some $d>0$ if and only if there exists coupling strategy for every looping branch of $P$ that satisfies the privacy constraint system.
\end{thm}

\subsection{Beyond Two Variables}

\sky{this will be heavily rewritten ignore for now}

It is straightforward to extend the definitions of 2v-transitions, paths, looping branches, etc. to more than two variables; it is additionally straightforward to extend results like lemma \ref{mvParallelCouplingsLemma} to apply more than two variables. However, it is not immediately clear how cross-couplings would be extended to additional variables;
one obvious possibility is to allow for cross-couplings between \textit{all} possible pairs, but the completeness result likely would not generalize in the same fashion. 

\section{Conclusion}
We have shown how to use coupling techniques to prove privacy for a class of SVT-like programs first defined in \cite{chadhaLinearTimeDecidability2021} and discovered that couplings additionally characterize this class. We additionally showed that this can be done tractably, and that couplings can help provide lower bounds on privacy costs of these algorithms. 

Future work most naturally would focus on extensions of the program model. For the model, potential areas include removing the requirement for output to be deterministic of a path through the automaton, which would allow for algorithms such as Report Noisy Max to be captured by the model. Similarly, the alphabet of the automaton could be expanded to incorporate more than comparisons between two real numbers. 
Such extensions would naturally also require extensions of the class of couplings we define here, which are limited to ``shifts''. 

Additionally, we believe that couplings should completely characterize GDiPAs as well as DiPAs; proving this requires showing that a lack of well-formedness in any single variable generates a counterexample to privacy. 
In this vein, we would like to explore using couplings to \textit{disprove} privacy; the fact that shift couplings completely characterize DiPAs hints at the possibility of ``anti-couplings'' to generate counterexamples.