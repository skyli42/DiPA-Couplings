
\section{Program Model Extensions - Multivariable Programs}

The class of programs we have defined is rather limited, leading to the natural question of whether our results can be extended to more powerful program models. 

Some `natural' extensions of DiPA end up reducing directly to DiPA. For example, we considered an extension of DiPA that included a single integral ``counter'' variable $n$; this program model also allowed for branching conditional on $n$ being greater than a threshold value. 
We discovered that every DiPA equipped with a counter can be rewritten as a standard DiPA by using a power set-style automata construction. \sky{is more elaboration here necessary?}

However, there are other extensions that warrant further study. In particular, we analyze one extension of DiPA that allows for two real-valued program variables $\texttt{x}, \texttt{y}$.

\subsection{Multivariable Transitions}

We begin by defining a multiple-variable transition, as in the single variable case. 

\begin{defn}[$k$-variable guards]
    Let $\texttt{x}_1, \ldots \texttt{x}_k$ be real-valued program variables. Then a \textbf{$k$-variable guard} is a boolean statement $c = c^{(\texttt{x}_1)}\oplus_1 c^{(\texttt{x}_2)}\oplus_2\ldots\oplus_{k-1}c^{(\texttt{x}_k)}$ where for all $i$, \begin{itemize}
        \item $c^{(\texttt{x}_i)}\in \{\texttt{true}, \mvlguard[\texttt{x}_i], \mvgguard[\texttt{x}_i]\}$
        \item $\oplus_i \in \{\land, \lor\}$
    \end{itemize}
    Without loss of generality, we will assume that every $k$-variable guard is in its most simplified form. 
    
    
    % For example, we will disallow any guards of the form $c = \ldots \texttt{true}\lor \lguard[\texttt{x}_i]\ldots$, since the guard would simplify to $\texttt{true}$ (in which case, we suppose that for all $i$, $c^{(\texttt{x}_i)} = \texttt{true}$ and $\oplus_i = \land$). 

    Let $\mathcal{C}^{(k)}$ be the set of all possible guards with $k$ variables $\texttt{x}_1, \ldots \texttt{x}_k$.
\end{defn}

\sky{the associativity details of the guard have to be defined - we can assume left-associative or allow for any possible groupings; I \textit{think} most of the results don't care about the details here}

\begin{defn}[$k$-variable transitions]
    A $k$-variable transition ($k$v-transition) is a tuple $(c, \sigma, \tau)$ where \begin{itemize}
        \item $c\in\mathcal{C}^{(k)}$ is a transition guard.
        \item $\sigma\in\Gamma\cup\{\texttt{insample}^{(\texttt{x}_1)}, \ldots, \texttt{insample}^{(\texttt{x}_k)}, \texttt{insample}'\}$ is the output of the transition
        \item $\tau \in \{0\} \cup [k]$ indicates whether to assign $\texttt{insample}^{(\texttt{x}_\tau)}$ into no variable (when $\tau = 0$) or $\texttt{x}_\tau$. In particular, note that only a single variable can be assigned into at a time and that every variable can only take its ``corresponding'' $\texttt{insample}$ value. 
    \end{itemize}
    \sky{I can never remember if $[n]$ notation includes 0 but I'm assuming it does here}
\end{defn}

As with single variable transitions, we associate every transition $t$ with two real-valued noise parameters $P(t) = (d, d')$

\subsection{$k$-Variable Program Semantics}

$k$-variable transitions semantically operate extremely similarly to single variable transitions: given some threshold values $\texttt{x}_i$ and a transition $t = (c, \sigma, \tau)$, let $P(t) = (d, d')$. Then $t$ will first read in a real number input $\texttt{in}$, 
sample $k$ \textbf{independent} random variables $z^{(\texttt{x}_1)}\sim\Lap(0, \frac{1}{d\varepsilon}),\ldots, z^{(\texttt{x}_k)}\sim\Lap(0, \frac{1}{d\varepsilon})$ for comparing a noised version of the input to each threshold variable as well as one random variable $z' \sim\Lap(0, \frac{1}{d\varepsilon})$ to potentially be used for outputting a re-noised version of the input. 

Using these noise variables, the transition then assigns $k$ variables $\texttt{insample}^{(\texttt{x}_i)} = \texttt{in} + z^{(x)}$ and an additional variable $\texttt{insample}' = \texttt{in} + z'$. 
If the guard $c$ is satisfied when comparing $\texttt{insample}^{(\texttt{x}_i)}$ to $\texttt{x}_i$ for all $i$, then the transition outputs $\sigma$ and, if $\tau\neq 0$, reassigns $\texttt{x}_{\tau} = \texttt{insample}^{(\texttt{x}_\tau)}$.

More formally, a program state is a tuple consisting of values for every threshold variable $\texttt{x}_i$ and an output value. Let $S = dist(\RR^k\times (\Gamma\cup \RR)^*)$ be the set of distributions over all possible program states. As expected, every possible input is simply an element of $\RR$. 

Then the semantics of a $k$v-transition $t$ can be defined as a function $\Phi_t: dist_\downarrow(S)\times \RR\to dist_\downarrow(S)$ that maps an initial program state and an input to a distribution of subsequent program states.

The precise semantics are defined exactly analogously to the single variable case. 

We again denote the probability that a transition $t=(c, \sigma, \tau)$ outputs a specific measurable output event $o$ as $\PP[\vec{\texttt{x}}, t, \texttt{in}, o]$, where $\vec{\texttt{x}}\in \RR^k$ is a vector of initial values of all threshold values $\texttt{x}_i$, $\texttt{in}\in \RR$ is a real-valued input, and $o\subseteq \Gamma\cup\RR$ is a possible measurable output event of $t$.

Specifically, if $\vec{\texttt{x}}$ is a distribution over $\RR^k$ and $o$ is a measurable output event of $t$, then $\PP[\vec{\texttt{x}}, t, \texttt{in}, o]$ is the marginal of $\Phi_t((\vec{\texttt{x}}, \lambda), \texttt{in})$ on $(\cdot, o)$

\sky{remove later}
\begin{defn}[Valid Transition Alphabets]
    A finite 2v-transition alphabet $\Sigma_T$ is valid if it satisfies the following conditions: 
    \begin{itemize}
        \item \textbf{Output distinction}: If there exist some $\sigma, \sigma', \tau, \tau'$ such that $(q, q', c, \sigma, \tau)\in \Sigma_T$  and $(q, q^*, c', \sigma', \tau') \in \Sigma_T$ for distinct guards $c, c'$, then $\sigma \neq \sigma'$. Additionally, at least one of $\sigma\in \Gamma$, $\sigma'\in \Gamma$ is true.
    \end{itemize}
\end{defn}

\subsection{Multivariable Couplings}

In this section, we introduce two methods for constructing two variable couplings for $k$v-transitions; one method combines couplings in parallel and the other combines couplings for different variables together. 

We begin by showing that if we can create couplings for each variable in isolation, then we can immediately create a coupling for a combined $k$v-transition. 

First, we define what it means to isolate a variable in a transition: 

\begin{defn}[Isolating a variable]
    Let $t = (c, \sigma, \tau)$ be a $k$-variable transition. For all $i$, $t^{(\texttt{x}_i)}$ is the single variable transition $t^{(\texttt{x}_i)} = (c^{(\texttt{x}_i)}, \sigma^{(\texttt{x}_i)}, \tau^{(\texttt{x}_i)})$, where $c^{(\texttt{x}_i)}$ is the $\texttt{x}_i$-component of $c$ as defined above, $\sigma^{(\texttt{x}_i)} = \begin{cases}
        \sigma & \sigma \in \Gamma\\
        \sigma & \sigma = \texttt{insample}^{(\texttt{x}_i)}\\
        \bot & \text{otherwise}
    \end{cases}$ and $\tau^{(\texttt{x}_i)} = \begin{cases}
        \texttt{true} & \tau = i\\
        \texttt{false} & \tau \neq i
    \end{cases}$, where $\bot$ is a unique ``junk'' symbol. We call $t^{(\texttt{x}_i)}$ the $\texttt{x}_i$-\textbf{isolated} version of $t$. 
\end{defn}

By lemma \ref{simplifiedIndTransitionCoupling}, we know that, given a $k$v-transition $t$, we can create couplings for each $\texttt{x}_i$-isolated version of $t$. We demonstrate that this is sufficient to create couplings for $t$ as a whole. 

\begin{lemma}\label{simplifiedMvParallelCouplingsLemma}
    For all $\varepsilon>0$, for any $k$v-transition $t$, measurable output event $\sigma$ of $t$, and adjacent inputs $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$, if we are given $2k+1$ real number ``shifts'' $\gamma_{x_1}, \ldots, \gamma_{x_k}, \gamma_t^{(x_1)}, \ldots, \gamma_t^{(x_k)}, \gamma_t'$ such that for all $1\leq i\leq k$, \[
        \begin{cases}
            \gamma_t^{(x_i)}\leq\gamma_{x_i} & c = \lguard[\texttt{x}_i]\\
            \gamma_t^{(x_i)}\geq\gamma_{x_i} & c = \gguard[\texttt{x}_i]\\
            \gamma_t^{(x_i)}=0 & \sigma = \texttt{insample}^{(\texttt{x}_i)}\\
            \gamma_t'=0 & \sigma = \texttt{insample}'
      \end{cases},
      \]
      then we can construct an approximate lifting that proves $\PP[\vec{X}\brangle{1}, t, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\vec{X}\brangle{2}, t, \texttt{in}\brangle{2}, \sigma]$ for some bounded $d>0$ and initial threshold Laplace-distributed variables $\vec{X}\brangle{1}$, $\vec{X}\brangle{2}$. 
\end{lemma}


\sky{the more technical version}
\begin{lemma}\label{mvParallelCouplingsLemma}
    Let $\vec{X}\brangle{1} = (X_1\brangle{1}, \ldots X_k\brangle{1})$ where $X_i\brangle{1}\sim \Lap(\mu_{x_i}\brangle{1}, \frac{1}{d_{x_i}\varepsilon})$ are independent random variables and $\vec{X}\brangle{2} = (X_1\brangle{2}, \ldots X_k\brangle{2})$ where $X_i\brangle{2}\sim \Lap(\mu_{x_i}\brangle{2}, \frac{1}{d_{x_i}\varepsilon})$ are independent random variables be representations of two possible initial values of $\vec{X}$, respectively.

    Let $t = (c, \sigma, \tau)$ be a $k$v-transition such that $P(t) = (d_t, d_t')$.

    Let $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$ be an arbitrary adjacent input pair and let $o\brangle{1}$, $o\brangle{2}$ be random variables representing possible outputs of $t$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. 

    Then $\forall \varepsilon>0$ and for all $\gamma_{x_1}, \ldots, \gamma_{x_k}, \gamma_t^{(x_1)}, \ldots, \gamma_t^{(x_k)}, \gamma_t'$ that satisfy the constraints \[
        \begin{cases}
            \gamma_t^{(x_i)}\leq\gamma_{x_i} & c = \lguard[\texttt{x}_i]\\
            \gamma_t^{(x_i)}\geq\gamma_{x_i} & c = \gguard[\texttt{x}_i]\\
            \gamma_t^{(x_i)}=0 & \sigma = \texttt{insample}^{(\texttt{x}_i)}\\
            \gamma_t'=0 & \sigma = \texttt{insample}'
      \end{cases}
      \] for all $1\leq i\leq k$, the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for 
      $d = \sum_{i=1}^k\left(|\mu_{x_i}\brangle{1}-\mu_{x_i}\brangle{2}+\gamma_{x_i}|d_{x_i}+|\texttt{in}\brangle{1}-\texttt{in}\brangle{2}+\gamma_t^{(x_i)}|d_t\right)+|\texttt{in}\brangle{1}-\texttt{in}\brangle{2}+\gamma_t'|d_t'$.
\end{lemma}
\begin{proof}
    From lemma \ref{indTransitionCoupling}, we know that if these constraints are satisfied, we can create liftings such that for all $i$, $c^{(\texttt{x}_i)}$ is satisfied in run $\brangle{1}\implies c^{(\texttt{x}_i)}$ is satisfied in run $\brangle{2}$.
    
    Because $c$ is made of conjunctions and disjunctions of all $c^{(\texttt{x}_i)}$, by [basic logical rules]\sky{is more specificity needed?}, this means that if $c$ is satisfied in run $\brangle{1}$, then $c$ must also be satisfied in $\brangle{2}$. 

    Finally, as before, if $\sigma \in \{\texttt{insample}^{(x_1)}\ldots \texttt{insample}^{(x_k)},\texttt{insample}'\}$, then for all $\sigma$, $o\brangle{1}=\sigma \implies o\brangle{2} = \sigma$. Further, note that we only need to couple $\texttt{insample}'\brangle{1}$ and $\texttt{insample}'\brangle{2}$ once for all variables. By simply adding up the costs from lemma \ref{indTransitionCoupling}, we complete the proof.
\end{proof}

This provides an extremely straightforward method of combining coupling strategies for different variables together; indeed, this specific result is immediately extensible to an arbitrary number of variables. 

As in the single variable case, we call a collection of shifts $\gamma_{x_1}, \ldots, \gamma_{x_k}, \gamma_t^{(x_1)}, \ldots, \gamma_t^{(x_k)}, \gamma_t'$ a \textbf{coupling strategy}, which is valid if it satisfies the above constraints. 

\sky{this might be redundant}
\begin{cor}
    For a $k$v-transition $t$, if, for all $1\leq i\leq k$, there exists a coupling strategy $C_i$ such that $C_i$ is a valid coupling strategy for the isolated transition $t^{(x_i)}$, then there exists a valid coupling strategy $C$ for $t$ such that $cost(C)\leq \sum_{i=1}^k cost(C_i)$.
\end{cor}


\textbf{Cross-Couplings}

\begin{lemma}\label{mvCrossCoupling}
    Let $\vec{X}\brangle{1} = (X_1\brangle{1}, \ldots X_k\brangle{1})$ where $X_i\brangle{1}\sim \Lap(\mu_i\brangle{1}, \frac{1}{d_x\varepsilon})$ are independent random variables and $\vec{X}\brangle{2} = (X_1\brangle{2}, \ldots X_k\brangle{2})$ where $X_i\brangle{2}\sim \Lap(\mu_{x_i}\brangle{2}, \frac{1}{d_{x_i}\varepsilon})$ are independent random variables be such that, for all $i$, $\mu_i\brangle{1}\sim \mu_i\brangle{2}$.

    Then for any valid coupling strategy $\gamma_{x_1}, \ldots, \gamma_{x_k}, \gamma_t^{(x_1)}, \ldots, \gamma_t^{(x_k)}, \gamma_t'$ for a transition $t = (c, \sigma,\tau)$, if one of the following is true: \begin{itemize}
        \item The boolean expression produced from $c$ by setting all $\texttt{insample}^{(\texttt{x}_i)}$ equal to each other and setting $\texttt{x}_i = \mu_i\brangle{1}$ for all $i$ is a contradiction.
        \item The boolean expression produced from $c$ by setting all $\texttt{insample}^{(\texttt{x}_i)}$ equal to each other and setting $\texttt{x}_i = \mu_i\brangle{2}-\gamma_{x_i}$ for all $i$ is a tautology.
    \end{itemize}
    then we can construct an approximate lifting that proves $\PP[\vec{X}\brangle{1}, t, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\vec{X}\brangle{2}, t, \texttt{in}\brangle{2}, \sigma]$ for some constant $d>0$ dependent only on $d_x$ and $\gamma$. 
\end{lemma}

We note that cross couplings require every single component of the initial variable distribution to have the same spread parameter.

Cross couplings allow us to construct liftings for certain transitions ``for free'' in a manner compatible with existing liftings, dependent on the initial threshold distributions. In particular, this construction applies to transitions whose guards correspond to checking if an input is within either the empty set or the entire real line, which are either always true or always false. 

We say that a collection of means $\{\mu_i\brangle{1}, \mu_i\brangle{2}\}_{i=1}^k$ and shifts $\gamma_{x_1},\ldots,\gamma_{x_k}$ \textbf{allow for a cross coupling} for a transition $t$ if either of the conditions in the above lemma are satisfied for $\mu$ and $\gamma$. 

\begin{defn}[$k$-variable paths]
    A $k$-variable path ($k$v-path) is a finite string of $k$v-transitions. Analogously to single variable paths, we call a $k$v-path $\rho = t_0t_1\ldots t_{n-1}$, \textbf{complete} if, for $0\leq i < k$, $t_i = (\texttt{true}, \sigma_i, i+1)$ for some $\sigma_i$.
\end{defn}

The semantics of a $k$v-path are again defined exactly by composing the semantics of each individual transition in the path; we will again denote the probability of a path $\rho$ outputting a specific input $\sigma$ given initial threshold distributions $\vec{\texttt{x}}$ and input sequence $\texttt{in}$ as $\PP[\vec{\texttt{x}}, \rho, \texttt{in}, \sigma]$, which we shorthand to $\PP[\rho, \texttt{in}, \sigma]$ when $\rho$ is complete.

Analogously to single variable paths, we will use the notation $t_{at_j(i)}$ to refer to the assignment transition for variable $\texttt{x}_j$ that immediately precedes transition $t_i$ within a path. 

As previously noted, cross couplings require that the spread parameter of threshold variables are identical across variables; we thus say that a path $\rho = t_0\ldots t_{n-1}$ \textbf{allows for cross couplings} if there exists some constant $d_{at}>0$ such that, for every assignment transition $t_i$ of $\rho$, $P(t_i) = (d_{at}, d'_i)$. 


Combining our ``parallel'' and ``cross'' coupling strategies gives us the major lemma for multivariable path couplings.

\begin{lemma}\label{mvPathCouplingLemma}
    Let $\rho = t_0\ldots t_{n-1}$ be a complete $k$v-path of length $n$ where $t_i = (c_i, \sigma_i, \tau_i)$ and $P(t_i) = (d_i, d'_i)$ for all $i$. 
    Let $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ be arbitrary adjacent input sequences of length $n$. Additionally, fix some potential output $\sigma$ of $\rho$ of length $n$ and let $\sigma\brangle{1}$, $\sigma\brangle{2}$ be random variables representing possible outputs of $\rho$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. 

    Then $\forall \varepsilon>0$ and for all $\{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{n-1}$ that, for all $0\leq i\leq n-1$ and $1\leq j\leq k$ satisfy the following constraints:\begin{enumerate}
        \item If $c_i$ is satisfied in run $\brangle{1}$, then $c_i$ is satisfied in run $\brangle{2}$; i.e. at least one of the following is true:\begin{enumerate}
            \item $\{\texttt{in}_{at_1(i)}\brangle{1}, \texttt{in}_{at_1(i)}\brangle{2}, \ldots, \texttt{in}_{at_k(i)}\brangle{1}, \texttt{in}_{at_k(i)}\brangle{2}\}$ and $\gamma_{at_1(i)}^{(\texttt{x}_1)}, \ldots, \gamma_{at_k(i)}^{(\texttt{x}_k)}$ allow for a cross coupling for $t_i$.
            \item For all $1\leq j \leq k$, if $c_i^{(\texttt{x}_j)} = \mvlguard[\texttt{x}_j]$, then $\gamma_i^{(\texttt{x}_j)}\leq \gamma^{(\texttt{x}_j)}_{at_j(i)}$ and if $c_i^{(\texttt{x}_j)} = \mvgguard[\texttt{x}_j]$, then $\gamma_i^{(\texttt{x}_j)}\geq \gamma^{(\texttt{x}_j)}_{at_j(i)}$.
            \item \sky{could be worth including the explicit $c_i =\texttt{true}$ case for clarity even if its technically covered already}
        \end{enumerate}
        \item If $t_i$ outputs the specific value $o_i$ in run $\brangle{1}$, then $t_i$ also outputs $o_i$ in run $\brangle{2}$; i.e. both of the following must be true: \begin{enumerate}
            \item If $\sigma_i = \texttt{insample}^{(\texttt{x}_j)}$, then $\gamma_i^{(\texttt{x}_j)}=0$
            \item If $\sigma_i = \texttt{insample}'$, then $\gamma_i'=0$
        \end{enumerate}
    \end{enumerate}
     we can construct an approximate lifting that proves $\PP[\rho, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\rho, \texttt{in}\brangle{2}, \sigma]$ for $d = \sum_{i=0}^{n-1}\left(|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}-\gamma_i'|d_i'+\sum_{j=1}^k|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}-\gamma_i^{(\texttt{x}_j)}|d_i\right)$.
\end{lemma}

\begin{proof}
    Follows from lemmas \ref{simplifiedMvParallelCouplingsLemma} and \ref{mvCrossCoupling} exactly as lemma \ref{multTransitionsCouplingProof} follows from lemma \ref{indTransitionCoupling}.
\end{proof}

This leads to a natural definition of coupling strategies for $k$v-paths:

\begin{defn}[$k$-variable Coupling Strategies]
    A $k$v-coupling strategy for a $k$v-path $\rho$ of length $n$ is a collection of shifts $\{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{n-1}$ such that every $\{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{n-1}$ is a function of two adjacent input sequences $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ with range $[-1, 1]$. 
    We call a coupling strategy \textbf{valid} if, for \textbf{all} input sequences $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$, it satisfies the constraints in lemma \ref{mvPathCouplingLemma}.
\end{defn}

As before, we denote the cost of a coupling strategy $C=\{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{n-1}$ for a $k$v-path $\rho$ as $cost(C) = \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n-1}\left(|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}-\gamma_i'|d_i'+\sum_{j=1}^k|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}-\gamma_i^{(\texttt{x}_j)}|d_i\right)$.

\subsection{Syntactic structure}

Before we extend $k$v-paths to looping branches, we must again define an underlying structured graph from which collections of paths can be drawn.

We again will represent a structured program as a directed graph $G = (V, E)$, where $V$ represents a set of program locations; as before, every edge $e\in E$ is additionally labeled with a $k$v-transition $t = (c, \sigma, \tau)$ and there must be some unique initial location $\ell_0\in V$. 

Analogously to the single variable case, we require that $G = (V, E)$ satisfies the following conditions: 
\begin{itemize}
    \item \textbf{Determinism:} For all locations $\ell\in V$, if there exist distinct edges $(\ell, \ell')$ labeled by $t'=(c', \sigma', \tau')$ and $(\ell, \ell')$ labeled by $t'=(c', \sigma', \tau')$ labeled by $t^* = (c^*, \sigma^*, \tau^*)$, then $c'$ and $c^*$ must be logically disjoint; i.e. the boolean expression $c' \land c^*$ must be a contradiction. 
    In particular, note that this means that if there exists an edge $(\ell, \ell')\in E$ labeled by a transition of the form $(\texttt{true}, \sigma, \tau)$, then there does not exist another edge in $E$ with source at $\ell$.
    \item \textbf{Shared Noise:} For all locations $\ell\in V$ and any two edges $(\ell, \ell')$ labeled by $t'=(c', \sigma', \tau')$ and $(\ell, \ell^*)$ labeled by $t^* = (c^*, \sigma^*, \tau^*)$, $P(t') = P(t^*)$. 
    \item \textbf{Cross Coupling Compatibility:} There exists some constant $d_{at}>0$ such that for every edge $e\in E$ labeled by the transition $t = (c, \sigma, \tau)$, if $\tau \neq 0$ (i.e. $t$ is an assignment transition), $P(t) = (d_{at}, d'_t)$ for some $d'_t >0$.
\end{itemize}

We will again use $\Psi(r)$ to denote the forgetful homomorphism from a run $r$ in $G$ that drops all states from $r$ to produce a $k$v-path. 

\subsection{Loops and Programs}

\begin{defn}[$k$-variable Looping Branches]
    A $k$v-looping branch $L$ is a set of complete $k$v-paths generated by a structured program graph $G_L$ such that $L$ is a language described by a single union-free regular expression over a finite alphabet of transitions. 
\end{defn}

We can similarly define coupling strategies for $k$v-looping branches:

\begin{defn}[Coupling strategy for a $k$v-looping branch]
    Let $L$ be a $k$v-looping branch generated by the graph $G_L = (V_L, E_L)$, where $m = |E_L|$. Then a coupling strategy $C = \{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{m-1}$ for $L$ is a function $C:E_L\times\RR \times\RR\to [-1, 1]^{m(k+1)}$ that computes $k+1$ shifts for each transition-labeled edge in $L$ as a function of two adjacent inputs.
\end{defn}

Observe that a coupling strategy for a $k$v-looping branch $L$ induces a coupling strategy for each $k$v-path in $L$ in the same manner as the single variable case (see definition \ref{svInducedCouplingStrategy}). 

As expected, the cost $cost(C)$ of a coupling strategy $C$ for a $k$v-looping branch $L$ is the supremum of the costs of the $k$v-path coupling strategies induced by $C$ over all paths in $L$.

We translate the constraints for finite cost from single variable looping branches: 

\begin{defn}\label{mvPrivacyConstraintSystem}
    Let $L$ be a $k$v-looping branch generated by $G_L = (V_L, E_L)$ and let $C = \{\gamma_i^{(\texttt{x}_1)},\ldots, \gamma_i^{(\texttt{x}_k)}, \gamma_i'\}_{i=0}^{m-1}$ be a coupling strategy for $L$. If, for every path $\rho$ in $L$, the coupling strategy for $\rho$ induced by $C$ satisfies the constraints from lemma \ref{mvPathCouplingLemma} as well as the following constraints for all input sequences $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$ and all $i$: \begin{enumerate}
        \setcounter{enumi}{2}
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then for all $1\leq j\leq k$, $\gamma_i^{(\texttt{x}_j)} = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
        \item If $\Psi^{-1}(t_i)$ is in a cycle in $G_L$, then $\gamma_i' = -\texttt{in}\brangle{1}_i+\texttt{in}\brangle{2}_i$
    \end{enumerate}
    then we say that $C$ satisfies the privacy constraint system for $L$. 
\end{defn}

\begin{lemma}
    If a coupling strategy $C$ satisfies the privacy constraint system for a $k$v-looping branch $L$, then $cost(C)<\infty$ and $L$ is $cost(C)\varepsilon$-differentially private. 
\end{lemma}

\begin{proof}
    Because the privacy constraint system includes constraints for validity by definition, we know that $C$ is a valid coupling strategy. In particular, by lemma \ref{mvPathCouplingLemma}, this means that $C$ will produce a proof that $L$ is $cost(C)\varepsilon$-differentially private. 
    
    It remains to show that $C$ has finite cost. For every path $\rho\in L$, let $\rho^{(\texttt{x}_i)}$ be the single variable path created from $\rho$ by isolating every transition to the variable $\texttt{x}_i$. 

    Because of constraints (3) and (4), we know that, for all $\texttt{x}_i$, $\sup_{\rho\in L}\sum_{i=0}^{|\rho|-1}|\texttt{in}\brangle{2}-\texttt{in}\brangle{1}+\gamma_i^{(\texttt{x}_i)}|d_i + |\texttt{in}\brangle{2}-\texttt{in}\brangle{1}+\gamma_i'|d_i'$ is finite by applying lemma \ref{finiteCostConstraintLemma} to $\rho^{(\texttt{x}_i)}$ and a single variable coupling strategy constructed using $(\gamma^{(\texttt{x}_i)}, \gamma')$. 

    This immediately implies that $cost(C)$ is finite as well, since there are a finite number of program variables. 
\end{proof}



\subsection{Counterexamples when $k=2$}

\sky{TBD still working on this}

Like the single variable case, whenever the privacy constraint system is not satisfiable for a 2v-program, we can identify at least one of four types of graph structures in the corresponding GDiPA.

\begin{lemma}
    If no coupling strategy for a 2v-looping branch $L$ satisfies the privacy constraint system, then there exists a leaking cycle, non-cancelling leaking pair, disclosing cycle, or privacy violating path in a variable in $L$.
\end{lemma}
\begin{proof}
    Suppose that we have some maximally satisfied coupling strategy $C$ for $L$. There must be some constraint that is violated by $C$. Note that if constraint (11) is violated, then there must be a leaking cycle in $L$ since we only allow cross-couplings between assignment transitions. 

    Thus, we can assume that constraint (11) is not violated. 

    By lemma \ref{ProgramCounterexampleLemma}, there must then be either a leaking cycle, leaking pair, disclosing cycle, or privacy violating path with respect to a single variable. 

    We will show that, if there only exist leaking pairs in $L$, then at least one leaking pair must be a non-cancelling leaking pair. 

    For the sake of contradiction, suppose that every leaking pair $\kappa, \kappa'$ in $L$ is a cancelling leaking pair. 

    By definition, this means that for every two transitions $t_i, t_j$ in $\kappa, \kappa'$, $at_x(i) = at_x(j)$ and $at_y(i) = at_y(j)$.

    Without loss of generality, we will assume that every non-$\texttt{true}$ transition in $\kappa$ must either have guard $\lguard[\texttt{x}]\land\gguard[\texttt{y}]$ or $\lguard[\texttt{x}]\lor\gguard[\texttt{y}]$. Thus, every non-$\texttt{true}$ transition in $\kappa'$ must either have guard $\gguard[\texttt{x}]\land\lguard[\texttt{y}]$ or $\gguard[\texttt{x}]\lor\lguard[\texttt{y}]$, respectively. 

    Let $t_i$ be an arbitrary non-$\texttt{true}$ transition in $\kappa$ and $t_j$ be an arbitrary non-$\texttt{true}$ transition in $\kappa'$.

    Consider the case where $c_i = \lguard[\texttt{x}]\land\gguard[\texttt{y}]$ and $c_j = \gguard[\texttt{x}]\land\lguard[\texttt{y}]$; the other case is symmetric.

    Observe that at least one of $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$ or $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$ must be true. Suppose that $\texttt{in}_{at_x(i)}\brangle{1}\leq \texttt{in}_{at_y(i)}\brangle{1}$. The case where $\texttt{in}_{at_y(i)}\brangle{1}\geq \texttt{in}_{at_y(i)}\brangle{1}$ is symmetric. 

    Then we can set $\gamma_{at_x(i)} = -1$, $\gamma_{at_y(i)}=1$, and $\gamma_{(at_x(i), at_y(i))} =  -\max(0, \texttt{in}_{at_x(i)}\brangle{1}+ \gamma_{at_x(i)}^{(x)}-\texttt{in}_{at_y(i)}\brangle{1}-\gamma_{at_y(i)}^{(y)})$. 
    
    Because there do not exist disclosing cycles, leaking cycles, or privacy violating paths in either variable, this cannot violate any further constraints. Thus, $C$ is not maximal, which is our contradiction, so $L$ must contain either a leaking cycle, disclosing cycle, privacy violating path, or non-cancelling leaking pair in at least one variable.
\end{proof}

We also extend the DiPA counterexample results to show that the presence of any these four graph structures in a GDiPA must lead to a violation of privacy, which allows us to conclude that, even with two variables, coupling proofs are complete for 2v-programs.

\begin{lemma}
    If there exists a leaking cycle, disclosing cycle, or privacy violating path in a single variable or a non-cancelling leaking pair in a single variable in a GDiPA $A$, then $A$ is not $dvarepsilon$-differentially private for any $d>0$. 
\end{lemma}

\begin{thm}
    A GDiPA $A$ is $d\varepsilon$-differentially private for some $d>0$ if and only if there exists a valid and finite cost coupling strategy for every looping branch of $A$. 
\end{thm}

\subsection{Beyond Two Variables}

It is straightforward to extend the definitions of 2v-transitions, paths, looping branches, etc. to more than two variables; it is additionally straightforward to extend results like lemma \ref{mvParallelCouplingsLemma} to apply more than two variables. However, it is not immediately clear how cross-couplings would be extended to additional variables;
one obvious possibility is to allow for cross-couplings between \textit{all} possible pairs, but the completeness result likely would not generalize in the same fashion. 

\section{Conclusion}
We have shown how to use coupling techniques to prove privacy for a class of SVT-like programs first defined in \cite{chadhaLinearTimeDecidability2021} and discovered that couplings additionally characterize this class. We additionally showed that this can be done tractably, and that couplings can help provide lower bounds on privacy costs of these algorithms. 

Future work most naturally would focus on extensions of the program model. For the model, potential areas include removing the requirement for output to be deterministic of a path through the automaton, which would allow for algorithms such as Report Noisy Max to be captured by the model. Similarly, the alphabet of the automaton could be expanded to incorporate more than comparisons between two real numbers. 
Such extensions would naturally also require extensions of the class of couplings we define here, which are limited to ``shifts''. 

Additionally, we believe that couplings should completely characterize GDiPAs as well as DiPAs; proving this requires showing that a lack of well-formedness in any single variable generates a counterexample to privacy. 
In this vein, we would like to explore using couplings to \textit{disprove} privacy; the fact that shift couplings completely characterize DiPAs hints at the possibility of ``anti-couplings'' to generate counterexamples.