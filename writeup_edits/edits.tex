\documentclass[12pt]{article}

\usepackage[shortlabels]{enumitem} 
\usepackage{amsmath,amsfonts,amssymb,amsthm,bm,mathrsfs}
\usepackage{fancyhdr}
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{stmaryrd}
% \usepackage{mdframed}
\usepackage{hyperref}
\usepackage{xcolor, soul}
\sethlcolor{cyan}


\newcommand{\NN}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\notimplies}{\;\not\!\!\!\implies}
\newcommand{\gguard}[1][x]{\texttt{insample}\geq#1}
\newcommand{\lguard}[1][x]{\texttt{insample} < #1}
\newcommand{\gaguard}{n<N \text{ AND } \texttt{insample} \geq\ \texttt{x}}
\newcommand{\laguard}{n<N\text{ AND }\texttt{insample} < \texttt{x}}
\newcommand{\itgguard}{\texttt{input}\neq\tau\text{ AND } \texttt{insample}\geq\texttt{x}}
\newcommand{\itlguard}{\texttt{input}\neq\tau\text{ AND }\texttt{insample} < \texttt{x}}
\newcommand{\range}{\texttt{range}}
\newcommand{\brangle}[1]{\langle#1 \rangle}
\newcommand{\guard}{\texttt{guard}}
\newcommand{\trans}{\texttt{trans}}
\newcommand{\Lap}{\texttt{Lap}}
\newcommand{\gcycle}{\texttt{G}-cycle}
\newcommand{\lcycle}{\texttt{L}-cycle}
\newcommand{\sgn}{\texttt{sgn}}
\newcommand{\andtext}{\text{ AND }}
\newcommand{\ortext}{\text{ OR }}
\newcommand{\supp}{\texttt{supp}}

\newcommand{\im}{\texttt{im}}

\newcommand{\todo}[2]{\textcolor{#1}{\textbf{#2}}}
\newcommand{\sasho}[1]{\todo{blue}{Sasho: <<#1>>}}
\newcommand{\sky}[1]{\todo{green}{Sky: <<#1>>}}
\newcommand{\vishnu}[1]{\todo{magenta}{Vishnu: <<#1>>}}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\providecommand{\floor}[1]{\lfloor #1 \rfloor}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{obs}[thm]{Observation}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{const}[thm]{Construction}
\newtheorem{examp}[thm]{Example}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{rmk}[thm]{Remark}
\newtheorem{clm}[thm]{Claim}

\newcommand{\isto}{\stackrel{\sim}{\smash{\longrightarrow}\rule{0pt}{0.4ex}}} 
\graphicspath{ {./} }
\bibliographystyle{plain} 


\begin{document}


\section{Reworked Transition/Path semantics}

\subsection{(v1)}

\subsubsection{Transitions}

We can think of each transition as defining an extremely small program; beginning at location $q$, a transition reads a real valued input $\texttt{in}$, compares it to a threshold $\texttt{x}$, and, depending on the result of the comparison, moves to a location $q'$ while outputting a value $\sigma$ and possibly updating the value of $\texttt{x}$.

More specifically, given some threshold value $\texttt{x}$, each transition $t = (q, q', c, \sigma, \tau)$ will first read a real number input $\texttt{in}$, sample two random variables $z\sim\Lap(0, \frac{1}{d\varepsilon})$, $z'\sim\Lap(0, \frac{1}{d'\varepsilon})$, where $P(q) = (d, d')$, and then assign two variables $\texttt{insample} = \texttt{in} + z$ and $\texttt{insample}' = \texttt{in} + z'$. 
If the guard $c$ is satisfied by comparing $\texttt{insample}$ to $\texttt{x}$, then we transition to location $q'$, outputting $\sigma\in \Gamma\cup\{\texttt{insample}, \texttt{insample}'\}$ and, if $\tau = \texttt{true}$, reassigning $\texttt{x} = \texttt{insample}$. 

We can describe the semantics of a transition as a function that maps an initial program state and a real-valued input to a subsequent program state. 

We define a program state as a tuple consisting of a program location, a (sub)distribution of possible values for the program value $\texttt{x}$, and a distribution of possible values for the current output $\sigma$. 

Let $S = Q\times dist(\RR)\times (\Gamma \cup dist(\RR))^*$ be the set of all possible program states. 
As expected, every possible input is simply an element of $\RR$.

Then the semantics of a transition $t$ can be defined as a function $\Phi_t:dist_\downarrow(S)\times \RR \to dist_\downarrow (S)$ that maps a subdistribution of initial program states and an input to a subdistribution of subsequent program states. 

More precisely, if $t = (q, q', c, \sigma, \tau)$, let $P(q) = (d_q, d_q')$, let $\texttt{insample}$ be the Laplace distribution $\Lap(\texttt{in}, \frac{1}{d_q\varepsilon})$, and $\texttt{insample}'$ be the independent Laplace distribution $\Lap(\texttt{in}, \frac{1}{d_q'\varepsilon})$. Let $\theta$ be a subdistribution of program states. 

Then $\Phi_t(\theta, \texttt{in})$ is a subdistribution $O$ such that for all states $(q, \texttt{x}, \sigma_0)$, \begin{align*}
   \PP_O[(q', \texttt{x}, \sigma_0\cdot \sigma)]&= \begin{cases}
    \PP_\theta[(q, \texttt{x}, \sigma_0)]\PP[c \text{ is satisfied}]& \tau = \texttt{false}\\
    0 & \tau = \texttt{true}
  \end{cases} \\
  \PP_O[(q', \texttt{insample}, \sigma_0\cdot \sigma)]&= \begin{cases}
    \PP_\theta[(q, \texttt{x}, \sigma_0)]\PP[c \text{ is satisfied}]& \tau = \texttt{true}\\
    0 & \tau = \texttt{false}
  \end{cases} 
\end{align*}

Every other possible state is assigned probability 0 by $O$; with probability $1-\sum_{s\in S} \PP_O[s]$, we consider the transition to have halted.

We primarily are concerned with the probability that a transition ``succeeds'', that is, the probability that from location $q$, the program defined by $t$ transitions to location $q'$ and outputs a certain value $o$, where $o$ is either a symbol from a finite alphabet $\Gamma$ or a measurable event of $\RR$. 

We denote this probability as $\PP[\texttt{x}, t, \texttt{in}, o]$, where $\texttt{x} \in dist(\RR)$ is the initial distribution of $\texttt{x}$, $t$ is a transition, $\texttt{in}\in \RR$ is a real-valued input, and $o\in \Gamma\cup \mathcal{P}(\RR)$ is a possible output of $t$. 
Specifically, let $O = \Phi_t((q, \texttt{x}, \lambda), \texttt{in})$, where $\lambda$ represents the empty string, be a subdistribution; we abuse notation here by using $(q, \texttt{x}, \lambda)$ to represent the subdistribution that assigns probability 1 to the state $(q, \texttt{x}, \lambda)$. Then $\PP[\texttt{x}, t, \texttt{in}, o] = \int_{-\infty}^\infty\PP_O[\texttt{x} = x]\PP_O[(q', x, o)]dx$. \sky{is $\PP_O[\texttt{x}=x]$ coherent?}

Note that this is an aggregated probability over all possible final values of $\texttt{x}$ --- it is not particularly important what the specific final value of $\texttt{x}$ is. 

\subsubsection{Paths}

The semantics of a path can be defined as a function mapping a subdistribution of program states and a real-valued input sequence to a subdistribution of final program states. 

More specifically, the semantics of a path $\rho = t_0t_1\cdots t_{n-1}$ are a function $\Phi_\rho: dist_\downarrow(S)\times \RR^n \to dist_\downarrow(S)$. $\Phi_\rho$ can be defined by composing transition semantics:

\[\Phi_\rho(s, \texttt{in}) = \begin{cases}
    \Phi_{t_0}(s, \texttt{in}_0)& |\rho| = 1\\
    \Phi_{t_{n-1}}(\Phi_{\rho_{0:n-1}}(s, \texttt{in}_{0:n-1}), \texttt{in}_{n-1})& |\rho| >1
\end{cases}\]
\sky{Is there a nicer way to write this that I'm forgetting}

Like with transitions, we denote the probability that a path $\rho = q_0\to\ldots\to q_n$ ``succeeds'' given an initial $\texttt{x}\in dist(\RR)$, input sequence $\texttt{in} \in \RR^n$, and possible output sequence $o \in (\Gamma\cup\Sigma)^n$as $\PP[\texttt{x}, \rho, \texttt{in}, o] = \int_{-\infty}^\infty\PP_O[\texttt{x} =x]\PP_O[(q_{n}, x, o)]dx$, where $O$ is the subdistribution produced by $\Phi_\rho((q, \texttt{x}, \lambda), \texttt{in})$.
\sky{Same issue with $\PP_O[\texttt{x}=x]$}

\section{Without program locations}

\subsection{Transitions}

\begin{defn}[Transitions]
    A transition is a tuple $t = (c, \sigma, \tau)$, where \begin{itemize}
        \item $c\in \{\texttt{true}, \lguard[\texttt{x}], \gguard[\texttt{x}]\}$ is a guard for the transition.
        \item $\sigma \in \Gamma\cup\{\texttt{insample}, \texttt{insample}'\}$ is the output of $t$.
        \item $\tau\in\{\texttt{true}, \texttt{false}\}$ is a boolean value indicating whether or not the stored value of $\texttt{x}$ will be updated.
    \end{itemize}
\end{defn}

We additionally associate two real-valued noise parameters $P(t) = (d, d')$ with each transition. 

\subsubsection{Semantics}

[...]

Let $S = dist(\RR)\times (\Gamma \cup dist(\RR))^*$ be the set of all possible program states. 
As expected, every possible input is an element of $\RR$.

Then the semantics of a transition $t$ can be defined as a function $\Phi_t:dist_\downarrow(S)\times \RR \to dist_\downarrow (S)$ that maps a subdistribution of initial program states and an input to a subdistribution of subsequent program states. 

More precisely, if $t = (c, \sigma, \tau)$, let $P(t) = (d_t, d_t')$, let $\texttt{insample}$ be the Laplace distribution $\Lap(\texttt{in}, \frac{1}{d_t\varepsilon})$, and $\texttt{insample}'$ be the independent Laplace distribution $\Lap(\texttt{in}, \frac{1}{d_t'\varepsilon})$. Let $\theta$ be a subdistribution of program states. 

Then $\Phi_t(\theta, \texttt{in})$ is a subdistribution $O$ such that for all states $(\texttt{x}, \sigma_0)$, \begin{align*}
   \PP_O[(\texttt{x}, \sigma_0\cdot \sigma)]&= \begin{cases}
    \PP_\theta[(\texttt{x}, \sigma_0)]\PP[c \text{ is satisfied}]& \tau = \texttt{false}\\
    0 & \tau = \texttt{true}
  \end{cases} \\
  \PP_O[(\texttt{insample}, \sigma_0\cdot \sigma)]&= \begin{cases}
    \PP_\theta[(\texttt{x}, \sigma_0)]\PP[c \text{ is satisfied}]& \tau = \texttt{true}\\
    0 & \tau = \texttt{false}
  \end{cases} 
\end{align*}

Every other possible state is assigned probability 0 by $O$; with probability $1-\sum_{s\in S} \PP_O[s]$, we consider the transition to have halted.

[...]

\subsection{Paths}

\begin{defn}[Paths]
    A path is a string composed of transitions. For a path $\rho = t_0\cdot t_1\cdot\ldots\cdot t_{n-1}$, if $t_0$ is of the form $t_0 = (\texttt{true}, \sigma, \texttt{true})$ for some $\sigma$, then we call $\rho$ a \textbf{complete} path.
\end{defn}

\subsubsection{Semantics}

[identical to above]

\subsection{Branching}


In a vacuum, each path in a branching program describes a completely isolated program. However, by associating transitions with \textbf{program locations}, we can combine paths together to model program branching.

Suppose we have some finite set $Q$ of program locations. 

\begin{defn}[Fixed Transition]
    A fixed transition is a transition that transitions between two specific program locations. More precisely, a fixed transition is a transition $t=(c, \sigma, \tau)$ along with a start program location $q\in Q$ and a destination program location $q'\in Q$. We will often use the notation $t = (q, q', c, \sigma, \tau)$ to denote the fixed transition from $q$ to $q'$.
\end{defn}

\begin{defn}[Fixed Path]
    A fixed path is a sequence of fixed transitions $\rho = t_0\cdots t_{n-1}$ such that for all $i$, $t_i$ is of the form $t_i = (q_i, q_{i+1}, c_i, \sigma_i, \tau_i)$ for program locations $q_0,\ldots, q_n \in Q$. A fixed path is complete if, for some $q_0, q_1\in Q$, the fixed transition $t_0$ has the form $t_0 = (q_0, q_1, \texttt{true}, \sigma_0, \texttt{true})$.
    A fixed path can alternatively be modeled as a string of the form $(Q \Sigma_T)^*Q$, where $\Sigma_T$ is a finite alphabet of transitions. 
\end{defn}

We can now define branching programs.

\begin{defn}[Branching Programs]
    A branching program is a finite set of complete fixed paths over a finite transition alphabet $\Sigma_T$. 
\end{defn}

Let $\Sigma(B)$ be the set of all fixed transitions in a branching program $B$.

To ensure that a branching program models a coherent program, we must impose some constraints:
\begin{defn}[Coherence]
    A branching program $B$ is coherent if it satisfies all of the following properties:  
    \begin{itemize}
        \item \textbf{Initialization:} There exists some $q_0, q_1\in Q$ such that for all paths $\rho = t_0\cdots t_{n-1}\in B$, $t_0 = (q_0, q_1, \texttt{true}, \sigma_0, \texttt{true})$ for some $\sigma_0$.
        \item \textbf{Determinism}: If any fixed transition $t\in \Sigma(B)$ is of the form $t=(q, q', c, \sigma, \tau)$, then no other fixed transitions of the form $(q, q^*, c, \sigma', \tau')$ for $q, q', q^*\in Q$ exist in $\Sigma(B)$. 
        Additionally, if there exists a transition $t=(q, q', \texttt{true}, \sigma, \tau)$ such that $t\in \Sigma(B)$, then transitions of the form $(q, q^*, \lguard[\texttt{x}], \sigma', \tau')$ or $(q, q^*, \lguard[\texttt{x}], \sigma', \tau')$ are not in $\Sigma(B)$. 
        \item \textbf{Non-input location condition}: For all locations $q\in Q_{non}$, if there exists a transition $t=(q, q', c, \sigma, \tau)$ such that $t\in \Sigma_T$, then $c = \texttt{true}$. \sky{necessary for \textit{equivalence} with DiPA, not necessary for counterexample results}
    \end{itemize}
\end{defn}

\section{Original}

We now begin the process of building up a program model through the lens of regular languages. 
We will model programs as simply regular languages comprised of possible program paths (or executions) where each path corresponds to a word in the language. This approach simultaneously allows us to build approximate liftings for each path that prove the overall privacy of a program.

We begin with single transitions between two program locations, which correspond directly to characters in our alphabet. 

\sky{todo: add a note about treating $\varepsilon$ as a parameter to the program}

\subsection{Individual Transitions}

We will define transitions over an underlying finite set of program \textbf{locations}; a transition defines how a program moves from one location to the next. 

\begin{defn}[Program locations]
    $Q$ is a finite set of program locations partitioned into input locations $Q_{in}$ and non-input locations $Q_{non}$. We will also associate each program location with two \textbf{noise parameters} using the function $P: Q\to \RR^{\geq 0}\times \RR^{\geq 0}$.
\end{defn}

Transitions act as guarded statements whose guard is dependent on a persistent real-valued variable $\texttt{x}$ and a real-valued input to which random noise is added; we can thus formally define individual transitions as follows:

\begin{defn}[Transitions]
    Given a finite set of program locations $Q$, a transition is a tuple $t = (q, q', c, \sigma, \tau)$, where \begin{itemize}
        \item $q\in Q$ is the initial location.
        \item $q'\in Q$ is the following location.
        \item $c\in \{\texttt{true}, \lguard[\texttt{x}], \gguard[\texttt{x}]\}$ is a guard for the transition.
        \item $\sigma \in \Gamma\cup\{\texttt{insample}, \texttt{insample}'\}$ is the output of $t$.
        \item $\tau\in\{\texttt{true}, \texttt{false}\}$ is a boolean value indicating whether or not the stored value of $\texttt{x}$ will be updated.
    \end{itemize}
    Depending on context, we may also notate $t$ as $q\to q'$. 
\end{defn}


\subsubsection{Constructing an alphabet}

As mentioned, we will consider individual transitions as part of an \textit{alphabet}; in particular, we will show that there is an interesting set of regular languages over an alphabet of transitions that we can apply the coupling framework to. 

However, in order to ensure that these languages do in fact correspond to semantically coherent programs, we need to restrict possible transition alphabets as follows. 

\begin{defn}[Valid Transition Alphabets]
    Let $\Sigma_T$ be a finite alphabet of transitions. We call $\Sigma_T$ \textbf{valid} if it satisfies the following conditions:
    \begin{itemize}
        \item \textbf{Initialization:} There exists some $t_{init}\in \Sigma_T$ such that $t_{init} = (q_0, q_1, \texttt{true}, \sigma, \texttt{true})$ for some $q_0, q_1\in Q$, $\sigma \in \Gamma\cup\{\texttt{insample}, \texttt{insample}'\}$. 
        \item \textbf{Determinism}: If any transition $t\in \Sigma_T$ is of the form $t=(q, q', c, \sigma, \tau)$, then no other transitions of the form $(q, q^*, c, \sigma', \tau')$ for $q, q', q^*\in Q$ exist in $\Sigma_T$. 
        Additionally, if there exists a transition $t=(q, q', \texttt{true}, \sigma, \tau)$ such that $t\in \Sigma_T$, then transitions of the form $(q, q^*, \lguard[\texttt{x}], \sigma', \tau')$ or $(q, q^*, \lguard[\texttt{x}], \sigma', \tau')$ are not in $\Sigma_T$. 
        \item \textbf{Output distinction}: If there exist some $\sigma, \sigma', \tau, \tau'$ such that $(q, q', \lguard[\texttt{x}], \sigma, \tau)\in \Sigma_T$  and $(q, q^*, \gguard[\texttt{x}], \sigma', \tau') \in \Sigma_T$, then $\sigma \neq \sigma'$. Additionally, at least one of $\sigma\in \Gamma$, $\sigma'\in \Gamma$ is true.
        \item \textbf{Non-input location condition}: For all locations $q\in Q_{non}$, if there exists a transition $t=(q, q', c, \sigma, \tau)$ such that $t\in \Sigma_T$, then $c = \texttt{true}$.
    \end{itemize}
\end{defn}

\subsubsection{Transition Semantics}

We can think of each transition as defining an extremely small program; beginning at location $q$, a transition reads a real valued input $\texttt{in}$, compares it to a threshold $\texttt{x}$, and, depending on the result of the comparison, moves to a location $q'$ while outputting a value $\sigma$ and possibly updating the value of $\texttt{x}$.

More specifically, given some threshold value $\texttt{x}$, each transition $t = (q, q', c, \sigma, \tau)$ will first read a real number input $\texttt{in}$, sample two random variables $z\sim\Lap(0, \frac{1}{d\varepsilon})$, $z'\sim\Lap(0, \frac{1}{d'\varepsilon})$, where $P(q) = (d, d')$, and then assign two variables $\texttt{insample} = \texttt{in} + z$ and $\texttt{insample}' = \texttt{in} + z'$. 
If the guard $c$ is satisfied by comparing $\texttt{insample}$ to $\texttt{x}$, then we transition to location $q'$, outputting $\sigma$ and, if $\tau = \texttt{true}$, reassigning $\texttt{x} = \texttt{insample}$. 

We can describe the semantics of a transition as a function that maps an initial program location and a real-valued input to a distribution of subsequent program locations, an output value, and a possibly new value for $\texttt{x}$. 

To be precise, we define a program state as a tuple consisting of a program location and a value for the program variable $\texttt{x}$. Let $S = Q\times\RR$ be the set of all possible program states. As expected, every possible input is simply an element of $\RR$. 
An output can either be a symbol from some finite alphabet $\Gamma$ or a real number; thus, the set of all possible output events is $\Gamma \cup \Sigma$, where $\Sigma$ is some $\sigma$-algebra over $\RR$.
In particular, we will take $\Sigma$ to be the standard $\sigma$-algebra of all Lebesgue measurable sets. 

It follows that the semantics of a transition $t$ can be defined as a function $\Phi_t: S\times \RR\to dist(S\times (\Gamma\cup\RR\cup \lambda))$ that maps an initial program location $q\in Q$ and an input $\texttt{in}\in \RR$ to a distribution of subsequent program locations and an output event following the expected semantics; $\lambda$ here denotes the empty string (i.e. no output). 

{\color{red}[If we need space, move the following section to appendix]}

Let $q\in Q$ be an initial location, $\texttt{x}\in \RR$ be an initial threshold value, and $P(q) = (d_q, d_q')$ be the distributional parameters associated with $q$. Let $t = (q, q', c, \sigma, \tau)$ be the transition whose semantics we are defining. 

Let $\texttt{in}\in \RR$ be a real-valued input and $o\in (\Gamma\cup\Sigma\cup\lambda)$ be a possible output event of $t$.

Let $I\sim \Lap(\texttt{in}, \frac{1}{d_q\varepsilon})$ and $I'\sim \Lap(\texttt{in}, \frac{1}{d_q'\varepsilon})$ be independent random variables corresponding to $\texttt{insample}$ and $\texttt{insample}'$. 

For both $I$ and $I'$, given $o$, we say that $I$ (or $I'$, respectively) matches $o$ if $o\subseteq \RR$ and $I\in o$. 

Let $T$ be the event that $c$ is satisfied given $\texttt{x}$ and $\texttt{insample}=I$ and let $O$ be the event that, if $\sigma=\texttt{insample}$, then $I$ matches $o$ and if $\sigma = \texttt{insample}'$, then $I'$ matches $o$. 

Then $\Phi_t((q, \texttt{x}), \texttt{in})$ is a distribution that assigns probabilities to output events as follows:

If $\tau = \texttt{false}$, then $\Phi_t((q, \texttt{x}), \texttt{in})$ assigns probability 0 to all events $((q', \texttt{x}'), o)$ such that $\texttt{x}'\neq \texttt{x}$. For all other events $((q', \texttt{x}), o)$. $\Phi_t((q, \texttt{x}), \texttt{in})$ assigns probability $\PP[T\land O]$ to $((q', \texttt{x}), o)$ and probability $\PP[\lnot T]$ to the event $((q_{term}, \texttt{x}), \lambda)$.


Similarly, if $\tau = \texttt{true}$, then $\Phi_t((q, \texttt{x}), \texttt{in})$ assigns probability $\PP[T\land O] $ to the event $((q', I), o)$ and assigns probability $\PP[\lnot T]$ to the event $((q_{term}, I), \lambda)$.

Here, $q_{term}$ is a sink or terminal location with no transitions allowed out of it. Equivalently, we could say that the program simply terminates and fails to transition to any new state.

We primarily are concerned with the probability that a transition ``succeeds'', that is, the probability that from location $q$, the program defined by $t$ transitions to location $q'$ and outputs a certain value. 

We denote this probability as $\PP[\texttt{x}, t, \texttt{in}, o]$, where $\texttt{x} \in \RR$ is the initial value of $\texttt{x}$, $t$ is a transition, $\texttt{in}\in \RR$ is a real-valued input, and $o\in \Gamma\cup\Sigma$ is a possible output of $t$. Specifically, $\PP[\texttt{x}, t, \texttt{in}, o] = \int_{-\infty}^\infty\PP[\texttt{x}\gets \texttt{x}']\Phi_t((q, \texttt{x}), \texttt{in})((q', \texttt{x}'), o)d\texttt{x}'$, 
where $\PP[\texttt{x}\gets \texttt{x}']$ is the probability that $\texttt{x}$ is updated to have the value $\texttt{x}'$.

Note that this is an aggregated probability over all possible final values of $\texttt{x}$---it is not particularly important what the specific final value of $\texttt{x}$ is. 



\subsubsection{Couplings}

We will now construct couplings for transitions with the aim of using them as building blocks for proofs of privacy.

First, we need to adapt standard privacy definitions to our specific setting; recall that $\texttt{in}$, in reality, represents a \textbf{function} of some underlying dataset. This means that `closeness' in this context is defined as follows:

\begin{defn}[Adjacency]
    Two inputs $\texttt{in}\sim_{\Delta} \texttt{in}'$ are $\Delta$-adjacent if $|\texttt{in}-\texttt{in}'|\leq \Delta$. If $\Delta$ is not specified, we assume that $\Delta = 1$. 
\end{defn}

Additionally, recall that some program locations ($Q_{non}$) in our model do not read in any input; to model this, we require that whenever input is passed into a non-input location, the actual input value is always 0.

\begin{defn}[Valid inputs]
    Let $t = (q, q', c, \sigma, \tau)$ be a transition over $Q$. A valid input to $t$ is a real number $\texttt{in}$ such that if $q\in Q_{non}$, then $\texttt{in} = 0$.
    In general, we will assume that all inputs are valid.
\end{defn}

To construct approximate liftings, we will analyze the behaviour of two different \textbf{runs} of a transition $t = (q, q', c, \sigma, \tau)$, one with input $\texttt{in}\brangle{1}$ and one with input $\texttt{in}\brangle{2}$. 

Our approach to couplings will be that for every Laplace-distributed variable, we will couple the value of the variable in one run with its value in the other \textbf{shifted} by some amount. 

We differentiate between the values of variables in the first and second run by using angle brackets $\brangle{k}$, so, for example, we will take $X\brangle{1}$ to be the value of $\texttt{x}$ at location $q$ in the run of $t$ with input $\texttt{in}\brangle{1}$ and $X\brangle{2}$ to be the value of $\texttt{x}$ in the run of $t$ with input $\texttt{in}\brangle{2}$. 

We thus want to create the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}o\brangle{2}$, where $o\brangle{1}$ and $o\brangle{2}$ are random variables representing the possible outputs of $t\brangle{1}$ and $t\brangle{2}$, respectively.

We must guarantee two things: that if the first transition is taken, then the second is also taken and that both runs output the same value $\sigma$ when taking the transition. Note that if $c = \texttt{true}$, the first condition is trivially satisfied and when $\sigma\in \Gamma$, the second condition is trivially satisfied. 

This gives us our major coupling lemma, which defines a family of couplings for privacy proofs.

\begin{lemma}\label{indTransitionCoupling}
    Let $X\brangle{1}\sim \Lap(\mu\brangle{1}, \frac{1}{d_x\varepsilon}), X\brangle{2}\sim\Lap(\mu\brangle{2}, \frac{1}{d_x\varepsilon})$ be random variables be random variables representing possible initial values of $\texttt{x}$ and let $t = (q, q^*, c, \sigma, \tau)$ be a transition from some valid transition alphabet $\Sigma_T$.
    Let $P(q) = (d_q, d_q')$.

    Let $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ be an arbitrary adjacent input pair and let $o\brangle{1}$, $o\brangle{2}$ be random variables representing possible outputs of $t$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. 

    Then $\forall \varepsilon>0$ and for all $\gamma_x, \gamma_q, \gamma_q'\in [-1, 1]$ that satisfy the constraints \[
        \begin{cases}
          \gamma_q\leq\gamma_x & c = \lguard[\texttt{x}]\\
          \gamma_q\geq\gamma_x & c = \gguard[\texttt{x}]\\
          \gamma_q=0 & \sigma = \texttt{insample}\\
          \gamma_q'=0 & \sigma = \texttt{insample}'
        \end{cases},
      \]
      the lifting $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ is valid for $d = (|\mu\brangle{1}-\mu\brangle{2}+\gamma_x|)d_x+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q|)d_q+(|-\texttt{in}\brangle{1}+\texttt{in}\brangle{2}-\gamma_q'|)d_q'$.
\end{lemma}


\begin{defn}[Valid Coupling Strategies]
    A \textbf{valid coupling strategy} for a transition $t_i = (q_i, q_{i+1}, c_i, \sigma_i, \tau_i)$ is a tuple $C_i = (\gamma_x^{(i)}, \gamma_i, \gamma_i')\in [-1, 1]^3$ such that the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_x^{(i)} & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_x^{(i)} & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}'
        \end{cases},
      \]
      are all satisfied. 
\end{defn}


\subsection{Program Paths}

We now demonstrate how to concatenate transitions and their corresponding coupling strategies together into program \textit{paths}.

\begin{defn}[Program paths]
    Let $\Sigma_T$ be a valid transition alphabet with underlying location space $Q$. A program \textbf{path} is a sequence of transitions $t_0\cdot t_1\cdot \ldots\cdot t_{n-1}$ such that for all $i\in 0\ldots n-1$, $t_i = (q_i, q_{i+1}, c_i, \sigma_i, \tau_i)$ for some $c_i, \sigma_i, \tau_i$. We will often notate an path $\rho$ as $\rho = q_0\to q_1\to \ldots \to q_n$. 

    If a path $\rho$ is of the form $\rho = t_{init}\cdot \rho'$ for $\rho'\in \Sigma_T^*$, then we call $\rho$ a \textbf{complete} path. 
\end{defn}

The length of a path $\rho$ is simply the number of transitions that are concatenated together to form $\rho$. 

We define some useful notation for dealing with paths and sequences more generally. 

Given a path (or sequence) $\rho = t_0\cdot t_1\cdot \ldots\cdot t_{n-1}$, the \textbf{tail} of $\rho$ is notated by $tail(\rho) = t_1\cdot \ldots\cdot t_{n-1}$. 
We may additionally use the notation $\rho_{i:j}$ to represent the subpath (or subsequence) $t_it_{i+1}\cdots t_{j-1}$ of $\rho$. Using this notation, $tail(\rho) = \rho_{1:} = \rho_{1:n}$.

Whereas an individual transition reads in one real-valued input and outputted one output value, a path reads in a \textbf{sequence} of inputs and outputs a sequence of outputs, one for each transition in the path.

As before, we need to restrict the space of possible inputs to a path based on which locations in the path actually read in user input.
\begin{defn}
    For a path $\rho$ of length $n$, an input sequence $\texttt{in}\in \RR^n$ is valid if, for all $q_i$ in $\rho$ such that $q_i \in Q_{non}$, $\texttt{in}_i = 0$.  
\end{defn} 

We will assume that all input sequences are valid from now on. 

Interestingly, the constraints on valid transition alphabets, specifically the constraints of determinism and output distinction, mean that outputs uniquely correspond to paths; in other words, given a valid transition alphabet, knowing an output sequence uniquely determines which path must have produced the output. 

\begin{prop}
    Let $\Sigma_T$ be a valid transition alphabet and let $\Gamma$ be the finite output alphabet associated with $\Sigma_T$. Let $O\subset (\Gamma\cup\{\texttt{insample}, \texttt{insample}'\})^*$ be the set of all possible outputs of complete paths over $\Sigma_T$. There exists an injection $f: \Sigma_T\to t_{init}\Sigma_T^*$ from the set of all possible outputs to complete paths over $\Sigma_T$. 
\end{prop}

\subsubsection{Path Semantics}

As with transitions, we can think of paths as very limited programs consisting of a series of transitions concatenated together with a persistent threshold variable $\texttt{x}$. Naturally, paths will now consider as input a \textbf{sequence} of real numbers, and similarly output a \textbf{sequence} of real numbers or symbols - each transition reads in an input and outputs some value.

In particular, the semantics of a path $\rho = q_0\to \ldots \to q_n = t_0t_1\cdots t_{n-1}$ can be defined as the function $\Phi_{\rho}((q, \texttt{x}), \texttt{in}): S\times \RR^n\to dist(S\times (\RR\cup\Gamma\cup\lambda)^n)$ mapping an initial program state and a input sequence to a distribution of final program states and output sequences. 

$\Phi_{\rho}$ can be computed by composing the program semantics of individual transitions in the natural manner:

As before, let $\texttt{in}\in \RR^n$ be a sequence of inputs and let $\sigma \in (\Sigma\cup\Gamma\cup\lambda)^n$ be a sequence of possible output events.
Let $I\sim \Lap(\texttt{in}_0, \frac{1}{d_q\varepsilon})$ and $I'\sim \Lap(\texttt{in}_0, \frac{1}{d_q'\varepsilon})$ be independent random variables corresponding to $\texttt{insample}$ and $\texttt{insample}'$. 

Let $t_0 = (q, q', c_0, \sigma_0, \tau_0)$

Then \[
    \Phi_{\rho}((q, \texttt{x}), \texttt{in})((q', \texttt{x}'), \sigma) = \begin{cases}
        1 & ((q', \texttt{x}'), \sigma)=((q_0, \texttt{x}), \lambda)\land n = 0\\
        \PP[c_0\text{ is not satisfied}] & ((q', \texttt{x}'), \sigma) = ((q_{term}, \texttt{x}), \lambda)\land \tau_0 = \texttt{false} \\
        \PP[c_0\text{ is not satisfied}] & ((q', I), \sigma) = ((q_{term}, \texttt{x}), \lambda)\land \tau_0 = \texttt{true}\\
        \begin{gathered}
            \PP[c_0\text{ is satisfied}]*\\
            \Phi_{tail(\rho)}((q',\texttt{x}), tail(\texttt{in}))((q', \texttt{x}'), tail(\sigma))
        \end{gathered} & \sigma_0 \in \Gamma\land \tau_0 = \texttt{false}\\[15pt]
        \begin{gathered}
            \PP[c_0\text{ is satisfied}]*\\
            \Phi_{tail(\rho)}((q',I), tail(\texttt{in}))((q', \texttt{x}'), tail(\sigma))
        \end{gathered} & \sigma_0 \in \Gamma\land\tau_0 = \texttt{true}\\[15pt]
        \begin{gathered}
            \PP[c_0\text{ is satisfied}\land I \text{ matches }\sigma_0]*\\
            \Phi_{tail(\rho)}((q',\texttt{x}), tail(\texttt{in}))((q', \texttt{x}'), tail(\sigma))
        \end{gathered} & \sigma_0 = \texttt{insample}\land \tau_0 = \texttt{false}\\[15pt]
        \begin{gathered}
            \PP[c_0\text{ is satisfied}\land I \text{ matches }\sigma_0]*\\
            \Phi_{tail(\rho)}((q',I), tail(\texttt{in}))((q', \texttt{x}'), tail(\sigma))
        \end{gathered} & \sigma_0 = \texttt{insample}\land\tau_0 = \texttt{true}\\[15pt]
        \begin{gathered}
            \PP[c_0\text{ is satisfied}\land I' \text{ matches }\sigma_0]*\\
            \Phi_{tail(\rho)}((q',\texttt{x}), tail(\texttt{in}))((q', \texttt{x}'), tail(\sigma))
        \end{gathered} & \sigma_0 = \texttt{insample}'\land \tau_0 = \texttt{false}\\[15pt]
        \begin{gathered}
            \PP[c_0\text{ is satisfied}\land I' \text{ matches }\sigma_0]*\\
            \Phi_{tail(\rho)}((q',I), tail(\texttt{in}))((q', \texttt{x}'), tail(\sigma))
        \end{gathered} & \sigma_0 = \texttt{insample}'\land\tau_0 = \texttt{true}\\[15pt]
        0 & otherwise
    \end{cases}.
\]

As before, we primarily care about the probability of a ``successful'' execution of a path with a particular output, which we will denote as $\PP[\texttt{x}_0, \rho, \texttt{in}, \sigma]$, where $\texttt{x} \in \RR$ is the initial value of $\texttt{x}$, $\rho$ is the path we are concerned about, $\texttt{in}\in \RR^n$ is a real-valued input sequence, and $o\in (\Gamma\cup\Sigma\cup\lambda)^n$ is a possible output sequence of $\rho$. 
As before, $\PP[\texttt{x}_0, \rho, \texttt{in}, \sigma] =\int_{-\infty}^{\infty} \PP[\texttt{x}\gets \texttt{x}']\Phi_\rho((q_0, \texttt{x}_0), \texttt{in})((q_n, \texttt{x}'), \sigma)d\texttt{x}'$, where $t_0 = (q_0, q_1, c_0, \sigma_0, \tau_0)$ is the first character of $\rho$ and $t_{n-1} = (q_{n-1}, q_n, c_{n-1}, \sigma_{n-1}, \tau_{n-1})$ is the final character of $\rho$.

For a complete path $\rho$, note that the initial value of $\texttt{x}$ is irrelevant, so we will shorthand $\PP[\texttt{x}_0, \rho, \texttt{in}, \sigma]$ to $\PP[\rho, \texttt{in}, \sigma]$.


\subsubsection{Privacy}

By leveraging the construction of couplings for individual transitions, we can construct a set of approximate liftings for entire paths.

Because paths read in a \textit{sequence} of real-valued inputs, we need to slightly modify our definition of adjacency.

\begin{defn}[Adjacency for a sequence of inputs]
    Two input sequences $\{\texttt{in}_i\brangle{1}\}_{i=1}^n, \{\texttt{in}_i\brangle{2}\}_{i=1}^n$ of length $n$ are $\Delta$-adjacent (notated $\texttt{in}\brangle{1} \sim_{\Delta}\texttt{in}\brangle{2}$) if, for all $i\in [1\ldots n]$, $|\texttt{in}_i\brangle{1}-\texttt{in}_i\brangle{2}|\leq \Delta$. 

    As before, if $\Delta$ is not specified, we assume that $\Delta = 1$. 
\end{defn}

Thus, we have the following definition of privacy for complete paths:

\begin{defn}[$d\varepsilon$-differential privacy for a path]
    A complete path $\rho$ of length $n$ is $d\varepsilon$-differentially private for some $d>0$ if $\forall \varepsilon>0$, for all valid adjacent input sequences $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ of length $n$ and all possible output sequences $\sigma$ of length $n$, $\PP[\rho, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\rho, \texttt{in}\brangle{2}, \sigma]$.
\end{defn}

Because, under our model, a program is simply a collection of paths, it will also be convenient to define a notion of privacy for sets of (complete) paths:
\begin{defn}
    Let $S$ be a set of complete paths and let $O$ be a set of all possible outputs of paths in $S$. 
    Then $S$ is $d\varepsilon$-differentially private for some $d>0$ if, for all paths $\rho\in S$ and outputs $\sigma\in O$, $\forall \varepsilon>0$, for all valid adjacent input sequences $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$, $\PP[\rho, \texttt{in}\brangle{1}, \sigma]\leq e^{d\varepsilon}\PP[\rho, \texttt{in}\brangle{2}, \sigma]$.
\end{defn}

We observe that because of the path-output correspondence, we can equivalently look at each path of a set in isolation:
\begin{prop}
    Let $S$ be a set of complete paths; $S$ is $d\varepsilon$-differentially private for some $d>0$ if and only if, for all paths $\rho\in S$, $\rho$ is $d\varepsilon$-differentially private.
\end{prop}

Note that, following \cite{chadhaLinearTimeDecidability2021}, we slightly redefine $\varepsilon$-differential privacy as $d\varepsilon$-differential privacy, treating $\varepsilon$ as a universal scaling parameter that can be fine-tuned by users for their own purposes. 
We argue that this definition is functionally equivalent, since if we are targeting $\varepsilon^*$-differential privacy overall, we can always take $\varepsilon = \frac{\varepsilon^*}{d}$.

\subsubsection{Concatenating couplings}

Just as individual transitions can be concatenated to form program paths, we can compose together couplings associated with each transition to produce a coupling proof of privacy for an entire path. 

If $o\brangle{1}, o\brangle{2}$ are random variables representing the output of $\rho$ given input sequences $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively, 
then in order to show that a program path $\rho$ is differentially private we want to create the coupling $o\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}o\brangle{2}$ for some $d>0$ for all adjacent inputs $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$ and all possible outputs $\sigma$.

As it turns out, directly composing together the couplings from lemma \ref{indTransitionCoupling} are essentially sufficient; the constraints imposed upon shifts for a coupling for transition $t_i$ depend solely on the shift at the most recent \textbf{assignment transition} in $\rho$ (i.e. the most recent transition $t_j$ such that $\tau_j = \texttt{true}$). 
The coupling shifts for \textit{non-assignment transitions} can thus never impact each other. 

\begin{defn}[Assignment transitions]
    Let $A_\rho = \{t_i=(q_i, q_{i+1}, c_i, \sigma_i, \tau_i): \tau_i = \texttt{true}\}$ be the set of \textbf{assignment transitions} in a path $\rho$. Additionally, for every transition $t_i$ in $\rho$, let $t_{at(i)}$ be the most recent assignment transition in $\rho$; i.e., $at(i) = \max\{j<i: t_j\in A_\rho\}$. If such a $j$ does not exist, we set $at(i)=-1$. 
\end{defn}

In particular, note that for transition $t_i$, $\gamma_x = \gamma_{at(i)}$, where $\gamma_{-1}$ is the shift applied to the initial $\texttt{x}$-values $\texttt{x}_0\brangle{1}$ and $\texttt{x}_0\brangle{2}$ (for complete paths, note that $\gamma_{-1}$ is irrelevant).

Thus, for an individual transition $t_i$ of $\rho$, we have a family of valid coupling strategies $C_i(\gamma_{at(i)}, \gamma_i, \gamma_i')$. 

We can merge these coupling strategies together to create a proof of privacy for the entire path: 

\begin{lemma}\label{multTransitionsCouplingProof}
    Let $\rho = q_0\to \ldots \to q_n$ be a complete path of length $n$. 
    Let $\texttt{in}\brangle{1}\sim \texttt{in}\brangle{2}$ be arbitrary adjacent input sequences of length $n$. Additionally, fix some potential output $\sigma$ of $\rho$ of length $n$ and let $\sigma\brangle{1}$, $\sigma\brangle{2}$ be random variables representing possible outputs of $\rho$ given inputs $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$, respectively. Additionally, for all $q_i$, let $P(q_i) = (d_i, d_i')$.

    Then $\forall \varepsilon>0$ and for all $\{\gamma_i, \gamma_i'\}_{i=0}^{n-1}$ that, for all $i$, satisfy the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_{at(i)} & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_{at(i)} & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}'
        \end{cases},
      \]
      the lifting $\sigma\brangle{1}\{(a, b): a=\sigma\implies b=\sigma\}^{\#d\varepsilon}\sigma\brangle{2}$ is valid for $d = \sum_{i=0}^{n-1}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'$, and therefore $t$ is $d\varepsilon$-differentially private. 
\end{lemma}
\begin{proof}
    From the proof of lemma \ref{indTransitionCoupling}, we know that we can create the couplings $\texttt{insample}_i\brangle{1} +\gamma_i{(=)}^{\#(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i\varepsilon}\texttt{insample}_i\brangle{2}$ and $\texttt{insample}_i'\brangle{1} +\gamma_i'{(=)}^{\#(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'\varepsilon}\texttt{insample}_i'\brangle{2}$ for all $q_i$ in $\rho$. 

    Additionally, for some fixed $q_i$ in $\rho$, if we have the coupling $\texttt{x}_i\brangle{1}+\gamma_x (=)^{\#(|\hat{\mu_i}\brangle{1}-\hat{\mu_i}\brangle{2}+\gamma_x|)\hat{d_i}\varepsilon}x_i\brangle{2}$, where $\texttt{x}_i\brangle{1}\sim \Lap(\hat{\mu_i}\brangle{1}, \frac{1}{\hat{d_i}\varepsilon})$ and $\texttt{x}_i\brangle{2}\sim \Lap(\hat{\mu_i}\brangle{2}, \frac{1}{\hat{d_i}\varepsilon})$, then subject to the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_x & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_x & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}_i\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}_i'
        \end{cases},
      \]
    the coupling $\sigma_i\brangle{1}\{(a, b): a=\sigma_i\implies b=\sigma_i\}^{\#d\varepsilon}\sigma_i\brangle{2}$ is valid for some $d$. 

    Indeed, note that for all $i$, $\texttt{x}_i = \texttt{insample}_{at(i)}$ by definition. Thus, we have that $\texttt{x}_i\brangle{1}+\gamma_x (=)^{\#(|-\texttt{in}_{at(i)}\brangle{1}+\texttt{in}_{at(i)}\brangle{2}+\gamma_{at(i)}|)d_{at(i)}\varepsilon}x_i\brangle{2}$, and we must satisfy the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_{at(i)} & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_{at(i)} & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}_i\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}_i'
        \end{cases}
      \]
      for all $i$.

    Thus, we can put all of these couplings together to show that the coupling $\sigma_i\brangle{1}\{(a, b): a=\sigma_i\implies b=\sigma_i\}^{\#d\varepsilon}\sigma_i\brangle{2}$ is valid for some $d>0$.

    In particular, note that we have created at most one pair of couplings (for $\texttt{insample}$ and $\texttt{insample}$) for each $q_i$. Thus, the total coupling cost associated with each $q_i$ is at most $(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'$, 
    which gives us an overall coupling cost of $d = \sum_{i=0}^{n-1}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'$.
\end{proof}

As with individual transitions, lemma \ref{multTransitionsCouplingProof} implicitly defines an entire family of possible coupling proofs that demonstrate the privacy of a path.

\begin{defn}
    For a complete path $\rho$ of length $n$, \textbf{coupling strategy} is a tuple of two functions $\bm{\gamma}(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}):\RR^n\times \RR^n\to [-1, 1]^n$ and $\bm{\gamma}'(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}):\RR^n\times \RR^n\to [-1, 1]^n$ that produce shifts for each transition of $\rho$ for every possible pair of adjacent input sequences $\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$. 
    If $\texttt{in}\brangle{1}$ and $\texttt{in}\brangle{2}$ are clear from context, we will often shorthand notating a coupling strategy as $\bm{\gamma}$ and $\bm{\gamma}'$. 
\end{defn}


\begin{defn}
    For a complete path $\rho$ of length $n$, a coupling strategy $C_\rho = (\bm{\gamma}, \bm{\gamma}')$ is \textbf{valid} if $\forall \texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}$, $\bm{\gamma}(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})$ and $\bm{\gamma}'(\texttt{in}\brangle{1}, \texttt{in}\brangle{2})$ satisfy the constraints \[
        \begin{cases}
          \gamma_i\leq\gamma_{at(i)} & c_i = \lguard[\texttt{x}]\\
          \gamma_i\geq\gamma_{at(i)} & c_i = \gguard[\texttt{x}]\\
          \gamma_i=0 & \sigma_i = \texttt{insample}\\
          \gamma_i'=0 & \sigma_i = \texttt{insample}'
        \end{cases}.
      \]
\end{defn}

Thus, if we have a \textbf{valid} coupling strategy $C$ for a path $\rho$, then immediately by lemma \ref{multTransitionsCouplingProof}, we have a proof that $\rho$ is $d\varepsilon$-differentially private. 

\sky{how necessary are these following defs/props}

\begin{defn}
    For a complete path $\rho$ of length $n$, the \textbf{cost} of a coupling strategy $C_\rho=(\bm{\gamma}, \bm{\gamma}')$ is \[cost(C_\rho) = \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n-1}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i|)d_i+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'|)d_i'.\]

    Additionally, let $G$ be the set of all valid coupling strategies $C_\rho=(\bm{\gamma}, \bm{\gamma}')$ for $\rho$. Then the \textbf{coupling cost} of $\rho$ is 
    \[cost(\rho) = \min_{(\bm{\gamma}, \bm{\gamma}')\in G}cost((\bm{\gamma}, \bm{\gamma}')).\]
\end{defn}

Naturally, the existence of a valid coupling strategy bounds the privacy cost of any path. 

\begin{cor}
    If $C_\rho=(\bm{\gamma}, \bm{\gamma}')$ is valid, then $\rho$ is $cost(C_\rho)\varepsilon$-differentially private.
\end{cor}



\subsection{Branching} 
{\color{red} considering cutting this section - the major function it serves is to emphasize that, excepting loops, paths should all have their own coupling strategies, which could just be explained in the program section}


\begin{defn}[Branching program]
    A branching program $B$ is a finite set of complete paths over a valid transition alphabet $\Sigma_T$.
\end{defn}

Equivalently, a branching program is a language over $\Sigma_T$ that can be represented by a regular expression only using concatenation and finite union; every word in the language must also be of the form $t_{init}\Sigma_T^*$ and satisfy the path condition. 

Branching programs exemplify our conception of programs as simply collections of possible program executions; indeed, we will demonstrate that for the purposes of privacy, we can do no better than treating them as collections of paths.

\subsubsection{Privacy}

We first extend the definition of coupling strategies to sets of paths in the natural manner.

\begin{defn}[Coupling strategies]
    A coupling strategy $C$ for a branching program $B$ is a collection of (path) coupling strategies where each complete path $\rho\in B$ is assigned a coupling strategy $C_\rho$. 
\end{defn}

\begin{defn}
    A coupling strategy $C$ for a branching program $B$ is valid if, for every constituent path coupling strategy $C_\rho$, $C_\rho$ is valid. 
\end{defn}

\begin{defn}
    The cost of a coupling strategy $C$ for a branched program $B$ is $\max_{\rho\in B}cost(\rho)$.
\end{defn}

Notably, for a general branching program, there is no ``smart'' way to combine coupling strategies together; that is, in order to obtain the optimal coupling cost, we must find different coupling strategies for each path in a branching program. We provide a simple counterexample.

\sky{note: rephrase this proposition slightly}
\begin{prop}\label{costDependspathProp}
    Optimal cost is dependent on path. There exists a valid transition alphabet $\Sigma_T$, a location space $Q$, and a branching program $B$ for which the optimal cost of a coupling strategy $C$ for $B$ is dependent on the path $\rho$. 
    
    In other words, the optimal strategy $C$ must assign different coupling strategies to occurances of the same transition in different paths. 
\end{prop}

\begin{proof}
    Let $Q = \{q_0, q_1, q_2, q_3\}$ consist only of input locations, each of which have both noise parameters equal to $1$. Let $\Sigma_T = \{t_{init}, t_{geq1}, t_{leq1}, t_{leq2}, t_{geq2}\}$ where 
    \begin{align*}
        t_{init} &= (q_0, q_1, \texttt{true}, \bot, 1)\\
        t_{geq1} &= (q_1, q_2, \gguard[\texttt{x}], \top, 0)\\
        t_{leq1} &= (q_1, q_3, \lguard[\texttt{x}], \bot, 0)\\
        t_{geq2} &= (q_2, q_2, \gguard[\texttt{x}], \top, 0)\\
        t_{leq2} &= (q_3, q_3, \lguard[\texttt{x}], \bot, 0)
    \end{align*}
    and let $B = \{t_{init}t_{geq1}t_{geq2}^n, t_{init}t_{leq1}t_{leq2}^n\}$ be the branching program consisting of two paths, each of which have $n$ repetitions of the cycle transitions $t_{geq2}$ and $t_{leq2}$, respectively.

    Let $\rho_1 = t_{init}t_{geq1}t_{geq2}^n$ and $\rho_2 = t_{init}t_{leq1}t_{leq2}^n$ be the two paths in $B$. Notice the following: 
    
    \begin{itemize}
        \item The cost of any coupling strategy for $B$ must be at least $2$.
        
        Let $C_{\rho_1}$ be a coupling strategy for $\rho_1$. We can bound its cost as follows: 
        \begin{align*}
            cost(C_{\rho_1}) &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2}))\\&\qquad+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
            &\geq \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}} \sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
            &= \max_{\Delta \in [-1, 1]^{n+2}} \sum_{i=0}^{n+2}(|\Delta_i-\gamma_i(0, \Delta_i)|)\\
            &\geq |1 - \gamma_0(0, 1)| + \sum_{i=1}^{n+2}|-1-\gamma_i(0, -1)|\\
            &= 1 - \gamma_0(0, 1) + \sum_{i=1}^{n+2} (1+\gamma_i(0, -1))\\
            &= 1 - \gamma_0(0, 1) + (n + 2) + \sum_{i=1}^{n+2}\gamma_i(0, -1)\\
            &\geq 1 - \gamma_0(0, 1) + (n + 2) + \sum_{i=1}^{n+2}\gamma_0(0, 1) \qquad \text{(privacy constraint)}\\
            &= (n + 3) + (n + 1) \gamma_0(0, 1)\\
            &\geq 2
        \end{align*}

    and by a similar argument, $cost(C_{\rho_2})\geq 2$ for any coupling strategy $C_{\rho_2}$.

    \item There exists a coupling strategy $C^*$ for $B$ such that $cost(C^*) = 2$.
    
    We will first describe $C_{\rho_1}^* = (\gamma, \gamma')$. Since no transition outputs \texttt{insample}, we can set $\gamma_i'(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) = \texttt{in}\brangle{2} - \texttt{in}\brangle{1}$ for all $i$ with no privacy cost. Define 
    \begin{align*}
        \gamma_0(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= -1 \\
        \gamma_i(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= \texttt{in}_i\brangle{2} - \texttt{in}_i\brangle{1} \qquad \text{for all $i>0$}
    \end{align*}
    We see that $C^*_{\rho_1}$ is valid, since $\gamma_i\geq \gamma_{0}$ for all $i>0$. Further, we see that 
    \begin{align*}
        cost(C^*_{\rho_1}) &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2}))\\&\qquad+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
        &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}} |-\texttt{in}_0\brangle{1}+\texttt{in}_0\brangle{2}-\gamma_0(\texttt{in}_0\brangle{1}, \texttt{in}_0\brangle{2})| \\
        &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}} |-\texttt{in}_0\brangle{1}+\texttt{in}_0\brangle{2}+1|\\
        &\leq 2 
    \end{align*}
    showing that $cost(C^*_{\rho_1}) = 2$. Similarly, there is a coupling strategy $C^*_{\rho_2}$ for which $cost(C^*_{\rho_2}) = 2$. This shows that there is a coupling strategy $C^*$, consisting of $C^*_{\rho_1}$ and $C^*_{\rho_2}$, for which $cost(C^*) = 2$.
    
    \item Any coupling strategy $C$ that assigns the same coupling strategy to $t_{init}$ in both $\rho_1$ and $\rho_2$ must have cost $>2$.
    
    Let $C$ be as described, and assume that $C$ has optimal cost, ie. $cost(C) = 2$. If $\gamma_0(0, 1) \neq -1$ in $C_{\rho_1}$, then $cost(C_{\rho_1}) > 2$ in the same method as the above, a contradiction.  

    Thus, $\gamma_0(0, 1) = -1$ in $C_{\rho_1}$, which by hypothesis, means that $\gamma_0(0, 1) = -1$ in $C_{\rho_2}$. We have the privacy constraint $\gamma_i \leq \gamma_0$ on $\rho_2$, which also means that $\gamma_i = -1$ identically for all $i > 0$. However, this means that 
    \begin{align*}
        cost(C_{\rho_2}) &= \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}}\sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2}))\\&\qquad+(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i'(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
        &\geq \max_{\texttt{in}\brangle{1}\sim\texttt{in}\brangle{2}} \sum_{i=0}^{n+2}(|-\texttt{in}_i\brangle{1}+\texttt{in}_i\brangle{2}-\gamma_i(\texttt{in}_i\brangle{1}, \texttt{in}_i\brangle{2})|)\\
        &\geq \max_{\Delta \in [-1, 1]^{n+2}} |\Delta_0 - \gamma_i(0, \Delta_0)| + \sum_{i=1}^{n+2}(|\Delta_i-\gamma_i(0, \Delta_i)|)\\
        &\geq |1 - \gamma_i(0, 1)| + \sum_{i=1}^{n+2}(|1+1|)\\
        &= 2 \cdot (n + 2)
    \end{align*}
    showing that $C$ is not optimal, a contradiction. Therefore $cost(C) > 2$.

    \end{itemize}
    
    The above observations show that the optimal coupling strategy for $B$ must necessarily assign different coupling strategies to $t_{init}$ in $\rho_1$ and $\rho_2$.
\end{proof}

Indeed, there exist a family of counterexamples such that the relative ``cost'' of choosing a unified coupling strategy for a branching program increases quadratically in the size of the branching program.


\begin{prop}
    There exist a family of branching programs $\{B_n\}_{n\in \NN}$ for which the cost of any path-independent coupling strategy $C$ for $B_n$ is in $\Omega(n^2)$, but for which there exists a path-dependent coupling strategy $C'$ for $B_n$ with cost in $O(n)$.
\end{prop}

\begin{proof}
    Construct $B_n$ as follows. Consider a path $\rho = t_{true}^{(1)} t_{geq}^{(1)} \left(t_{leq}^{(1)}\right)^n \dots t_{true}^{(n)} t_{geq}^{(n)} \left(t_{leq}^{(n)}\right)^n$ where:

    \begin{itemize}
        \item $t_{true}^{(i)}$ are assignment transitions with guard \texttt{true}.
        \item $t_{geq}^{(i)}$ are assignment transitions with guard $\gguard$.
        \item $t_{leq}^{(i)}$ are non-assignment transitions with guard $\lguard$.
        \item The noise parameters for all transitions are $1$.
        \item None of the transitions output \texttt{insample}.
    \end{itemize}

    For each $i$, construct also the looping branch $L_i = L\left(t_{true}^{(n + i)} \left(t_{loop}^{(i)}\right)^* t_{geq}^{(i)}\right)$ such that each transition $t_{geq}^{(i)}$ is preceded by an arbitrary number of transitions with guard $\lguard$.
    
    Let $C$ be a path-independent coupling strategy for $B_n$ -- this menas that $C$ must assign the same shift to each transition in $B_n$. 

    From the privacy constraints on the looping branches $L_i$, we see that $\gamma_{t_{true}^{n + i}}(1, 0) = 1$ from the same method as in \ref{costDependspathProp}, which then implies from the constraint $\gamma_{t_{true}^{n + i}} \leq \gamma_{t_{geq}^{(i)}}$ that $\gamma_{t_{geq}^{(i)}}(1, 0) = 1$. 

    Since the preceding assignment transition for $t_{leq}^{(i)}$ is given by $t_{geq}^{(i)}$, for which we have the privacy constraint $\gamma_{t_{geq}^{(i)}} \leq \gamma_{t_{leq}^{(i)}}$, we see that $\gamma_{t_{leq}^{(i)}}(1, 0) = 1$ as well. 

    Computing the cost of the coupling strategy assigned to $\rho$, which has $n \cdot (n + 2)$ transitions, we get 

    \begin{align*}
        cost(C_\rho) &\geq \max_{\Delta = \texttt{in}\brangle{2} - \texttt{in}\brangle{1}} \sum_{i=1}^{n} \big(|\Delta_{t_{true}^{(i)}} - \gamma_{t_{true}^{(i)}}(-\Delta_{t_{true}^{(i)}}, 0)| + |\Delta_{t_{geq}^{(i)}} - \gamma_{t_{geq}^{(i)}}(-\Delta_{t_{geq}^{(i)}}, 0)| \\ & \qquad \qquad \qquad \qquad + n \cdot |\Delta_{t_{leq}^{(i)}} - \gamma_{t_{leq}^{(i)}}(-\Delta_{t_{leq}^{(i)}}, 0)|\big)\\
        &\geq \sum_{i = 1}^n \left(|-1 - \gamma_{t_{true}^{(i)}}(1, 0)| + |-1 - \gamma_{t_{geq}^{(i)}}(1, 0)| + n \cdot |-1 - \gamma_{t_{leq}^{(i)}}(1, 0)|\right)\\
        &= \sum_{i = 1}^n \left(|-1 - \gamma_{t_{true}^{(i)}}(1, 0)| + |-1 - 1| + n \cdot |-1 - 1|\right)\\
        &\geq \sum_{i = 1}^n \left(2 n + 1\right)\\
        &= n \cdot (2 n + 1)
    \end{align*} 

    whereas there exists another coupling strategy $C_\rho^* = (\gamma^*, \gamma^{'*})$ for $\rho$ that would assign 
    \begin{align*}
        \gamma_{t_{true}^{(i)}}^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= -\texttt{in}\brangle{1} + \texttt{in}\brangle{2}\\
        \gamma_{t_{geq}^{(i)}}^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= 1\\
        \gamma_{t_{leq}^{(i)}}^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= -\texttt{in}\brangle{1} + \texttt{in}\brangle{2}
    \end{align*}
    which satisfies the privacy constraints \[\gamma_{t_{true}^{(i)}}^* \leq \gamma_{t_{geq}^{(i)}}^* \geq \gamma_{t_{leq}^{(i)}}^*\] for all $i$, which has cost $2n$.
    
    For the looping branches $L_i$, the coupling strategy $C_{L_i}^* = (\gamma^*, \gamma^{'*})$ assigns

    \begin{align*}
        \gamma_{t_{true}^{(n + i)}}^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= 1\\
        \gamma_{t_{loop}^{(i)}}^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= -\texttt{in}\brangle{1} + \texttt{in}\brangle{2}\\
        \gamma_{t_{geq}^{(i)}}^*(\texttt{in}\brangle{1}, \texttt{in}\brangle{2}) &= 1
    \end{align*}

    which satisfies the privacy constraints \[\gamma_{t_{geq}^{(i)}}^* \geq \gamma_{t_{true}^{(n + i)}}^* \leq \gamma_{t_{loop}^{(i)}}^*\] for all $i$, and has cost $4$.
    
    Putting these strategies together, we have a coupling startegy $C^*$ for $B_n$ with cost $2n$, as opposed to at least $n (2n + 1)$ for any path-independent coupling strategy $C$.
\end{proof}


\end{document} 