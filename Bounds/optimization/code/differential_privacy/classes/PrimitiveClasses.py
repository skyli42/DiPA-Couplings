from fractions import Fraction
from typing import Literal, Union

import numpy as np

from helpers.constants import Guards, Outputs

Rational = Union[Fraction, int]

class TransitionInterface(object):
    def get_output(self):
        raise NotImplementedError

    def get_dest_state(self) -> 'State':
        raise NotImplementedError

    def is_assignment_transition(self):
        raise NotImplementedError

class State(object):

    def __init__(self,
                 label: str,
                 d: Rational = 1,
                 mu: Rational = 0,
                 d_prime: Rational = 1,
                 mu_prime: Rational = 0):
        """
        Initializes a State object for use in a DiPA.
        :param label: state label
        :param d: scale parameter for insample noise
        :param mu: mean for insample noise
        :param d_prime: scale parameter for insample' noise
        :param mu_prime: mean for insample' noise
        """

        self.label = label
        self.d = d
        self.mu = mu
        self.d_prime = d_prime
        self.mu_prime = mu_prime

        self.transitions: dict[Guards, Transition] = {}

    def generate_lap_noise(self, epsilon: Rational):
        """
        Generates Laplace noise based on parameters d, mu, d_prime, mu_prime.
        Draws z1 from the Lap(d * epsilon, mu) distribution.
        Draws z2 from the Lap(d_prime * epsilon, mu_prime) distribution.

        Above, we define Lap(k, mu) to have the distribution
            f_{k, mu} = (k/2) * exp(-k * | x - mu | )
        and so Lap(k, mu) is generated by np.random.laplace(mu, 1 / k ).

        :return: (z1, z2)
        """

        beta_1 = 1 / (self.d * epsilon)
        beta_2 = 1 / (self.d_prime * epsilon)

        z1 = np.random.laplace(float(self.mu), float(beta_1))
        z2 = np.random.laplace(float(self.mu_prime), float(beta_2))

        return z1, z2

    def add_transition(self,
                       dest_state: "State",
                       guard: Guards,
                       output: Outputs,
                       assignment_trans: bool
                       ) \
            -> "Transition":
        """
        Add the transition from this state to dest_state that is made on
        :param output:
        :param assignment_trans:
        :param dest_state:
        :param guard:
        :return:
        """
        if guard in self.transitions:
            raise TransitionAlreadyDefinedError

        trans = Transition(self, dest_state, guard, output, assignment_trans)

        self.transitions[guard] = trans

        return trans

    def get_next_transition(self, insample_gteq_x: bool) -> TransitionInterface:
        """
        Returns the transition from this state that is made on the given input.
        :param insample_gteq_x: Whether insample >= x in this state of the DiPA.
        :return: The transition from this state.
        """
        if Guards.TRUE_CONDITION in self.transitions:
            return self.transitions[Guards.TRUE_CONDITION]
        elif insample_gteq_x:
            return self.transitions[Guards.INSAMPLE_GTE_CONDITION]
        else:
            return self.transitions[Guards.INSAMPLE_LT_CONDITION]

    def is_terminal_state(self) -> bool:
        """
        Returns whether this state is a terminal state.
        :return: True if this state is a terminal state, False otherwise.
        """
        return len(self.transitions) == 0

    def has_assignment_transition(self) -> bool:
        """
        Returns whether this state has a transition that is an assignment transition.
        :return:
        """
        for cond, trans in self.transitions.items():
            if trans.is_assignment_transition():
                return True
        return False

    def validate_transitions(self) -> bool:
        """
        Validates that all transitions from this state are valid.
        :return:
        """

        # TODO
        return True

    def get_label(self) -> str:
        return self.label

    def __repr__(self):
        return f"{self.label}"


class TransitionAlreadyDefinedError(Exception):
    pass


class TransitionNotDefinedError(Exception):
    pass


class Transition(TransitionInterface):
    def __init__(self,
                 source_state: State,
                 dest_state: State,
                 guard: Guards,
                 output: Outputs,
                 assignment_trans: bool):
        """
        Initializes a Transition object for use in a DiPA.
        :param source_state: The source state of the transition.
        :param dest_state: The destination state of the transition.
        :param guard: The guard of the transition.
        :param output: The output (either BOT or TOP) of the transition.
        :param assignment_trans: Whether the transition is an assignment transition.
        """

        self.guard = guard
        self.source_state = source_state
        self.dest_state = dest_state
        self.output = output
        self.assignment_trans = assignment_trans

    def get_dest_state(self) -> State:
        """
        Returns the destination state of this transition.
        :return: The destination state of this transition.
        """
        return self.dest_state

    def get_output(self) -> Outputs:
        """
        Returns the output of this transition.
        :return: The output of this transition.
        """
        return self.output

    def is_assignment_transition(self) -> bool:
        """
        Returns whether this transition is an assignment transition.
        :return: True if this transition is an assignment transition, False otherwise.
        """
        return self.assignment_trans

    def __repr__(self) -> str:
        return f"({self.source_state} -> {self.dest_state}, {self.output}, {self.assignment_trans})"
